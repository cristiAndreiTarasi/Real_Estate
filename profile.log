FUNCTION  <SNR>3_SynSet()
Called 2 times
Total time:   0.158754
 Self time:   0.072120

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000015   syn clear
    2              0.000023   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    2              0.000013   let s = expand("<amatch>")
    2              0.000007   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    2              0.000005   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000039     for name in split(s, '\.')
    2   0.158562   0.071928       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    2              0.000007     endfor
    2              0.000004   endif

FUNCTION  <SNR>149_rgb2xterm()
Called 3 times
Total time:   0.003696
 Self time:   0.003696

count  total (s)   self (s)
    3              0.000011 		let best_match=0
    3              0.000009 		let smallest_distance = 10000000000
    3              0.000019 		let color = tolower(a:color)
    3              0.000025 		let r = s:hex[color[0:1]]
    3              0.000018 		let g = s:hex[color[2:3]]
    3              0.000016 		let b = s:hex[color[4:5]]
                            
    3              0.000017 		let vr = s:xvquant[r]
    3              0.000017 		let vg = s:xvquant[g]
    3              0.000015 		let vb = s:xvquant[b]
    3              0.000018 		let cidx = vr * 36 + vg * 6 + vb + 16
    3              0.000029 		let ccol = [ s:cubergb[vr], s:cubergb[vg], s:cubergb[vb], cidx ]
                            
  126              0.000372 		for [tr,tg,tb,idx] in [ ccol ] + s:xtermcolor
  123              0.000375 			let dr = tr - r
  123              0.000365 			let dg = tg - g
  123              0.000352 			let db = tb - b
  123              0.000572 			let distance = dr*dr + dg*dg + db*db
  123              0.000275 			if distance == 0 | return idx | endif
  243              0.000494 			if distance > smallest_distance | continue | endif
    3              0.000008 			let smallest_distance = distance
    3              0.000008 			let best_match = idx
    3              0.000004 		endfor
    3              0.000007 		return best_match

FUNCTION  <SNR>278_offset()
Called 4 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    4              0.000036 	let s:offset = s:mw_order == 'btt' ? ( a:height - s:res_count ) : 0
    4              0.000026 	retu s:offset > 0 ? ( repeat([''], s:offset) + a:lines ) : a:lines

FUNCTION  <SNR>134_obsolete_gitgutter_signs_to_remove()
Called 4 times
Total time:   0.000334
 Self time:   0.000237

count  total (s)   self (s)
    4              0.000019   let signs_to_remove = []  " list of [<id (number)>, ...]
    4              0.000013   let remove_all_signs = 1
    4   0.000149   0.000052   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
    4              0.000027   for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
                              endfor
    4              0.000016   let s:remove_all_old_signs = remove_all_signs
    4              0.000010   return signs_to_remove

FUNCTION  <SNR>278_buffunc()
Called 6 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
    6              0.000058 	if a:e && has_key(s:buffunc, 'enter')
                            		cal call(s:buffunc['enter'], [], s:buffunc)
                            	elsei !a:e && has_key(s:buffunc, 'exit')
                            		cal call(s:buffunc['exit'], [], s:buffunc)
                            	en

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 5 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    5              0.000075   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  ctrlspace#util#SetStatusline()
Called 1 time
Total time:   0.000362
 Self time:   0.000059

count  total (s)   self (s)
    1              0.000009 	if has("statusline")
    1   0.000349   0.000046 		silent! exe "let &l:statusline = " . s:config.StatuslineFunction
    1              0.000002 	endif

FUNCTION  ctrlspace#api#BufferList()
Called 33 times
Total time:   0.012471
 Self time:   0.009188

count  total (s)   self (s)
   33              0.000118 	let bufferList     = []
   33   0.002400   0.000328 	let singleList     = ctrlspace#buffers#Buffers(a:tabnr)
   33              0.000197 	let visibleBuffers = tabpagebuflist(a:tabnr)
                            
  131              0.000458 	for i in keys(singleList)
   98              0.000469 		let i = str2nr(i)
                            
   98              0.000548 		let bufname = bufname(i)
   98              0.000539 		let bufVisible = index(visibleBuffers, i) != -1
   98              0.000704 		let bufModified = (getbufvar(i, '&modified'))
                            
   98              0.000548 		if !strlen(bufname) && (bufModified || bufVisible)
                            			let bufname = '[' . i . '*No Name]'
                            		endif
                            
   98              0.000383 		if strlen(bufname)
   98              0.001142 			call add(bufferList, { "index": i, "text": bufname, "visible": bufVisible, "modified": bufModified })
   98              0.000139 		endif
   98              0.000152 	endfor
                            
   33   0.002251   0.001040 	call sort(bufferList, function("ctrlspace#engine#CompareByText"))
                            
   33              0.000069 	return bufferList

FUNCTION  358()
Called 3 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    3              0.000020     let sep_idx = stridx(a:cname, '/')
    3              0.000007     if sep_idx > 0
    3              0.000021         let ft = a:cname[: sep_idx-1]
    3              0.000015         let name = a:cname[sep_idx+1 :]
    3              0.000003     else
                                    let ft = &filetype
                                    let name = a:cname
                                endif
    3              0.000021     return get(self._checkerMap[ft], name, {})

FUNCTION  359()
Called 3 times
Total time:   0.000201
 Self time:   0.000080

count  total (s)   self (s)
    3   0.000198   0.000077     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  ctrlspace#search#UpdateSearchResults()
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000006 	if s:updateSearchResults
                            		let s:updateSearchResults = 0
                            		call ctrlspace#window#Kill(0, 0)
                            		call ctrlspace#window#Toggle(1)
                            	endif

FUNCTION  <SNR>278_ignore()
Called 1 time
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    1              0.000033 	let igdirs = [ '\.git', '\.hg', '\.svn', '_darcs', '\.bzr', '\.cdv', '\~\.dep', '\~\.dot', '\~\.nib', '\~\.plst', '\.pc', '_MTN', 'blib', 'CVS', 'RCS', 'SCCS', '_sgbak', 'autom4te\.cache', 'cover_db', '_build', ]
    1              0.000022 	let igfiles = [ '\~$', '#.+#$', '[._].*\.swp$', 'core\.\d+$', '\.exe$', '\.so$', '\.bak$', '\.png$', '\.jpg$', '\.gif$', '\.zip$', '\.rar$', '\.tar\.gz$', ]
    1              0.000056 	retu { 'dir': '\v[\/]('.join(igdirs, '|').')$', 'file': '\v'.join(igfiles, '|'), }

FUNCTION  airline#extensions#tabline#ctrlspace#add_tab_section()
Called 23 times
Total time:   0.010844
 Self time:   0.002536

count  total (s)   self (s)
   23              0.000063   if a:pos == 0
                                let pos_extension = ''
                              else
   23              0.000070     let pos_extension = '_right'
   23              0.000030   endif
                            
   46              0.000118   for tab in s:tab_list
   23              0.000047     if tab.current
   23              0.000045       if tab.modified
   18              0.000086         let group = 'airline_tabmod'.pos_extension
   18              0.000024       else
    5              0.000023         let group = 'airline_tabsel'.pos_extension
    5              0.000007       endif
   23              0.000027     else
                                  if tab.modified
                                    let group = 'airline_tabmod_unsel'.pos_extension
                                  else
                                    let group = 'airline_tabhid'.pos_extension
                                  endif
                                endif
                            
   23   0.008960   0.000652     call a:builder.add_section_spaced(group, '%'.tab.index.'T'.tab.title.ctrlspace#api#TabBuffersNumber(tab.index).'%T')
   23              0.000054   endfor

FUNCTION  syntastic#log#debug()
Called 217 times
Total time:   0.005062
 Self time:   0.003152

count  total (s)   self (s)
  217   0.004303   0.002393     if !s:_isDebugEnabled(a:level)
  217              0.000365         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  airline#util#exec_funcrefs()
Called 54 times
Total time:   0.222475
 Self time:   0.010220

count  total (s)   self (s)
  424              0.001209     for Fn in a:list
  415   0.217805   0.005550       let code = call(Fn, a:000)
  415              0.000993       if code != 0
   45              0.000094         return code
                                  endif
  370              0.000562     endfor
    9              0.000012     return 0

FUNCTION  <SNR>278_leavepre()
Called 1 time
Total time:   0.010736
 Self time:   0.000096

count  total (s)   self (s)
    1              0.000023 	if exists('s:bufnr') && s:bufnr == bufnr('%') | bw! | en
    1              0.000027 	if !( exists(s:ccex) && !{s:ccex} ) && !( has('clientserver') && len(split(serverlist(), "\n")) > 1 )
    1   0.010678   0.000038 		cal ctrlp#clra()
    1              0.000002 	en

FUNCTION  <SNR>110_has_lawrencium()
Called 961 times
Total time:   0.008562
 Self time:   0.008562

count  total (s)   self (s)
  961              0.007369   return exists('*lawrencium#statusline')

FUNCTION  buffergator#BuffergatorCycleMru()
Called 1 time
Total time:   0.066827
 Self time:   0.001741

count  total (s)   self (s)
    1              0.000012     if !exists("w:buffergator_mru")
                                    let w:buffergator_mru = g:buffergator_mru[:]
                                endif
    1              0.000004     if g:buffergator_mru_cycle_local_to_window
    1              0.000006         let l:mru_cycle_list = w:buffergator_mru
    1              0.000002     else
                                    let l:mru_cycle_list = g:buffergator_mru
                                endif
    1              0.000006     if len(l:mru_cycle_list) < 2
                                    call s:_buffergator_messenger.send_info("only one buffer available")
                                    return
                                endif
    1   0.000242   0.000064     let l:target_buf = s:_find_mru_bufnr(a:dir)
    1              0.000003     if l:target_buf > 0
    1              0.000005         if a:bufopencmd == ""
    1              0.000005             let l:bufopencmd = "buffer"
    1              0.000002         else
                                        let l:bufopencmd = a:bufopencmd
                                    endif
    1              0.000004         let g:buffergator_track_mru = 0
    1   0.066485   0.001577         execute "silent keepalt keepjumps " . l:bufopencmd . " " . l:target_buf
    1              0.000004         let g:buffergator_track_mru = 1
    1              0.000001     else
                                    call s:_buffergator_messenger.send_info("no previous/next existing buffers available")
                                endif

FUNCTION  <SNR>124_get_syn()
Called 30266 times
Total time:   2.412186
 Self time:   2.412186

count  total (s)   self (s)
30266              0.193393   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
30266              0.074132   let color = ''
30266              0.435591   if hlexists(a:group)
28932              0.602544     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
28932              0.040491   endif
30266              0.142282   if empty(color) || color == -1
                                " should always exists
 3552              0.083364     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
 3552              0.014044     if empty(color) || color == -1
 3022              0.007224       let color = 'NONE'
 3022              0.003515     endif
 3552              0.003644   endif
30266              0.061925   return color

FUNCTION  <SNR>77__is_quitting()
Called 6 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    6              0.000023     let quitting = 0
    6              0.000035     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
    6              0.000012     return quitting

FUNCTION  <SNR>113_check_mixed_indent_file()
Called 24 times
Total time:   0.021022
 Self time:   0.021022

count  total (s)   self (s)
   24              0.000371   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
   24              0.000202   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
   24              0.000071     let head_spc = '\v(^ +)'
   24              0.000029   endif
   24              0.010746   let indent_tabs = search('\v(^\t+)', 'nw')
   24              0.008968   let indent_spc  = search(head_spc, 'nw')
   24              0.000108   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
   24              0.000052     return ''
                              endif

FUNCTION  ctrlspace#api#StatuslineModeSegment()
Called 1 time
Total time:   0.000168
 Self time:   0.000164

count  total (s)   self (s)
    1              0.000004 	let statuslineElements = []
                            
    1   0.000018   0.000014 	let clv = ctrlspace#modes#CurrentListView()
                            
    1              0.000004 	if clv.Name ==# "Workspace"
                            		if clv.Data.SubMode ==# "load"
                            			call add(statuslineElements, s:config.Symbols.WLoad)
                            		elseif clv.Data.SubMode ==# "save"
                            			call add(statuslineElements, s:config.Symbols.WSave)
                            		endif
                            	elseif clv.Name ==# "Tab"
                            		call add(statuslineElements, s:createStatusTabline())
                            	elseif clv.Name ==# "Bookmark"
                            		call add(statuslineElements, s:config.Symbols.BM)
                            	else
    1              0.000003 		if clv.Name ==# "File"
                            			let symbol = s:config.Symbols.File
                            		elseif clv.Name ==# "Buffer"
    1              0.000003 			if clv.Data.SubMode == "visible"
                            				let symbol = s:config.Symbols.Vis
                            			elseif clv.Data.SubMode == "single"
    1              0.000004 				let symbol = s:config.Symbols.Sin
    1              0.000003 			elseif clv.Data.SubMode == "all"
                            				let symbol = s:config.Symbols.All
                            			endif
    1              0.000001 		endif
                            
    1              0.000002 		if s:modes.NextTab.Enabled
                            			let symbol .= " " . s:config.Symbols.NTM . ctrlspace#api#TabBuffersNumber(tabpagenr() + 1)
                            		endif
                            
    1              0.000006 		call add(statuslineElements, symbol)
                            
    1              0.000002 		if s:modes.Zoom.Enabled
                            			call add(statuslineElements, s:config.Symbols.Zoom)
                            		endif
    1              0.000002 	endif
                            
    1              0.000006 	if !empty(s:modes.Search.Data.Letters) || s:modes.Search.Enabled
                            		let searchElement = s:config.Symbols.SLeft . join(s:modes.Search.Data.Letters, "")
                            
                            		if s:modes.Search.Enabled
                            			let searchElement .= "_"
                            		endif
                            
                            		let searchElement .= s:config.Symbols.SRight
                            
                            		call add(statuslineElements, searchElement)
                            	endif
                            
    1              0.000002 	if s:modes.Help.Enabled
                            		call add(statuslineElements, s:config.Symbols.Help)
                            	endif
                            
    1              0.000004 	let separator = (a:0 > 0) ? a:1 : "  "
                            
    1              0.000006 	return join(statuslineElements, separator)

FUNCTION  <SNR>143_ExcludeOther()
Called 68 times
Total time:   0.001416
 Self time:   0.001416

count  total (s)   self (s)
   68              0.001119   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
                                return 1 | endif

FUNCTION  <SNR>278_regisfilter()
Called 3 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    3              0.000078 	retu substitute(getreg(a:reg), "[\t\n]", ' ', 'g')

FUNCTION  <SNR>36_savetofile()
Called 2 times
Total time:   0.169624
 Self time:   0.000057

count  total (s)   self (s)
    2   0.169622   0.000055 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>274_setUpBuffer()
Called 1 time
Total time:   0.107535
 Self time:   0.008935

count  total (s)   self (s)
    1   0.000019   0.000015 	setlocal noswapfile
    1   0.000017   0.000012 	setlocal buftype=nofile
    1   0.000013   0.000012 	setlocal bufhidden=delete
    1   0.000387   0.000020 	setlocal nobuflisted
    1   0.000014   0.000012 	setlocal nomodifiable
    1   0.000012   0.000009 	setlocal nowrap
    1   0.000010   0.000008 	setlocal nonumber
    1              0.000009 	if exists('+relativenumber')
    1   0.000014   0.000010 		setlocal norelativenumber
    1              0.000002 	endif
    1   0.000011   0.000008 	setlocal nocursorcolumn
    1   0.000010   0.000008 	setlocal nocursorline
    1   0.000011   0.000009 	setlocal nospell
    1   0.000013   0.000009 	setlocal nolist
    1   0.000017   0.000015 	setlocal cc=
    1   0.098179   0.000014 	setlocal filetype=ctrlspace
                            
    1   0.000046   0.000037 	call ctrlspace#context#SetPluginBuffer(bufnr("%"))
                            
    1   0.000012   0.000007 	let root = ctrlspace#roots#CurrentProjectRoot()
                            
    1              0.000004 	if !empty(root)
    1              0.000416 		silent! exe "lcd " . fnameescape(root)
    1              0.000003 	endif
                            
    1              0.000002 	if &timeout
    1              0.000004 		let b:timeoutlenSave = &timeoutlen
    1   0.000023   0.000011 		set timeoutlen=10
    1              0.000002 	endif
                            
    1              0.000004 	let b:updatetimeSave = &updatetime
                            
                            	" shellslash support for win32
    1              0.000008 	if has("win32") && !&ssl
                            		let b:nosslSave = 1
                            		set ssl
                            	endif
                            
    1              0.000006 	augroup CtrlSpaceUpdateSearch
    1              0.000335 		au!
    1              0.000011 		au CursorHold <buffer> call ctrlspace#search#UpdateSearchResults()
    1              0.000002 	augroup END
                            
    1              0.000002 	augroup CtrlSpaceLeave
    1              0.000035 		au!
    1              0.000007 		au BufLeave <buffer> call ctrlspace#window#Kill(0, 1)
    1              0.000001 	augroup END
                            
                            	" set up syntax highlighting
    1              0.000006 	if has("syntax")
    1              0.000006 		syn clear
    1              0.000051 		syn match CtrlSpaceNormal /  .*/
    1              0.000019 		syn match CtrlSpaceSelected /> .*/hs=s+1
    1              0.000001 	endif
                            
    1              0.000004 	call clearmatches()
                            
    1              0.000009 	if !s:config.UseMouseAndArrowsInTerm && !has("gui_running")
                            		" Block unnecessary escape sequences!
    1              0.000057 		noremap <silent><buffer><esc>[ :call ctrlspace#keys#MarkKeyEscSequence()<CR>
    1              0.000005 		let b:mouseSave = &mouse
    1   0.000012   0.000010 		set mouse=
    1              0.000002 	endif
                            
  160   0.000390   0.000384 	for k in ctrlspace#keys#KeyNames()
  159              0.001005 		let key = strlen(k) > 1 ? ("<" . k . ">") : k
                            
  159              0.000413 		if k == '"'
    1              0.000004 			let k = '\' . k
    1              0.000001 		endif
                            
  159              0.004731 		silent! exe "noremap <silent><buffer> " . key . " :call ctrlspace#keys#Keypressed(\"" . k . "\")<CR>"
  159              0.000275 	endfor

FUNCTION  <SNR>197_lash()
Called 10 times
Total time:   0.000375
 Self time:   0.000375

count  total (s)   self (s)
   10              0.000357 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  <SNR>64_match_highlight()
Called 4 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
    4              0.000079   let matches = matchlist(a:highlight, a:pattern)
    4              0.000017   if len(matches) == 0
    4              0.000008     return 'NONE'
                              endif
                              return matches[1]

FUNCTION  airline#extensions#nrrwrgn#apply()
Called 37 times
Total time:   0.005447
 Self time:   0.005447

count  total (s)   self (s)
   37              0.000530   if exists(":WidenRegion") == 2
                                let spc = g:airline_symbols.space
                                if !exists("*nrrwrgn#NrrwRgnStatus()") || empty(nrrwrgn#NrrwRgnStatus())
                                  call a:1.add_section('airline_a', printf('%s[Narrowed%s#%d]', spc, spc, b:nrrw_instn))
                                  let bufname=(get(b:, 'orig_buf', 0) ? bufname(b:orig_buf) : substitute(bufname('%'), '^Nrrwrgn_\zs.*\ze_\d\+$', submatch(0), ''))
                                  call a:1.add_section('airline_c', spc.bufname.spc)
                                  call a:1.split()
                                else
                                  let dict=nrrwrgn#NrrwRgnStatus()
                                  let vmode = { 'v': 'Char ', 'V': 'Line ', '': 'Block '}
                                  let mode = dict.visual ? vmode[dict.visual] : vmode['V']
                                  let winwidth = winwidth(0)
                                  if winwidth < 80
                                    let mode = mode[0]
                                  endif
                                  let title = (winwidth < 80 ? "Nrrw" : "Narrowed ")
                                  let multi = (winwidth < 80 ? 'M' : 'Multi')
                                  call a:1.add_section('airline_a', printf('[%s%s%s#%d]%s', (dict.multi ? multi : ""), title, mode, b:nrrw_instn, spc))
                                  let name = dict.fullname
                                  if name !=# '[No Name]'
                                    if winwidth > 100
                                      " need some space
                                      let name = fnamemodify(dict.fullname, ':~')
                                      if strlen(name) > 8
                                        " shorten name
                                        let name = substitute(name, '\(.\)[^/\\]*\([/\\]\)', '\1\2', 'g')
                                      endif
                                    else
                                      let name = fnamemodify(dict.fullname, ':t')
                                    endif
                                  endif
                                  let range=(dict.multi ? '' : printf("[%d-%d]", dict.start[1], dict.end[1]))
                                  call a:1.add_section('airline_c', printf("%s %s %s", name, range, dict.enabled ? (&encoding ==? 'utf-8'  ? "\u2713"  : '')  : '!'))
                                  call a:1.split()
                                  call a:1.add_section('airline_x', get(g:, 'airline_section_x').spc)
                                  call a:1.add_section('airline_y', spc.get(g:, 'airline_section_y').spc)
                                  call a:1.add_section('airline_z', spc.get(g:, 'airline_section_z'))
                                endif
                                return 1
                              endif

FUNCTION  airline#extensions#term#apply()
Called 40 times
Total time:   0.001406
 Self time:   0.001406

count  total (s)   self (s)
   40              0.000169   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_c', spc.'%f')
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  <SNR>36_mergelists()
Called 2 times
Total time:   0.002527
 Self time:   0.000552

count  total (s)   self (s)
    2   0.001987   0.000068 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    2              0.000372 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    2              0.000072 	let mrufs = s:mrufs + diskmrufs
    2   0.000091   0.000035 	retu s:chop(mrufs)

FUNCTION  syntastic#log#debugShowOptions()
Called 3 times
Total time:   0.000053
 Self time:   0.000037

count  total (s)   self (s)
    3   0.000044   0.000028     if !s:_isDebugEnabled(a:level)
    3              0.000005         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  airline#statusline()
Called 965 times
Total time:   0.032641
 Self time:   0.032641

count  total (s)   self (s)
  965              0.015103   if has_key(s:contexts, a:winnr)
  965              0.013840     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>277_pos()
Called 14 times
Total time:   0.000320
 Self time:   0.000320

count  total (s)   self (s)
   14              0.000160   let pos = getpos(a:mark)
   14              0.000128   return [pos[1], pos[2]]

FUNCTION  airline#check_mode()
Called 972 times
Total time:   6.120189
 Self time:   0.180941

count  total (s)   self (s)
  972              0.007669   let context = s:contexts[a:winnr]
                            
  972              0.006585   if get(w:, 'airline_active', 1)
  968              0.005758     let l:m = mode()
  968              0.003556     if l:m ==# "i"
   22              0.000108       let l:mode = ['insert']
   22              0.000053     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
   20              0.000110       let l:mode = ['visual']
   20              0.000043     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
  926              0.003860       let l:mode = ['normal']
  926              0.001271     endif
  968              0.009312     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  968              0.001338   else
    4              0.000015     let l:mode = ['inactive']
    4              0.000030     let w:airline_current_mode = get(g:airline_mode_map, '__')
    4              0.000004   endif
                            
  972              0.005508   if g:airline_detect_modified && &modified
  223              0.001523     call add(l:mode, 'modified')
  223              0.000305   endif
                            
  972              0.003037   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  972              0.008532   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  972              0.003062   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  972              0.002509   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
  972              0.009791   let mode_string = join(l:mode)
  972              0.007764   if get(w:, 'airline_lastmode', '') != mode_string
   52   0.041356   0.000727     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   52   5.899849   0.001230     call airline#highlighter#highlight(l:mode, context.bufnr)
   52              0.000258     let w:airline_lastmode = mode_string
   52              0.000064   endif
                            
  972              0.001741   return ''

FUNCTION  <SNR>278_PrtExit()
Called 3 times
Total time:   0.013405
 Self time:   0.000548

count  total (s)   self (s)
    3              0.000059 	let bw = bufwinnr('%')
    3              0.000244 	exe bufwinnr(s:bufnr).'winc w'
    3              0.000046 	if bufnr('%') == s:bufnr && bufname('%') == 'ControlP'
    3   0.012974   0.000117 		noa cal s:Close()
    3              0.000042 		noa winc p
    3              0.000006 	els
                            		exe bw.'winc w'
                            	en

FUNCTION  <SNR>278_SetWD()
Called 3 times
Total time:   0.036938
 Self time:   0.000655

count  total (s)   self (s)
    3              0.000044 	if has_key(a:args, 'args') && stridx(a:args['args'], '--dir') >= 0 && exists('s:dyncwd')
                            		cal ctrlp#setdir(s:dyncwd) | retu
                            	en
    3              0.000032 	if has_key(a:args, 'dir') && a:args['dir'] != ''
                            		cal ctrlp#setdir(a:args['dir']) | retu
                            	en
    3              0.000034 	let pmodes = has_key(a:args, 'mode') ? a:args['mode'] : s:pathmode
    3              0.000084 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]
    3              0.000021 	if (!type(pmodes))
                            		let pmodes = pmodes == 0 ? '' : pmodes == 1 ? 'a' : pmodes == 2 ? 'r' : 'c'
                            	en
    3              0.000065 	let spath = pmodes =~ 'd' ? s:dyncwd : pmodes =~ 'w' ? s:cwd : s:crfpath
    6              0.000094 	for pmode in split(pmodes, '\zs')
    9   0.036444   0.000161 		if ctrlp#setpathmode(pmode, spath) | retu | en
    3              0.000007 	endfo

FUNCTION  <SNR>93_Highlight_Matching_Pair()
Called 1198 times
Total time:   0.672314
 Self time:   0.672314

count  total (s)   self (s)
                              " Remove any previous match.
 1198              0.011329   if exists('w:paren_hl_on') && w:paren_hl_on
  273              0.001913     silent! call matchdelete(3)
  273              0.001152     let w:paren_hl_on = 0
  273              0.000475   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
 1198              0.009443   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
 1198              0.006347   let c_lnum = line('.')
 1198              0.005789   let c_col = col('.')
 1198              0.003146   let before = 0
                            
 1198              0.006849   let text = getline(c_lnum)
 1198              0.051194   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
 1198              0.005855   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
 1198              0.011821     let [c_before, c] = matches[1:2]
 1198              0.001950   endif
 1198              0.049505   let plist = split(&matchpairs, '.\zs[:,]')
 1198              0.008278   let i = index(plist, c)
 1198              0.002706   if i < 0
                                " not found, in Insert mode try character before the cursor
  741              0.004743     if c_col > 1 && (mode() == 'i' || mode() == 'R')
    2              0.000009       let before = strlen(c_before)
    2              0.000006       let c = c_before
    2              0.000008       let i = index(plist, c)
    2              0.000003     endif
  741              0.001486     if i < 0
                                  " not found, nothing to do
  741              0.001222       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
  457              0.000996   if i % 2 == 0
   13              0.000040     let s_flags = 'nW'
   13              0.000081     let c2 = plist[i + 1]
   13              0.000018   else
  444              0.001247     let s_flags = 'nbW'
  444              0.001257     let c2 = c
  444              0.002523     let c = plist[i - 1]
  444              0.000617   endif
  457              0.001225   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  457              0.000932   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
  457              0.004526   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
  457              0.140806   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
  457              0.003598   let stoplinebottom = line('w$')
  457              0.002345   let stoplinetop = line('w0')
  457              0.001231   if i % 2 == 0
   13              0.000053     let stopline = stoplinebottom
   13              0.000015   else
  444              0.001749     let stopline = stoplinetop
  444              0.000561   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  457              0.003103   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
  457              0.004002     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  457              0.000614   endif
  457              0.000651   try
  457              0.148966     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
  457              0.001237   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
  457              0.001066   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
  457              0.001737   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  273              0.001645     if exists('*matchaddpos')
  273              0.017973       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
  273              0.000457     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
  273              0.000850     let w:paren_hl_on = 1
  273              0.000320   endif

FUNCTION  <SNR>149_create_syn_match()
Called 316 times
Total time:   0.010567
 Self time:   0.006528

count  total (s)   self (s)
                            
  316              0.002044 	let pattern = submatch(0)
                            
  316              0.002341 	if has_key( b:css_color_syn, pattern ) | return | endif
    3              0.000014 	let b:css_color_syn[pattern] = 1
                            
    3              0.000022 	let rgb_color = get( s:pattern_color, pattern, '' )
                            
    3              0.000013 	if ! strlen( rgb_color )
    3              0.000014 		let hexcolor = submatch(1)
    3              0.000012 		let funcname = submatch(2)
                            
    3              0.000009 		if funcname == 'rgb'
                            			let rgb_color = s:rgb2color(submatch(3),submatch(4),submatch(5))
                            		elseif funcname == 'hsl'
                            			let rgb_color = s:hsl2color(submatch(3),submatch(4),submatch(5))
                            		elseif strlen(hexcolor) == 6
    3              0.000015 			let rgb_color = tolower(hexcolor)
    3              0.000009 		elseif strlen(hexcolor) == 3
                            			let rgb_color = substitute(tolower(hexcolor), '\(.\)', '\1\1', 'g')
                            		else
                            			throw 'css_color: create_syn_match invoked on bad match data'
                            		endif
                            
    3              0.000016 		let s:pattern_color[pattern] = rgb_color
    3              0.000003 	endif
                            
    3              0.000016 	if ! has_key( b:css_color_hi, rgb_color )
    3              0.000019 		let is_bright = get( s:color_bright, rgb_color, -1 )
    3              0.000007 		if is_bright == -1
    3              0.000028 			let r = s:hex[rgb_color[0:1]]
    3              0.000018 			let g = s:hex[rgb_color[2:3]]
    3              0.000018 			let b = s:hex[rgb_color[4:5]]
    3              0.000016 			let is_bright = r*30 + g*59 + b*11 > 12000
    3              0.000015 			let s:color_bright[rgb_color] = is_bright
    3              0.000004 		endif
                            
    3   0.004099   0.000060 		call s:create_highlight( rgb_color, is_bright )
    3              0.000019 		let b:css_color_hi[rgb_color] = is_bright
    3              0.000006 	endif
                            
                            	" iff pattern ends on word character, require word break to match
    3              0.000068 	if pattern =~ '\>$' | let pattern .= '\>' | endif
    3              0.000108 	exe 'syn match BG'.rgb_color.' /'.escape(pattern, '/').'/ contained containedin=@colorableGroup'
                            
    3              0.000007 	return ''

FUNCTION  airline#util#append()
Called 6727 times
Total time:   0.155732
 Self time:   0.155732

count  total (s)   self (s)
 6727              0.033892   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 6727              0.040987   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 6727              0.043867   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>277_handle_special_key()
Called 1 time
Total time:   0.000181
 Self time:   0.000074

count  total (s)   self (s)
                              " Use feedkeys here instead of calling the function directly to prevent
                              " increasing the call stack, since feedkeys execute after the current call
                              " finishes
    1              0.000007   if a:key == g:multi_cursor_next_key
    1              0.000004     if s:use_word_boundary == 1
    1   0.000128   0.000021       call s:feedkeys("\<Plug>(multiple-cursors-new-word)")
    1              0.000003     else
                                  call s:feedkeys("\<Plug>(multiple-cursors-new)")
                                endif
    1              0.000003   elseif a:key == g:multi_cursor_prev_key
                                call s:feedkeys("\<Plug>(multiple-cursors-prev)")
                              elseif a:key == g:multi_cursor_skip_key
                                call s:feedkeys("\<Plug>(multiple-cursors-skip)")
                              endif

FUNCTION  <SNR>65_throw()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000009   let v:errmsg = 'fugitive: '.a:string
                              throw v:errmsg

FUNCTION  <SNR>137_internalFilePath()
Called 1 time
Total time:   0.000231
 Self time:   0.000225

count  total (s)   self (s)
    1   0.000021   0.000015 	let root = ctrlspace#roots#CurrentProjectRoot()
    1              0.000012 	let fullPart = empty(root) ? "" : (root . "/")
                            
    1              0.000007 	if !empty(s:config.ProjectRootMarkers)
    1              0.000008 		for candidate in s:config.ProjectRootMarkers
    1              0.000008 			let candidatePath = fullPart . candidate
                            
    1              0.000153 			if isdirectory(candidatePath)
    1              0.000011 				return candidatePath . "/" . a:name
                            			endif
                            		endfor
                            	endif
                            
                            	return fullPart . "." . a:name

FUNCTION  <SNR>277_display_error()
Called 4 times
Total time:   0.000437
 Self time:   0.000404

count  total (s)   self (s)
    4   0.000159   0.000126   if s:bad_input == s:cm.size() && ((s:from_mode ==# 'n'    && has_key(g:multi_cursor_normal_maps, s:char[0])) ||  (s:from_mode =~# 'v\|V' && has_key(g:multi_cursor_visual_maps, s:char[0])))
                                " we couldn't replay it anywhere but we're told it's the beginning of a
                                " multi-character map like the `d` in `dw`
                                let s:retry_keys = s:char
                              else
    4              0.000018     let s:retry_keys = ""
    4              0.000014     if s:bad_input > 0
    1              0.000127       echohl ErrorMsg | echo "Key '".s:char."' cannot be replayed at ". s:bad_input." cursor location".(s:bad_input == 1 ? '' : 's') | echohl Normal
    1              0.000002     endif
    4              0.000007   endif
    4              0.000017   let s:bad_input = 0

FUNCTION  <SNR>77_UpdateErrors()
Called 3 times
Total time:   0.084167
 Self time:   0.000862

count  total (s)   self (s)
    3   0.000112   0.000056     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    3   0.000115   0.000062     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
    3   0.000095   0.000044     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    3   0.000113   0.000057     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    3   0.000142   0.000030     call s:modemap.synch()
                            
    3   0.002832   0.000049     if s:_skip_file(a:buf)
                                    return
                                endif
                            
    3   0.000668   0.000052     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
    3              0.000008     if run_checks
    3   0.074052   0.000062         call s:CacheErrors(a:buf, a:checker_names)
    3   0.000088   0.000050         call syntastic#util#setLastTick(a:buf)
    3              0.000006     elseif a:auto_invoked
                                    return
                                endif
                            
    3   0.000174   0.000029     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    3              0.000017     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    3   0.000112   0.000031     let do_jump = syntastic#util#var('auto_jump') + 0
    3              0.000009     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    3   0.000104   0.000029     if syntastic#util#var('always_populate_loc_list') || do_jump
    3   0.000430   0.000029         call loclist.setloclist(1)
    3              0.000012         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    3              0.000003     endif
                                " }}}3
                            
    3   0.004887   0.000039     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>274_setActiveLine()
Called 1 time
Total time:   0.000500
 Self time:   0.000230

count  total (s)   self (s)
    1              0.000006 	if !empty(s:modes.Search.Data.Letters) && s:modes.Search.Data.NewSearchPerformed
                            		call ctrlspace#window#MoveSelectionBar(line("$"))
                            
                            		if !s:modes.Search.Enabled
                            			call s:modes.Search.SetData("NewSearchPerformed", 0)
                            		endif
                            	else
    1   0.000012   0.000008 		let clv = ctrlspace#modes#CurrentListView()
                            
    1              0.000003 		if clv.Name ==# "Workspace"
                            			if clv.Data.LastBrowsed
                            				let activeLine = clv.Data.LastBrowsed
                            			else
                            				let activeLine = 1
                            				let aw         = ctrlspace#workspaces#ActiveWorkspace()
                            
                            				if aw.Status
                            					let currWsp = aw.Name
                            				elseif !empty(clv.Data.LastActive)
                            					let currWsp = clv.Data.LastActive
                            				else
                            					let currWsp = ""
                            				endif
                            
                            				if !empty(currWsp)
                            					let workspaces = ctrlspace#workspaces#Workspaces()
                            
                            					for i in range(b:size)
                            						if currWsp ==# workspaces[b:indices[i]]
                            							let activeLine = i + 1
                            							break
                            						endif
                            					endfor
                            				endif
                            			endif
                            		elseif clv.Name ==# "Tab"
                            			let activeLine = tabpagenr()
                            		elseif clv.Name ==# "Bookmark"
                            			let activeLine = 1
                            
                            			if !empty(clv.Data.Active)
                            				let bookmarks = ctrlspace#bookmarks#Bookmarks()
                            
                            				for i in range(b:size)
                            					if clv.Data.Active.Name ==# bookmarks[b:indices[i]].Name
                            						let activeLine = i + 1
                            						break
                            					endif
                            				endfor
                            			endif
                            		elseif clv.Name ==# "File"
                            			let activeLine = line("$")
                            		else
    1              0.000002 			let activeLine = 0
    1              0.000002 			let maxCounter = 0
    1              0.000002 			let lastLine   = 0
                            
    1              0.000006 			for i in range(b:size)
    1              0.000006 				if b:indices[i] == t:CtrlSpaceActivebuf
    1              0.000004 					let activeLine = i + 1
    1              0.000002 					break
                            				endif
                            
                            				let currentJumpCounter = ctrlspace#util#GetbufvarWithDefault(b:indices[i], "CtrlSpaceJumpCounter", 0)
                            
                            				if currentJumpCounter > maxCounter
                            					let maxCounter = currentJumpCounter
                            					let lastLine = i + 1
                            				endif
                            			endfor
                            
    1              0.000002 			if !activeLine
                            				let activeLine = (lastLine > 0) ? lastLine : b:size - 1
                            			endif
    1              0.000001 		endif
                            
    1   0.000298   0.000032 		call ctrlspace#window#MoveSelectionBar(activeLine)
    1              0.000001 	endif

FUNCTION  <SNR>116_update_tabline()
Called 1 time
Total time:   0.000562
 Self time:   0.000377

count  total (s)   self (s)
    1              0.000016   if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
                              endif
    1              0.000014   let match = expand('<afile>')
    1              0.000010   let ignore_bufadd_pat = get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', '\c\vgundo|undotree|vimfiler|tagbar|nerd_tree|startify')
    1              0.000004   if pumvisible()
                                return
                              elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
                              elseif empty(match) || airline#util#ignore_buf(match) || isdirectory(expand("<afile>"))
                                return
                              endif
    1   0.000136   0.000024   doautocmd User BufMRUChange
                              " sometimes, the tabline is not correctly updated see #1580
                              " so force redraw here
    1              0.000036   let &tabline = &tabline

FUNCTION  <SNR>77_QuitPreHook()
Called 1 time
Total time:   0.000390
 Self time:   0.000109

count  total (s)   self (s)
    1   0.000161   0.000016     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000044   0.000023     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
    1   0.000038   0.000009     if !syntastic#util#var('check_on_wq')
    1   0.000112   0.000026         call syntastic#util#setWids()
    1              0.000015         call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
    1              0.000002     endif
                            
    1              0.000007     if !empty(get(w:, 'syntastic_loclist_set', []))
                                    call SyntasticLoclistHide()
                                endif

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 955 times
Total time:   0.028591
 Self time:   0.028591

count  total (s)   self (s)
  955              0.008087   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
    2              0.000003     return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  <SNR>77_CacheErrors()
Called 3 times
Total time:   0.073990
 Self time:   0.001756

count  total (s)   self (s)
    3   0.000174   0.000059     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    3   0.002430   0.000125     call s:ClearCache(a:buf)
    3   0.000254   0.000035     let newLoclist = g:SyntasticLoclist.New([])
    3   0.000060   0.000027     call newLoclist.setOwner(a:buf)
                            
    3   0.002834   0.000051     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    3   0.000094   0.000037         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    3   0.000106   0.000051         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
    3   0.000107   0.000056             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    3   0.000113   0.000061             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
    3              0.000003         endif
    3   0.000180   0.000115         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    3   0.000097   0.000044         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    3   0.044842   0.000064         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
    3   0.000372   0.000110         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
    3              0.000017         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    3              0.000016         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    3              0.000006         let names = []
    3              0.000007         let unavailable_checkers = 0
    6              0.000015         for checker in clist
    3   0.000050   0.000030             let cname = checker.getCName()
    3   0.020765   0.000029             if !checker.isAvailable()
    3   0.000100   0.000046                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
    3              0.000012                 let unavailable_checkers += 1
    3              0.000006                 continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            call newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
    3              0.000011         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    3              0.000016         if len(clist) == unavailable_checkers
    3              0.000013             if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
    3   0.000097   0.000043                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
    3              0.000003             endif
    3              0.000004         endif
                                    " }}}3
                            
    3   0.000088   0.000039         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    3              0.000006         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    3              0.000003     endif
                            
    3   0.000529   0.000036     call newLoclist.deploy()

FUNCTION  ctrlp#utils#writecache()
Called 4 times
Total time:   0.460663
 Self time:   0.459014

count  total (s)   self (s)
    4   0.002020   0.000490 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    4   0.458573   0.458454 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    4              0.000038 	en

FUNCTION  <SNR>278_buildpat()
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000007 	let pat = a:lst[0]
    1              0.000003 	if s:matchnatural == 1
                            		for item in range(1, len(a:lst) - 1)
                            			let c = a:lst[item - 1]
                            			let pat .= (c == '/' ? '[^/]\{-}' : '[^'.c.'/]\{-}').a:lst[item]
                            		endfo
                            	els
    1              0.000008 		for item in range(1, len(a:lst) - 1)
                            			let pat .= '[^'.a:lst[item - 1].']\{-}'.a:lst[item]
                            		endfo
    1              0.000001 	en
    1              0.000001 	retu pat

FUNCTION  ctrlspace#window#GoToStartWindow()
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000014 	silent! exe t:CtrlSpaceStartWindow . "wincmd w"
                            
    1              0.000008 	if winrestcmd() != t:CtrlSpaceWinrestcmd
                            		silent! exe t:CtrlSpaceWinrestcmd
                            
                            		if winrestcmd() != t:CtrlSpaceWinrestcmd
                            			wincmd =
                            		endif
                            	endif

FUNCTION  airline#themes#get_highlight()
Called 5316 times
Total time:   1.722402
 Self time:   0.086310

count  total (s)   self (s)
 5316   1.717104   0.081012   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>149_clear_matches()
Called 1217 times
Total time:   0.021997
 Self time:   0.021997

count  total (s)   self (s)
 1217              0.013776 	call map(get(w:, 'css_color_match_id', []), 'matchdelete(v:val)')
 1217              0.005603 	let w:css_color_match_id = []

FUNCTION  ctrlp#nosy()
Called 7 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    7              0.000078 	retu !( has('syntax') && exists('g:syntax_on') )

FUNCTION  ctrlspace#util#HandleVimSettings()
Called 2 times
Total time:   0.000249
 Self time:   0.000108

count  total (s)   self (s)
    2   0.000138   0.000053 	call s:handleSwitchbuf(a:switch)
    2   0.000106   0.000050 	call s:handleAutochdir(a:switch)

FUNCTION  ctrlspace#util#NormalizeDirectory()
Called 2 times
Total time:   0.001091
 Self time:   0.001091

count  total (s)   self (s)
    2              0.001004 	let directory = resolve(expand(a:directory))
                            
    2              0.000053 	while directory[strlen(directory) - 1] == "/" || directory[strlen(directory) - 1] == "\\"
                            		let directory = directory[0:-2]
                            	endwhile
                            
    2              0.000008 	return directory

FUNCTION  ctrlspace#roots#FindProjectRoot()
Called 1 time
Total time:   0.000811
 Self time:   0.000811

count  total (s)   self (s)
    1              0.000175 	let projectRoot = fnamemodify(".", ":p:h")
                            
    1              0.000014 	if !empty(s:config.ProjectRootMarkers)
    1              0.000005 		let rootFound     = 0
    1              0.000153 		let candidate     = fnamemodify(projectRoot, ":p:h")
    1              0.000006 		let lastCandidate = ""
                            
    1              0.000007 		while candidate != lastCandidate
    1              0.000006 			for marker in s:config.ProjectRootMarkers
    1              0.000009 				let markerPath = candidate . "/" . marker
    1              0.000355 				if filereadable(markerPath) || isdirectory(markerPath)
    1              0.000006 					let rootFound = 1
    1              0.000003 					break
                            				endif
                            			endfor
                            
    1              0.000003 			if !rootFound
                            				let rootFound = exists("s:projectRoots[candidate]")
                            			endif
                            
    1              0.000003 			if rootFound
    1              0.000006 				let projectRoot = candidate
    1              0.000002 				break
                            			endif
                            
                            			let lastCandidate = candidate
                            			let candidate = fnamemodify(candidate, ":p:h:h")
                            		endwhile
                            
    1              0.000005 		return rootFound ? projectRoot : ""
                            	endif
                            
                            	return projectRoot

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 965 times
Total time:   0.342083
 Self time:   0.341535

count  total (s)   self (s)
  965              0.006951   if !exists('b:fugitive_name')
    1              0.000003     let b:fugitive_name = ''
    1              0.000001     try
    1   0.000579   0.000031       let buffer = fugitive#buffer()
                                  if buffer.type('blob')
                                    let b:fugitive_name = buffer.repo().translate(buffer.path())
                                  endif
                                catch
    1              0.000006     endtry
    1              0.000001   endif
                            
  965              0.004264   if empty(b:fugitive_name)
  965              0.304167     return fnamemodify(bufname('%'), s:fmod)
                              else
                                return fnamemodify(b:fugitive_name, s:fmod)
                              endif

FUNCTION  <SNR>278_lash()
Called 231 times
Total time:   0.006477
 Self time:   0.006477

count  total (s)   self (s)
  231              0.006144 	retu ( a:0 ? a:1 : s:dyncwd ) !~ '[\/]$' ? s:lash : ''

FUNCTION  <SNR>278_MapNorms()
Called 3 times
Total time:   0.003983
 Self time:   0.003983

count  total (s)   self (s)
    3              0.000034 	if exists('s:nmapped') && s:nmapped == s:bufnr | retu | en
    1              0.000014 	let pcmd = "nn \<buffer> \<silent> \<k%s> :\<c-u>cal \<SID>%s(\"%s\")\<cr>"
    1              0.000015 	let cmd = substitute(pcmd, 'k%s', 'char-%d', '')
    1              0.000004 	let pfunc = 'PrtFocusMap'
    1              0.000074 	let ranges = [32, 33, 125, 126] + range(35, 91) + range(93, 123)
    4              0.000010 	for each in [34, 92, 124]
    3              0.000135 		exe printf(cmd, each, pfunc, escape(nr2char(each), '"|\'))
    3              0.000005 	endfo
   93              0.000192 	for each in ranges
   92              0.002674 		exe printf(cmd, each, pfunc, nr2char(each))
   92              0.000173 	endfo
   11              0.000024 	for each in range(0, 9)
   10              0.000296 		exe printf(pcmd, each, pfunc, each)
   10              0.000015 	endfo
    6              0.000033 	for [ke, va] in items(s:kprange)
    5              0.000167 		exe printf(pcmd, ke, pfunc, va)
    5              0.000009 	endfo
    1              0.000004 	let s:nmapped = s:bufnr

FUNCTION  <SNR>278_MatchedItems()
Called 4 times
Total time:   0.066353
 Self time:   0.007683

count  total (s)   self (s)
    4              0.000031 	let exc = exists('s:crfilerel') ? s:crfilerel : ''
    4   0.007293   0.007218 	let items = s:narrowable() ? s:matched + s:mdata[3] : a:items
    4   0.000204   0.000064 	let matcher = s:getextvar('matcher')
    4              0.000041 	if empty(matcher) || type(matcher) != 4 || !has_key(matcher, 'match')
    4              0.000010 		unlet matcher
    4              0.000012 		let matcher = s:matcher
    4              0.000005 	en
    4              0.000012 	if matcher != {}
                            		let argms = has_key(matcher, 'arg_type') && matcher['arg_type'] == 'dict' ? [{ 'items':  items, 'str':    a:pat, 'limit':  a:limit, 'mmode':  s:mmode(), 'ispath': s:ispath, 'crfile': exc, 'regex':  s:regexp, }] : [items, a:pat, a:limit, s:mmode(), s:ispath, exc, s:regexp]
                            		let lines = call(matcher['match'], argms, matcher)
                            	el
    4   0.058554   0.000099 		let lines = s:MatchIt(items, a:pat, a:limit, exc)
    4              0.000011 	en
    4              0.000035 	let s:matches = len(lines)
    4              0.000016 	unl! s:did_exp
    4              0.000010 	retu lines

FUNCTION  ctrlp#complen()
Called 108 times
Total time:   0.001976
 Self time:   0.001976

count  total (s)   self (s)
                            	" By length
  108              0.001196 	let [len1, len2] = [strlen(a:1), strlen(a:2)]
  108              0.000470 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  <SNR>200_untracked_output()
Called 5 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
    5              0.000150   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
    5              0.000043     let a:dict.cfg.untracked[a:dict.file] = ''
    5              0.000006   endif

FUNCTION  <SNR>278_comptime()
Called 108 times
Total time:   0.067959
 Self time:   0.067959

count  total (s)   self (s)
                            	" By last modified time
  108              0.066843 	let [time1, time2] = [getftime(a:1), getftime(a:2)]
  108              0.000737 	retu time1 == time2 ? 0 : time1 < time2 ? 1 : -1

FUNCTION  496()
Called 1 time
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    1              0.000042   let obj = copy(self)
                              " List of Cursors we're managing
    1              0.000007   let obj.cursors = []
                              " Current index into the s:cursors array
    1              0.000005   let obj.current_index = -1
                              " This marks the starting cursor index into the s:cursors array
    1              0.000005   let obj.starting_index = -1
                              " We save some user settings when the plugin loads initially
    1              0.000023   let obj.saved_settings = { 'virtualedit': &virtualedit, 'cursorline': &cursorline, 'lazyredraw': &lazyredraw, 'paste': &paste, 'clipboard': &clipboard, }
                              " We save the window view when multicursor mode is entered
    1              0.000005   let obj.saved_winview = []
                              " Track whether we started multicursor mode from calling multiple_cursors#find
    1              0.000004   let obj.start_from_find = 0
    1              0.000003   return obj

FUNCTION  ctrlp#dirnfile()
Called 8 times
Total time:  15.455356
 Self time:   8.438285

count  total (s)   self (s)
    8   0.000797   0.000381 	let [items, cwd] = [[[], []], s:dyncwd.s:lash()]
27910              0.076308 	for each in a:entries
27902              6.413857 		let etype = getftype(each)
28618   7.435667   0.419012 		if s:igntype >= 0 && s:usrign(each, etype) | con | en
27186              0.087959 		if etype == 'dir'
10953              0.026474 			if s:showhidden | if each !~ '[\/]\.\{1,2}$'
                            				cal add(items[0], each)
                            			en | el
10953              0.085376 				cal add(items[0], each)
10953              0.017975 			en
10953              0.019858 		elsei etype == 'link'
    2              0.000004 			if s:folsym
                            				let isfile = !isdirectory(each)
                            				if s:folsym == 2 || !s:samerootsyml(each, isfile, cwd)
                            					cal add(items[isfile], each)
                            				en
                            			en
    2              0.000004 		elsei etype == 'file'
16231              0.117079 			cal add(items[1], each)
16231              0.025211 		en
27186              0.105590 	endfo
    8              0.000018 	retu items

FUNCTION  gitgutter#utility#set_repo_path()
Called 8 times
Total time:   0.361915
 Self time:   0.001676

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    8   0.000430   0.000119   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    8   0.020644   0.000343   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' ls-files --error-unmatch --full-name '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    8   0.000176   0.000130   if g:gitgutter_async && gitgutter#async#available()
    8              0.000065     if has('lambda')
    8   0.340111   0.000530       call gitgutter#async#execute(cmd, a:bufnr, {   'out': {bufnr, path -> gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))},   'err': {bufnr       -> gitgutter#utility#setbufvar(bufnr, 'path', -2)}, })
    8              0.000012     else
                                  call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:set_path', [-2]) })
                                endif
    8              0.000009   else
                                let path = gitgutter#utility#system(cmd)
                                if v:shell_error
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                else
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                                endif
                              endif

FUNCTION  <SNR>277_apply_highlight_fix()
Called 4 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
                              " Only do this if we're on the last character of the line
    4              0.000044   if col('.') == col('$')
                                let s:saved_line = getline('.')
                                if s:from_mode ==# 'i'
                                  silent! undojoin | call setline('.', s:saved_line.' ')
                                else
                                  call setline('.', s:saved_line.' ')
                                endif
                              endif

FUNCTION  ctrlp#init()
Called 3 times
Total time: 162.741323
 Self time:   0.001102

count  total (s)   self (s)
    3   0.000361   0.000105 	if exists('s:init') || s:iscmdwin() | retu | en
    3              0.000032 	let [s:ermsg, v:errmsg] = [v:errmsg, '']
    3              0.000021 	let [s:matches, s:init] = [1, 1]
    3   0.009129   0.000076 	cal s:Reset(a:0 ? a:1 : {})
    3   0.022766   0.000098 	noa cal s:Open()
    3   0.037022   0.000084 	cal s:SetWD(a:0 ? a:1 : {})
    3   0.004059   0.000076 	cal s:MapNorms()
    3   0.007701   0.000061 	cal s:MapSpecs()
    3              0.000026 	if empty(g:ctrlp_types) && empty(g:ctrlp_ext_vars)
                            		call ctrlp#exit()
                            		retu
                            	en
    3              0.000014 	if type(a:type) == 0
    3              0.000010 		let type = a:type
    3              0.000003 	el
                            		let type = index(g:ctrlp_types, a:type)
                            		if type == -1
                            			call ctrlp#exit()
                            			retu
                            		en
                            	en
    3 162.318924   0.000090 	cal ctrlp#setlines(s:settype(type))
    3   0.003869   0.000064 	cal ctrlp#syntax()
    3   0.000077   0.000053 	cal s:SetDefTxt()
    3   0.000115   0.000026 	let curName = s:CurTypeName()
    3              0.000037 	let shouldExitSingle = index(s:opensingle, curName[0])>=0 || index(s:opensingle, curName[1])>=0
    3              0.000014 	if shouldExitSingle && s:ExitIfSingleCandidate()
                            		return 0
                            	en
    3   0.336995   0.000064 	cal s:BuildPrompt(1)
    3              0.000021 	if s:keyloop | cal s:KeyLoop() | en
    3              0.000007 	return 1

FUNCTION  <SNR>278_narrowable()
Called 4 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    4              0.000069 	retu exists('s:act_add') && exists('s:matched') && s:matched != [] && exists('s:mdata') && s:mdata[:2] == [s:dyncwd, s:itemtype, s:regexp] && s:matcher == {} && !exists('s:did_exp')

FUNCTION  <SNR>278_comparent()
Called 108 times
Total time:   0.034752
 Self time:   0.008391

count  total (s)   self (s)
                            	" By same parent dir
  108              0.000723 	if !stridx(s:crfpath, s:dyncwd)
  108   0.008621   0.002788 		let [as1, as2] = [s:dyncwd.s:lash().a:1, s:dyncwd.s:lash().a:2]
  108   0.023055   0.002527 		let [loc1, loc2] = [s:getparent(as1), s:getparent(as2)]
  108              0.000879 		if loc1 == s:crfpath && loc2 != s:crfpath | retu -1 | en
  103              0.000714 		if loc2 == s:crfpath && loc1 != s:crfpath | retu 1  | en
  103              0.000186 		retu 0
                            	en
                            	retu 0

FUNCTION  airline#highlighter#highlight()
Called 70 times
Total time:   6.320992
 Self time:   0.601845

count  total (s)   self (s)
   70              0.000360   let bufnr = a:0 ? a:1 : ''
   70              0.000517   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   70              0.001512   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   70              0.000509   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
  166              0.000546   for mode in mapped
   96              0.000566     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
    9              0.000033       continue
                                endif
   87              0.001074     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   87              0.000665       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
 2116              0.010049       for kvp in items(dict)
 2029              0.009706         let mode_colors = kvp[1]
 2029              0.008989         let name = kvp[0]
 2029              0.012483         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    8              0.000034           let name = 'airline_c'.bufnr
    8              0.000010         endif
 2029   1.181249   0.029954         call airline#highlighter#exec(name.suffix, mode_colors)
                            
 6087              0.025390         for accent in keys(s:accents)
 4058              0.021657           if !has_key(p.accents, accent)
                                        continue
                                      endif
 4058              0.032786           let colors = copy(mode_colors)
 4058              0.024932           if p.accents[accent][0] != ''
 2029              0.013565             let colors[0] = p.accents[accent][0]
 2029              0.003220           endif
 4058              0.019989           if p.accents[accent][2] != ''
 2029              0.011874             let colors[2] = p.accents[accent][2]
 2029              0.003086           endif
 4058              0.015470           if len(colors) >= 5
 4058              0.032619             let colors[4] = get(p.accents[accent], 4, '')
 4058              0.006987           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
 4058   2.343673   0.069392           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
 4058              0.007706         endfor
 2029              0.003484       endfor
                            
                                  " TODO: optimize this
 1929              0.008389       for sep in items(s:separators)
 1842   2.328884   0.035313         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
 1842              0.003535       endfor
   87              0.000195     endif
   87              0.000175   endfor

FUNCTION  SyntaxCheckers_vim_vimlint_IsAvailable()
Called 1 time
Total time:   0.019603
 Self time:   0.019536

count  total (s)   self (s)
    1              0.000003     try
                                    " Vim 7.2-051 and later
    1              0.009629         let vimlparser = globpath(&runtimepath, 'autoload/vimlparser.vim', 1)
    1              0.009830         let vimlint    = globpath(&runtimepath, 'autoload/vimlint.vim', 1)
    1              0.000006     catch /\m^Vim\%((\a\+)\)\=:E118/
                                    let vimlparser = globpath(&runtimepath, 'autoload/vimlparser.vim')
                                    let vimlint    = globpath(&runtimepath, 'autoload/vimlint.vim')
                                endtry
    1   0.000114   0.000047     call self.log("globpath(&runtimepath, 'autoload/vimlparser.vim', 1) = " . string(vimlparser) . ', ' . "globpath(&runtimepath, 'autoload/vimlint.vim', 1) = " .    string(vimlint))
    1              0.000004     return vimlparser !=# '' && vimlint !=# ''

FUNCTION  <SNR>63_not_git_dir()
Called 228 times
Total time:   0.324841
 Self time:   0.010601

count  total (s)   self (s)
  228   0.324317   0.010077   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>278_Close()
Called 3 times
Total time:   0.012857
 Self time:   0.004211

count  total (s)   self (s)
    3   0.000141   0.000046 	cal s:buffunc(0)
    3              0.000018 	if winnr('$') == 1
                            		bw!
                            	el
    3              0.001534 		try | bun!
    3              0.000025 		cat | clo! | endt
    3   0.000137   0.000046 		cal s:unmarksigns()
    3              0.000005 	en
  102              0.000665 	for key in keys(s:glbs) | if exists('+'.key)
   48              0.000967 		sil! exe 'let &'.key.' = s:glb_'.key
   96              0.000215 	en | endfo
    3              0.000059 	if exists('s:glb_acd') | let &acd = s:glb_acd | en
    3              0.000012 	let g:ctrlp_lines = []
    3              0.000033 	if s:winres[1] >= &lines && s:winres[2] == winnr('$')
    3              0.000059 		exe s:winres[0].s:winres[0]
    3              0.000004 	en
    3              0.000042 	unl! s:focus s:hisidx s:hstgot s:marked s:statypes s:init s:savestr s:mrbs s:did_exp
    3   0.008328   0.000054 	cal ctrlp#recordhist()
    3   0.000142   0.000073 	cal s:execextvar('exit')
    3   0.000154   0.000037 	cal s:log(0)
    3              0.000045 	let v:errmsg = s:ermsg
    3              0.000092 	ec

FUNCTION  fugitive#buffer()
Called 1 time
Total time:   0.000548
 Self time:   0.000035

count  total (s)   self (s)
                              return s:buffer(a:0 ? a:1 : '%')

FUNCTION  ctrlp#utils#glob()
Called 1 time
Total time:   0.000333
 Self time:   0.000249

count  total (s)   self (s)
    1   0.000095   0.000011 	let path = ctrlp#utils#fnesc(a:1, 'g')
    1              0.000236 	retu s:wig_cond ? glob(path, a:2) : glob(path)

FUNCTION  503()
Called 7 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
    7              0.000029   if a:hi_id
                                " If the user did a matchdelete or a clearmatches, we don't want to barf if
                                " the matchid is no longer valid
    5              0.000050     silent! call matchdelete(a:hi_id)
    5              0.000011   endif

FUNCTION  <SNR>66_CreateDelimMapFromCms()
Called 20 times
Total time:   0.002211
 Self time:   0.002211

count  total (s)   self (s)
   20              0.000273     if &ft == '' && exists('g:NERDDefaultDelims')
                                    let delims = g:NERDDefaultDelims
                                    for i in ['left', 'leftAlt', 'right', 'rightAlt']
                                        if !has_key(delims, i)
                                            let delims[i] = ''
                                        endif
                                    endfor
                                    return delims
                                endif
   20              0.001476     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}

FUNCTION  airline#extensions#default#apply()
Called 42 times
Total time:   0.073545
 Self time:   0.004675

count  total (s)   self (s)
   42              0.000193   let winnr = a:context.winnr
   42              0.000141   let active = a:context.active
                            
   42   0.000872   0.000524   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   37   0.021374   0.000588     call s:build_sections(a:builder, a:context, s:layout[0])
   37              0.000046   else
    5   0.000498   0.000061     let text = s:get_section(winnr, 'c')
    5              0.000022     if empty(text)
                                  let text = ' %f%m '
                                endif
    5   0.000121   0.000071     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    5              0.000008   endif
                            
   42   0.004498   0.000830   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   42   0.000726   0.000406   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   42   0.043828   0.000567     call s:build_sections(a:builder, a:context, s:layout[1])
   42              0.000048   endif
                            
   42              0.000068   return 1

FUNCTION  505()
Called 1 time
Total time:   0.000926
 Self time:   0.000396

count  total (s)   self (s)
    1   0.000030   0.000013   let cur = self.get_current()
    1              0.000006   if s:to_mode ==# 'v' || s:to_mode ==# 'V'
                                " If we're in visual line mode, we need to go to visual mode before we can
                                " update the visual region
    1              0.000003     if s:to_mode ==# 'V'
                                  exec "normal! gvv\<Esc>"
                                endif
                                " Sets the cursor at the right place
    1              0.000026     exec "normal! gv\<Esc>"
    1   0.000577   0.000085     call cur.update_visual_selection(s:get_visual_region(s:pos('.')))
    1              0.000004   elseif s:from_mode ==# 'v' || s:from_mode ==# 'V'
                                " Save contents of unnamed register after each operation in Visual mode.
                                " This should be executed after user input is processed, when unnamed
                                " register already contains the text.
                                call cur.save_unnamed_register()
                                call cur.remove_visual_selection()
                              elseif s:from_mode ==# 'i' && s:to_mode ==# 'n' && self.current_index != 0
                                normal! h
                              elseif s:from_mode ==# 'n'
                                " Save contents of unnamed register after each operation in Normal mode.
                                call cur.save_unnamed_register()
                              endif
    1   0.000036   0.000015   let pos = s:pos('.')
                            
                              " If the total number of lines changed in the buffer, we need to potentially
                              " adjust other cursor locations
    1              0.000011   let vdelta = line('$') - s:saved_linecount
    1              0.000003   if vdelta != 0
                                if self.current_index != self.size() - 1
                                  let cur_column_offset = (cur.column() - col('.')) * -1
                                  let new_line_length = len(getline('.'))
                                  for i in range(self.current_index+1, self.size()-1)
                                    let hdelta = 0
                                    " Note: some versions of Vim don't like chaining function calls like
                                    " a.b().c(). For compatibility reasons, don't do it
                                    let c = self.get(i)
                                    " If there're other cursors on the same line, we need to adjust their
                                    " columns. This needs to happen before we adjust their line!
                                    if cur.line() == c.line() || cur.position == pos
                                      if vdelta > 0
                                        " Added a line
                                        let hdelta = cur_column_offset
                                      else
                                        " Removed a line
                                        let hdelta = new_line_length
                                      endif
                                    endif
                                    call c.move(vdelta, hdelta)
                                  endfor
                                endif
                              else
                                " If the line length changes, for all the other cursors on the same line as
                                " the current one, update their cursor location as well
    1              0.000010     let hdelta = col('$') - cur.line_length
                                " Only do this if we're still on the same line as before
    1              0.000007     if hdelta != 0 && cur.line() == line('.')
                                  " Update all the cursor's positions that occur after the current cursor on
                                  " the same line
                                  if self.current_index != self.size() - 1
                                    for i in range(self.current_index+1, self.size()-1)
                                      let c = self.get(i)
                                      " Only do it for cursors on the same line
                                      if cur.line() == c.line()
                                        call c.move(0, hdelta)
                                      else
                                        " Early exit, if we're not on the same line, neither will any cursor
                                        " that come after this
                                        break
                                      endif
                                    endfor
                                  endif
                                endif
    1              0.000002   endif
                            
    1              0.000004   if cur.position == pos
    1              0.000003     return 0
                              endif
                              call cur.update_position(pos)
                              return 1

FUNCTION  364()
Called 25 times
Total time:   0.007314
 Self time:   0.001810

count  total (s)   self (s)
   25   0.000878   0.000291     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
   25   0.000761   0.000314     let old_signs = copy(self._bufSignIds())
   25   0.001421   0.000203     if self.enabled()
   25              0.000077         if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
                                    endif
                            
   25   0.002677   0.000244         call self._signErrors(a:loclist)
   25              0.000035     endif
   25   0.001054   0.000235     call self._removeSigns(old_signs)

FUNCTION  <SNR>65_repo_head()
Called 448 times
Total time:   0.523643
 Self time:   0.036419

count  total (s)   self (s)
  448   0.477910   0.009237     let head = s:repo().head_ref()
                            
  448              0.008493     if head =~# '^ref: '
  448   0.026475   0.007924       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
  448              0.001331     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
  448              0.001210     return branch

FUNCTION  <SNR>278_formatline()
Called 40 times
Total time:   0.006439
 Self time:   0.004295

count  total (s)   self (s)
   40              0.000141 	let str = a:str
   40   0.001890   0.000321 	let ct = s:curtype()
   40              0.000133 	if ct == 'buf'
                            		let bufnr = s:bufnrfilpath(str)[0]
                            		let parts = s:bufparts(bufnr)
                            		let str = printf('%'.s:bufnr_width.'s', bufnr)
                            		if s:has_conceal
                            			let str .= printf(' %-13s %s%-36s', '<bi>'.parts[0].'</bi>', '<bn>'.parts[1], '{'.parts[2].'}</bn>')
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', '<bp>'.parts[3].'</bp>')
                            			en
                            		el
                            			let str .= printf(' %-5s %-30s', parts[0], parts[2])
                            			if (!empty(s:bufpath_mod))
                            				let str .= printf('  %s', parts[3])
                            			en
                            		en
                            	en
   40   0.001412   0.000837 	let cond = ct != 'buf' &&s:ispath && ( s:winw - 4 ) < s:strwidth(str)
   40              0.000291 	retu s:lineprefix.( cond ? s:pathshorten(str) : str )

FUNCTION  <SNR>278_BuildPrompt()
Called 4 times
Total time:   0.670341
 Self time:   0.351791

count  total (s)   self (s)
    4   0.000256   0.000054 	let base = ( s:regexp ? 'r' : '>' ).( s:byfname() ? 'd' : '>' ).'> '
    4   0.000422   0.000068 	let str = escape(s:getinput(), '\')
    4              0.000034 	let lazy = str == '' || exists('s:force') || !has('autocmd') ? 0 : s:lazy
    4              0.000025 	if a:upd && !lazy && ( s:matches || s:regexp || exists('s:did_exp') || str =~ '\(\\\(<\|>\)\|[*|]\)\|\(\\\:\([^:]\|\\:\)*$\)' )
    4   0.241931   0.000110 		sil! cal s:Update(str)
    4              0.000004 	en
    4   0.076268   0.000095 	sil! cal ctrlp#statusline()
                            	" Toggling
    4              0.000064 	let [hiactive, hicursor, base] = s:focus ? ['CtrlPPrtText', 'CtrlPPrtCursor', base] : ['CtrlPPrtBase', 'CtrlPPrtBase', tr(base, '>', '-')]
    4              0.000012 	let hibase = 'CtrlPPrtBase'
                            	" Build it
    4              0.350771 	redr
    4              0.000038 	let prt = copy(s:prompt)
    4              0.000074 	cal map(prt, 'escape(v:val, ''"\'')')
    4              0.000263 	exe 'echoh' hibase '| echon "'.base.'" | echoh' hiactive '| echon "'.prt[0].'" | echoh' hicursor '| echon "'.prt[1].'" | echoh' hiactive '| echon "'.prt[2].'" | echoh None'
                            	" Append the cursor at the end
    4              0.000028 	if empty(prt[1]) && s:focus
    4              0.000081 		exe 'echoh' hibase '| echon "_" | echoh None'
    4              0.000005 	en

FUNCTION  <SNR>55_airline_theme()
Called 7 times
Total time:   1.156289
 Self time:   0.000193

count  total (s)   self (s)
    7              0.000026   if a:0
    7   1.156206   0.000110     call airline#switch_theme(a:1)
    7              0.000008   else
                                echo g:airline_theme
                              endif

FUNCTION  syntastic#util#unique()
Called 15 times
Total time:   0.000851
 Self time:   0.000851

count  total (s)   self (s)
   15              0.000061     let seen = {}
   15              0.000042     let uniques = []
   30              0.000083     for e in a:list
   15              0.000087         let k = string(e)
   15              0.000072         if !has_key(seen, k)
   15              0.000061             let seen[k] = 1
   15              0.000074             call add(uniques, e)
   15              0.000021         endif
   15              0.000026     endfor
   15              0.000029     return uniques

FUNCTION  <SNR>65_shellslash()
Called 2 times
Total time:   0.000083
 Self time:   0.000053

count  total (s)   self (s)
    2   0.000062   0.000032   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
    2              0.000005     return a:path
                              endif

FUNCTION  <SNR>278_dosigns()
Called 11 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
   11              0.000095 	retu exists('s:marked') && s:bufnr > 0 && s:opmul != '0' && has('signs')

FUNCTION  ctrlspace#engine#CompareByText()
Called 126 times
Total time:   0.001250
 Self time:   0.001250

count  total (s)   self (s)
  126              0.000542 	if a:a.text < a:b.text
   76              0.000144 		return -1
                            	elseif a:a.text > a:b.text
   50              0.000075 		return 1
                            	else
                            		return 0
                            	endif

FUNCTION  <SNR>149_create_matches()
Called 1194 times
Total time:   1.518255
 Self time:   1.496803

count  total (s)   self (s)
 1194   0.033020   0.011568 	call s:clear_matches()
 1194              0.007494 	if ! &l:cursorline | return | endif
                            	" adds matches based that duplicate the highlighted colors on the current line
 1193              0.005700 	let lnr = line('.')
 1193              0.003068 	let group = ''
 1193              0.003208 	let groupstart = 0
 1193              0.006126 	let endcol = col('$')
31811              0.071565 	for col in range( 1, endcol )
30618              0.998499 		let nextgroup = col < endcol ? synIDattr( synID( lnr, col, 1 ), 'name' ) : ''
55232              0.149900 		if group == nextgroup | continue | endif
 5593              0.047933 		if group =~ '^BG\x\{6}$'
   10              0.000177 			let regex = '\%'.lnr.'l\%'.groupstart.'c'.repeat( '.', col - groupstart )
   10              0.000259 			let w:css_color_match_id += [ matchadd( group, regex, -1 ) ]
   10              0.000016 		endif
 5593              0.016351 		let group = nextgroup
 5593              0.014793 		let groupstart = col
 5593              0.011671 	endfor

FUNCTION  <SNR>278_InitCustomFuncs()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000008 	if s:igntype == 4 && has_key(s:usrign, 'func-init') && s:usrign['func-init'] != ''
                            		exe call(s:usrign['func-init'], [])
                            	en

FUNCTION  airline#parts#filetype()
Called 965 times
Total time:   0.011920
 Self time:   0.011920

count  total (s)   self (s)
  965              0.010627   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 40 times
Total time:   0.001743
 Self time:   0.001743

count  total (s)   self (s)
   40              0.000325   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  ctrlp#utils#globpath()
Called 61 times
Total time:   0.025550
 Self time:   0.025550

count  total (s)   self (s)
   61              0.025441 	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])

FUNCTION  airline#extensions#tabline#formatters#unique_tail#format()
Called 235 times
Total time:   0.099611
 Self time:   0.074389

count  total (s)   self (s)
  235              0.000934   let duplicates = {}
  235              0.000681   let tails = {}
  235              0.000602   let map = {}
  888              0.002141   for nr in a:buffers
  653              0.003899     let name = bufname(nr)
  653              0.002945     if empty(name)
                                  let map[nr] = '[No Name]'
                                else
  653              0.013900       let tail = fnamemodify(name, ':s?/\+$??:t')
  653              0.003693       if has_key(tails, tail)
                                    let duplicates[nr] = nr
                                  endif
  653              0.003245       let tails[tail] = 1
  653   0.036492   0.011270       let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, tail)
  653              0.001143     endif
  653              0.001058   endfor
                            
  235              0.001900   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':p:.')
  235              0.001369   for nr in values(duplicates)
                                let name = bufname(nr)
                                let fnamecollapse = get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                if fnamecollapse
                                  let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g'))
                                else
                                  let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, fnamemodify(name, fmod))
                                endif
                              endfor
                            
  235              0.001326   if has_key(map, a:bufnr)
  235              0.001076     return map[a:bufnr]
                              endif
                            
                              " if we get here, the buffer list isn't in sync with the selected buffer yet, fall back to the default
                              return airline#extensions#tabline#formatters#default#format(a:bufnr, a:buffers)

FUNCTION  airline#parts#iminsert()
Called 961 times
Total time:   0.014938
 Self time:   0.014938

count  total (s)   self (s)
  961              0.006258   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  961              0.001545   return ''

FUNCTION  gitgutter#hunk#summary()
Called 448 times
Total time:   0.019850
 Self time:   0.007735

count  total (s)   self (s)
  448   0.019252   0.007137   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  gitgutter#highlight#define_highlights()
Called 2 times
Total time:   0.001518
 Self time:   0.001003

count  total (s)   self (s)
    2   0.000565   0.000050   let [guibg, ctermbg] = s:get_background_colors('SignColumn')
                            
                              " Highlights used by the signs.
                            
    2              0.000073   execute "highlight GitGutterAddDefault    guifg=#009900 guibg=" . guibg . " ctermfg=2 ctermbg=" . ctermbg
    2              0.000066   execute "highlight GitGutterChangeDefault guifg=#bbbb00 guibg=" . guibg . " ctermfg=3 ctermbg=" . ctermbg
    2              0.000063   execute "highlight GitGutterDeleteDefault guifg=#ff2222 guibg=" . guibg . " ctermfg=1 ctermbg=" . ctermbg
    2              0.000053   highlight default link GitGutterChangeDeleteDefault GitGutterChangeDefault
                            
    2              0.000069   execute "highlight GitGutterAddInvisible    guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    2              0.000067   execute "highlight GitGutterChangeInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    2              0.000069   execute "highlight GitGutterDeleteInvisible guifg=bg guibg=" . guibg . " ctermfg=" . ctermbg . " ctermbg=" . ctermbg
    2              0.000052   highlight default link GitGutterChangeDeleteInvisible GitGutterChangeInvisible
                            
    2              0.000051   highlight default link GitGutterAdd          GitGutterAddDefault
    2              0.000050   highlight default link GitGutterChange       GitGutterChangeDefault
    2              0.000050   highlight default link GitGutterDelete       GitGutterDeleteDefault
    2              0.000051   highlight default link GitGutterChangeDelete GitGutterChangeDeleteDefault
                            
                              " Highlights used for the whole line.
                            
    2              0.000051   highlight default link GitGutterAddLine          DiffAdd
    2              0.000052   highlight default link GitGutterChangeLine       DiffChange
    2              0.000051   highlight default link GitGutterDeleteLine       DiffDelete
    2              0.000051   highlight default link GitGutterChangeDeleteLine GitGutterChangeLine

FUNCTION  <SNR>157_on_exit_vim()
Called 6 times
Total time:   0.000597
 Self time:   0.000163

count  total (s)   self (s)
    6   0.000593   0.000159   call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))

FUNCTION  <SNR>272_h()
Called 301 times
Total time:   0.050839
 Self time:   0.050839

count  total (s)   self (s)
  301              0.000895   if (a:0 > 0) " Will be true if we got here from onedark#extend_highlight
                                let a:highlight = s:group_colors[a:group]
                                for style_type in ["fg", "bg", "sp"]
                                  if (has_key(a:style, style_type))
                                    let l:default_style = (has_key(a:highlight, style_type) ? a:highlight[style_type] : { "cterm16": "NONE", "cterm": "NONE", "gui": "NONE" })
                                    let a:highlight[style_type] = extend(l:default_style, a:style[style_type])
                                  endif
                                endfor
                                if (has_key(a:style, "gui"))
                                  let a:highlight.gui = a:style.gui
                                endif
                              else
  301              0.000951     let a:highlight = a:style
  301              0.001867     let s:group_colors[a:group] = a:highlight " Cache default highlight group settings
  301              0.000379   endif
                            
  301              0.000753   if g:onedark_terminal_italics == 0
  301              0.001572     if has_key(a:highlight, "cterm") && a:highlight["cterm"] == "italic"
    2              0.000006       unlet a:highlight.cterm
    2              0.000002     endif
  301              0.001437     if has_key(a:highlight, "gui") && a:highlight["gui"] == "italic"
    2              0.000004       unlet a:highlight.gui
    2              0.000002     endif
  301              0.000314   endif
                            
  301              0.000640   if g:onedark_termcolors == 16
                                let l:ctermfg = (has_key(a:highlight, "fg") ? a:highlight.fg.cterm16 : "NONE")
                                let l:ctermbg = (has_key(a:highlight, "bg") ? a:highlight.bg.cterm16 : "NONE")
                              else
  301              0.002083     let l:ctermfg = (has_key(a:highlight, "fg") ? a:highlight.fg.cterm : "NONE")
  301              0.002004     let l:ctermbg = (has_key(a:highlight, "bg") ? a:highlight.bg.cterm : "NONE")
  301              0.000371   endif
                            
  301              0.019724   execute "highlight" a:group "guifg="   (has_key(a:highlight, "fg")    ? a:highlight.fg.gui   : "NONE") "guibg="   (has_key(a:highlight, "bg")    ? a:highlight.bg.gui   : "NONE") "guisp="   (has_key(a:highlight, "sp")    ? a:highlight.sp.gui   : "NONE") "gui="     (has_key(a:highlight, "gui")   ? a:highlight.gui      : "NONE") "ctermfg=" . l:ctermfg "ctermbg=" . l:ctermbg "cterm="   (has_key(a:highlight, "cterm") ? a:highlight.cterm    : "NONE")

FUNCTION  <SNR>63_filename()
Called 8 times
Total time:   0.006338
 Self time:   0.000172

count  total (s)   self (s)
    8   0.006327   0.000161   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>63_strip_trailing_new_line()
Called 6 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    6              0.000092   return substitute(a:line, '\n$', '', '')

FUNCTION  <SNR>137_handleAutochdir()
Called 2 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000020 	if (a:switch == "start") && &acd
                            		let s:acdWasOn = 1
                            		set noacd
                            	elseif (a:switch == "stop") && exists("s:acdWasOn")
                            		set acd
                            		unlet s:acdWasOn
                            	endif

FUNCTION  gitgutter#process_buffer()
Called 208 times
Total time:   5.359644
 Self time:   0.023420

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
  208   0.738973   0.003796   if gitgutter#utility#is_active(a:bufnr)
  205   0.014095   0.002974     if a:force || s:has_fresh_changes(a:bufnr)
                            
   68              0.000258       let diff = ''
   68              0.000139       try
   68   4.579376   0.001543         let diff = gitgutter#diff#run_diff(a:bufnr, 0)
   64              0.000216       catch /gitgutter not tracked/
    4   0.003920   0.000120         call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
    4              0.000013       catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
   68              0.000306       if diff != 'async'
    4   0.005350   0.000069         call gitgutter#diff#handler(a:bufnr, diff)
    4              0.000005       endif
                            
   68              0.000077     endif
  205              0.000312   else
    3   0.003078   0.000066     call s:clear(a:bufnr)
    3              0.000006   endif

FUNCTION  501()
Called 6 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    6              0.000048   return self.cursors[a:i]

FUNCTION  <SNR>65_repo_dir()
Called 896 times
Total time:   0.015880
 Self time:   0.015880

count  total (s)   self (s)
  896              0.014428   return join([self.git_dir]+a:000,'/')

FUNCTION  506()
Called 1 time
Total time:   0.000041
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000038   0.000028   let self.current_index = (self.current_index + 1) % self.size()

FUNCTION  507()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000006   let self.current_index  = 0
    1              0.000004   let self.starting_index = 0

FUNCTION  airline#extensions#ctrlp#ctrlp_airline()
Called 4 times
Total time:   0.075228
 Self time:   0.000562

count  total (s)   self (s)
    4   0.000285   0.000052   let b = airline#builder#new({'active': 1})
    4              0.000012   if a:2 == 'file'
                                call b.add_section_spaced('CtrlPlight', 'by fname')
                              endif
    4              0.000007   if a:3
                                call b.add_section_spaced('CtrlPlight', 'regex')
                              endif
    4              0.000031   if get(g:, 'airline#extensions#ctrlp#show_adjacent_modes', 1)
    4   0.000198   0.000045     call b.add_section_spaced('CtrlPlight', a:4)
    4   0.000148   0.000037     call b.add_section_spaced('CtrlPwhite', a:5)
    4   0.000160   0.000051     call b.add_section_spaced('CtrlPlight', a:6)
    4              0.000005   else
                                call b.add_section_spaced('CtrlPwhite', a:5)
                              endif
    4   0.000165   0.000033   call b.add_section_spaced('CtrlPdark', a:7)
    4   0.000058   0.000026   call b.split()
    4   0.000142   0.000033   call b.add_section_spaced('CtrlPdark', a:1)
    4   0.000139   0.000034   call b.add_section_spaced('CtrlPdark', a:2)
    4   0.000149   0.000036   call b.add_section_spaced('CtrlPlight', '%{getcwd()}')
    4   0.073620   0.000051   return b.build()

FUNCTION  <SNR>63_vimdiff()
Called 228 times
Total time:   0.011893
 Self time:   0.011893

count  total (s)   self (s)
  456              0.003548     for winid in win_findbuf(a:bufnr)
  228              0.002158       if getwinvar(winid, '&diff')
                                    return 1
                                  endif
  228              0.000513     endfor
  228              0.000527     return 0

FUNCTION  <SNR>278_nosort()
Called 4 times
Total time:   0.000407
 Self time:   0.000228

count  total (s)   self (s)
    4   0.000218   0.000039 	let ct = s:curtype()
    4              0.000176 	retu s:matcher != {} || s:nolim == 1 || ( ct == 'mru' && s:mrudef ) || ( ct =~ '^\(buf\|mru\)$' && s:prompt == ['', '', ''] ) || !s:dosort

FUNCTION  <SNR>277_revert_mode()
Called 2 times
Total time:   0.000400
 Self time:   0.000096

count  total (s)   self (s)
    2              0.000011   if a:to ==# 'v'
    2   0.000340   0.000036     call s:cm.reapply_visual_selection()
    2              0.000007   elseif a:to ==# 'V'
                                call s:cm.reapply_visual_selection()
                                normal! V
                              elseif a:to ==# 'n' && a:from ==# 'i'
                                stopinsert
                              endif

FUNCTION  <SNR>133_reset_tick()
Called 3 times
Total time:   0.000174
 Self time:   0.000050

count  total (s)   self (s)
    3   0.000168   0.000044   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  <SNR>278_Open()
Called 3 times
Total time:   0.022668
 Self time:   0.017962

count  total (s)   self (s)
    3   0.000176   0.000059 	cal s:log(1)
    3   0.003714   0.000054 	cal s:getenv()
    3   0.000110   0.000045 	cal s:execextvar('enter')
    3              0.012979 	sil! exe 'keepa' ( s:mw_pos == 'top' ? 'to' : 'bo' ) '1new ControlP'
    3   0.000203   0.000094 	cal s:buffunc(1)
    3              0.000055 	let [s:bufnr, s:winw] = [bufnr('%'), winwidth(0)]
    3              0.000051 	let [s:focus, s:prompt] = [1, ['', '', '']]
    3              0.000010 	abc <buffer>
    3              0.000020 	if !exists('s:hstry')
    1   0.000871   0.000657 		let hst = filereadable(s:gethistloc()[1]) ? s:gethistdata() : ['']
    1              0.000013 		let s:hstry = empty(hst) || !s:maxhst ? [''] : hst
    1              0.000002 	en
  102              0.000867 	for [ke, va] in items(s:glbs) | if exists('+'.ke)
   48              0.001874 		sil! exe 'let s:glb_'.ke.' = &'.ke.' | let &'.ke.' = '.string(va)
   96              0.000237 	en | endfo
    3              0.000034 	if s:opmul != '0' && has('signs')
    3              0.000312 		sign define ctrlpmark text=+> texthl=CtrlPMark
    3              0.000248 		hi def link CtrlPMark Search
    3              0.000005 	en
    3   0.000630   0.000089 	cal s:setupblank()

FUNCTION  <SNR>36_record()
Called 48 times
Total time:   0.095731
 Self time:   0.003776

count  total (s)   self (s)
   48              0.000388 	if s:locked | retu | en
   48              0.000289 	let bufnr = a:bufnr + 0
   48              0.000437 	let bufname = bufname(bufnr)
   48              0.000309 	if bufnr > 0 && !empty(bufname)
   48              0.000866 		cal filter(s:mrbs, 'v:val != bufnr')
   48              0.000283 		cal insert(s:mrbs, bufnr)
   48   0.092766   0.000811 		cal s:addtomrufs(bufname)
   48              0.000067 	en

FUNCTION  <SNR>277_get_time_in_ms()
Called 4 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
    4              0.000170   return str2nr(substitute(reltimestr(reltime()), '\.\(...\).*', '\1', ''))

FUNCTION  <SNR>274_fillBufferSpace()
Called 1 time
Total time:   0.001289
 Self time:   0.000041

count  total (s)   self (s)
    1   0.001269   0.000021 	let fill = s:filler()
                            
    1              0.000012 	while winheight(0) > line(".")
                            		silent! put =fill
                            	endwhile

FUNCTION  <SNR>277_update_visual_markers()
Called 1 time
Total time:   0.000133
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000010   if a:region[0] == a:region[1]
                                normal! v
                              else
    1              0.000009     call cursor(a:region[1])
    1              0.000013     normal! m`
    1              0.000010     call cursor(a:region[0])
    1              0.000014     normal! v``
    1              0.000003   endif
    1   0.000065   0.000013   call s:exit_visual_mode()

FUNCTION  ctrlp#igncwd()
Called 1 time
Total time:   0.000579
 Self time:   0.000151

count  total (s)   self (s)
    1   0.000578   0.000150 	retu ctrlp#utils#glob(a:cwd, 0) == '' || ( s:igntype >= 0 && s:usrign(a:cwd, getftype(a:cwd)) )

FUNCTION  <SNR>228_SearchForMatchingTag()
Called 376 times
Total time:   0.919471
 Self time:   0.919471

count  total (s)   self (s)
                                "returns the position of a matching tag or [0 0]
                            
  376              0.005844     let starttag = '\V<'.escape(a:tagname, '\').'\%(\_s\%(\.\{-}\|\_.\{-}\%<'.line('.').'l\)/\@<!\)\?>'
  376              0.000994     let midtag = ''
  376              0.003952     let endtag = '\V</'.escape(a:tagname, '\').'\_s\*'.(a:forwards?'':'\zs').'>'
  376              0.001626     let flags = 'nW'.(a:forwards?'':'b')
                            
                                " When not in a string or comment ignore matches inside them.
  376              0.002854     let skip ='synIDattr(synID(line("."), col("."), 0), "name") ' . '=~?  "\\%(html\\|xml\\)String\\|\\%(html\\|xml\\)CommentPart"'
  376              0.161132     execute 'if' skip '| let skip = 0 | endif'
                            
                                " Limit the search to lines visible in the window.
  376              0.003088     let stopline = a:forwards ? line('w$') : line('w0')
  376              0.000974     let timeout = 300
                            
                                " The searchpairpos() timeout parameter was added in 7.2
  376              0.001020     if v:version >= 702
  376              0.732993         return searchpairpos(starttag, midtag, endtag, flags, skip, stopline, timeout)
                                else
                                    return searchpairpos(starttag, midtag, endtag, flags, skip, stopline)
                                endif

FUNCTION  ctrlp#statusline()
Called 4 times
Total time:   0.076173
 Self time:   0.000863

count  total (s)   self (s)
    4              0.000030 	if !exists('s:statypes')
    3              0.000018 		let s:statypes = copy(s:coretypes)
    3              0.000013 		if !empty(g:ctrlp_ext_vars)
                            			cal map(copy(g:ctrlp_ext_vars), 'add(s:statypes, [ v:val["lname"], v:val["sname"] ])')
                            		en
    3              0.000004 	en
    4              0.000012 	let tps = s:statypes
    4              0.000026 	let max = len(tps) - 1
    4   0.000108   0.000073 	let nxt = tps[s:walker(max, s:itemtype,  1)][1]
    4   0.000076   0.000052 	let prv = tps[s:walker(max, s:itemtype, -1)][1]
    4              0.000023 	let s:ctype = tps[s:itemtype][0]
    4              0.000015 	let focus   = s:focus ? 'prt'  : 'win'
    4              0.000018 	let byfname = s:ispath ? s:byfname ? 'file' : 'path' : 'line'
    4              0.000043 	let marked  = s:opmul != '0' ? exists('s:marked') ? ' <'.s:dismrk().'>' : ' <->' : ''
    4              0.000018 	if s:status != {}
    4              0.000079 		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'focus':   focus, 'byfname': byfname, 'regex':   s:regexp, 'prev':    prv, 'item':    s:ctype, 'next':    nxt, 'marked':  marked, }] : [focus, byfname, s:regexp, prv, s:ctype, nxt, marked]
    4   0.075539   0.000288 		let &l:stl = call(s:status['main'], argms, s:status)
    4              0.000006 	el
                            		let item    = '%#CtrlPMode1# '.s:ctype.' %*'
                            		let focus   = '%#CtrlPMode2# '.focus.' %*'
                            		let byfname = '%#CtrlPMode1# '.byfname.' %*'
                            		let regex   = s:regexp  ? '%#CtrlPMode2# regex %*' : ''
                            		let slider  = ' <'.prv.'>={'.item.'}=<'.nxt.'>'
                            		let dir     = ' %=%<%#CtrlPMode2# %{getcwd()} %*'
                            		let &l:stl  = focus.byfname.regex.slider.marked.dir
                            	en

FUNCTION  300()
Called 3 times
Total time:   0.000145
 Self time:   0.000085

count  total (s)   self (s)
    3   0.000088   0.000028     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    3              0.000031     autocmd! syntastic CursorMoved
    3              0.000009     unlet! b:syntastic_private_messages
    3              0.000011     let b:syntastic_private_line = -1

FUNCTION  302()
Called 50 times
Total time:   0.002174
 Self time:   0.000614

count  total (s)   self (s)
   50   0.002113   0.000553     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  303()
Called 25 times
Total time:   0.005528
 Self time:   0.003022

count  total (s)   self (s)
   25   0.001239   0.000198     if self.enabled()
   25   0.001078   0.000342         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
   25   0.000760   0.000198         call self._reset()
   25              0.000138         let buf = bufnr('')
   25   0.000521   0.000354         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
   25              0.000095         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
   25              0.000035     endif

FUNCTION  304()
Called 3 times
Total time:   0.000183
 Self time:   0.000070

count  total (s)   self (s)
    3              0.000009     if s:has_highlighting
    3   0.000084   0.000029         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    3   0.000078   0.000020         call self._reset()
    3              0.000004     endif

FUNCTION  306()
Called 28 times
Total time:   0.000620
 Self time:   0.000620

count  total (s)   self (s)
   29              0.000181     for match in getmatches()
    1              0.000007         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
    1              0.000002     endfor

FUNCTION  307()
Called 4 times
Total time:   0.000295
 Self time:   0.000295

count  total (s)   self (s)
    4              0.000098     let newObj = copy(self)
                            
    4              0.000034     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
    4              0.000012     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
    4              0.000015     let newObj._rawLoclist = llist
    4              0.000012     let newObj._name = ''
    4              0.000020     let newObj._owner = bufnr('')
    4              0.000012     let newObj._sorted = 0
    4              0.000015     let newObj._columns = g:syntastic_cursor_columns
                            
    4              0.000007     return newObj

FUNCTION  308()
Called 1950 times
Total time:   0.109935
 Self time:   0.084716

count  total (s)   self (s)
 1950              0.014501     let buf = a:0 ? a:1 : bufnr('')
 1950   0.052672   0.027529     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
 1950              0.017895     if type(loclist) != type({}) || empty(loclist)
    1              0.000003         unlet! loclist
    1   0.000097   0.000021         let loclist = g:SyntasticLoclist.New([])
    1              0.000001     endif
 1950              0.003863     return loclist

FUNCTION  ctrlp#mrufiles#bufs()
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000015 	retu s:mrbs

FUNCTION  fugitive#detect()
Called 1 time
Total time:   0.004767
 Self time:   0.000157

count  total (s)   self (s)
    1              0.000008   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    1              0.000005   if !exists('b:git_dir')
    1   0.004641   0.000031     let dir = fugitive#extract_git_dir(a:path)
    1              0.000003     if dir !=# ''
                                  let b:git_dir = dir
                                  if empty(fugitive#buffer().path())
                                    silent! exe haslocaldir() ? 'lcd .' : 'cd .'
                                  endif
                                endif
    1              0.000001   endif
    1              0.000004   if exists('b:git_dir')
                                if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
                                if !exists('g:fugitive_no_maps')
                                  cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
                                  nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
                                endif
                                let buffer = fugitive#buffer()
                                if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
                                if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
                                  if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
                                  if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
                                endif
                                try
                                  let [save_mls, &modelines] = [&mls, 0]
                                  call s:define_commands()
                                  doautocmd User Fugitive
                                finally
                                  let &mls = save_mls
                                endtry
                              endif

FUNCTION  <SNR>149_parse_screen()
Called 1172 times
Total time:  13.969506
 Self time:  12.585697

count  total (s)   self (s)
 1172              0.012723 	let leftcol = winsaveview().leftcol
 1172              0.009993 	let left = max([ leftcol - 15, 0 ])
 1172              0.004480 	let width = &columns * 4
 1172  12.540686  12.530119 	call filter( range( line('w0'), line('w$') ), 'substitute( strpart( getline(v:val), col([v:val, left]), width ), b:css_color_pat, ''\=s:create_syn_match()'', ''g'' )' )
 1172   1.396952   0.023710 	call s:create_matches()

FUNCTION  airline#extensions#tabline#buflist#list()
Called 235 times
Total time:   0.013005
 Self time:   0.011589

count  total (s)   self (s)
  235              0.001822   if exists('s:current_buffer_list')
  212              0.000601     return s:current_buffer_list
                              endif
                            
   23              0.000189   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
   23              0.000164   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
   23              0.000165   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
   23              0.000315   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
   23              0.000069   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
  164              0.000328   for nr in list
  141              0.000618     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                            
                                  " check buffer numbers first
   68              0.000290       if index(exclude_buffers, nr) >= 0
                                    continue
                                    " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                    " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
   68              0.000315       call add(buffers, nr)
   68              0.000095     endif
  141              0.000253   endfor
                            
   23              0.000097   let s:current_buffer_list = buffers
   23              0.000045   return buffers

FUNCTION  513()
Called 3 times
Total time:   0.002076
 Self time:   0.000320

count  total (s)   self (s)
                              " Lazy init
    3   0.000119   0.000043   if self.is_empty()
    2   0.000412   0.000036     call self.initialize()
    2              0.000004   endif
                            
                              " Don't add duplicates
    3              0.000011   let i = 0
    3              0.000017   for c in self.cursors
    1              0.000005     if c.position == a:pos
    1              0.000002       return 0
                                endif
                                let i+=1
                              endfor
                            
    2   0.000737   0.000037   let cursor = s:Cursor.new(a:pos)
                            
                              " Save the visual selection
    2              0.000008   if a:0 > 0
    2   0.000636   0.000032     call cursor.update_visual_selection(a:1)
    2              0.000005   endif
                            
    2              0.000016   call add(self.cursors, cursor)
    2              0.000009   let self.current_index += 1
    2              0.000004   return 1

FUNCTION  <SNR>278_iscmdwin()
Called 3 times
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
    3              0.000050 	let [ermsg, v:errmsg] = [v:errmsg, '']
    3              0.000066 	sil! noa winc p
    3              0.000039 	sil! noa winc p
    3              0.000034 	let [v:errmsg, ermsg] = [ermsg, v:errmsg]
    3              0.000053 	retu ermsg =~ '^E11:'

FUNCTION  <SNR>277_region()
Called 3 times
Total time:   0.000221
 Self time:   0.000098

count  total (s)   self (s)
    3   0.000216   0.000093   return [s:pos(a:start_mark), s:pos(a:end_mark)]

FUNCTION  syntastic#util#stamp()
Called 28 times
Total time:   0.001273
 Self time:   0.001273

count  total (s)   self (s)
   28              0.001226     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  <SNR>109_get_hunks_gitgutter()
Called 961 times
Total time:   0.063489
 Self time:   0.021719

count  total (s)   self (s)
  961   0.029774   0.013384   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
  513              0.001055     return ''
                              endif
  448   0.029081   0.003701   return GitGutterGetHunkSummary()

FUNCTION  ctrlp#setlines()
Called 3 times
Total time: 162.318810
 Self time:   0.000245

count  total (s)   self (s)
    3              0.000020 	if a:0 | let s:itemtype = a:1 | en
    3   0.000972   0.000037 	cal s:modevar()
    3              0.000028 	let inits = {'fil': 'ctrlp#files()', 'buf': 'ctrlp#buffers()', 'mru': 'ctrlp#mrufiles#list()'}
    3              0.000051 	let types = map(copy(g:ctrlp_types), 'inits[v:val]')
    3              0.000017 	if !empty(g:ctrlp_ext_vars)
                            		cal map(copy(g:ctrlp_ext_vars), 'add(types, v:val["init"])')
                            	en
    3 162.317689   0.000059 	let g:ctrlp_lines = eval(types[s:itemtype])

FUNCTION  ctrlspace#files#ClearAll()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000008 	let s:files = []
    1              0.000004 	let s:items = []

FUNCTION  <SNR>110_has_vcscommand()
Called 513 times
Total time:   0.005530
 Self time:   0.005530

count  total (s)   self (s)
  513              0.004790   return get(g:, 'airline#extensions#branch#use_vcscommand', 0) && exists('*VCSCommandGetStatusLine')

FUNCTION  311()
Called 122 times
Total time:   0.000803
 Self time:   0.000803

count  total (s)   self (s)
  122              0.000654     return empty(self._rawLoclist)

FUNCTION  312()
Called 25 times
Total time:   0.001904
 Self time:   0.000680

count  total (s)   self (s)
   25              0.000164     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
   25   0.001530   0.000306     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  313()
Called 25 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
   25              0.000138     return copy(self._rawLoclist)

FUNCTION  314()
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000009     return self._rawLoclist

FUNCTION  315()
Called 6 times
Total time:   0.000492
 Self time:   0.000137

count  total (s)   self (s)
    6   0.000485   0.000130     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  317()
Called 1922 times
Total time:   0.271848
 Self time:   0.271848

count  total (s)   self (s)
 1922              0.012903     if !exists('self._stl_format')
    3              0.000011         let self._stl_format = ''
    3              0.000004     endif
 1922              0.009889     if !exists('self._stl_flag')
    3              0.000009         let self._stl_flag = ''
    3              0.000003     endif
                            
 1922              0.008330     if g:syntastic_stl_format !=# self._stl_format
 1922              0.008283         let self._stl_format = g:syntastic_stl_format
                            
 1922              0.007923         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
 1922              0.006048             let self._stl_flag = ''
 1922              0.002581         endif
 1922              0.002128     endif
                            
 1922              0.004627     return self._stl_flag

FUNCTION  airline#extensions#po#apply()
Called 37 times
Total time:   0.000580
 Self time:   0.000580

count  total (s)   self (s)
   37              0.000227   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                              endif

FUNCTION  <SNR>101_is_excluded_window()
Called 42 times
Total time:   0.004500
 Self time:   0.004500

count  total (s)   self (s)
   42              0.000202   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
  168              0.000477   for matchw in g:airline_exclude_filenames
  126              0.001814     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
  126              0.000178   endfor
                            
   42              0.000129   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   42              0.000066   return 0

FUNCTION  <SNR>278_Update()
Called 4 times
Total time:   0.241821
 Self time:   0.005724

count  total (s)   self (s)
                            	" Get the previous string if existed
    4              0.000030 	let oldstr = exists('s:savestr') ? s:savestr : ''
                            	" Get the new string sans tail
    4   0.000386   0.000060 	let str = s:sanstail(a:str)
                            	" Stop if the string's unchanged
    4              0.000037 	if str == oldstr && !empty(str) && !exists('s:force') | retu | en
                            	" Optionally send the string to a custom validate function
    4              0.000030 	if s:validate != '' | let str = call(s:validate, [str]) | en
    4              0.000047 	let s:martcs = &scs && str =~ '\u' ? '\C' : ''
    4   0.000797   0.000079 	let pat = s:matcher == {} ? s:SplitPattern(str) : str
    4   0.071478   0.005125 	let lines = s:nolim == 1 && empty(str) ? copy(g:ctrlp_lines) : s:MatchedItems(g:ctrlp_lines, pat, s:mw_res)
    4              0.000078 	if empty(str) | cal clearmatches() | en
    4   0.168875   0.000175 	cal s:Render(lines, pat)
    4              0.000016 	return lines

FUNCTION  gitgutter#utility#cd_cmd()
Called 72 times
Total time:   0.150946
 Self time:   0.004381

count  total (s)   self (s)
   72   0.078291   0.002658   let cd = s:unc_path(a:bufnr) ? 'pushd' : (s:windows() ? 'cd /d' : 'cd')
   72   0.072481   0.001549   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  ctrlspace#workspaces#SetWorkspaceNames()
Called 1 time
Total time:   0.000986
 Self time:   0.000689

count  total (s)   self (s)
    1   0.000322   0.000040 	let filename     = ctrlspace#util#WorkspaceFile()
    1              0.000006 	let s:workspaces = []
                            
    1   0.000031   0.000016 	call s:modes.Workspace.SetData("LastActive", "")
                            
    1              0.000580 	if filereadable(filename)
                            		for line in readfile(filename)
                            			if line =~? "CS_WORKSPACE_BEGIN: "
                            				call add(s:workspaces, line[20:])
                            			elseif line =~? "CS_LAST_WORKSPACE: "
                            				call s:modes.Workspace.SetData("LastActive", line[19:])
                            			endif
                            		endfor
                            	endif

FUNCTION  <SNR>278_writecache()
Called 1 time
Total time:   0.283861
 Self time:   0.000654

count  total (s)   self (s)
    1   0.000654   0.000614 	if ( g:ctrlp_newcache || !filereadable(a:cafile) ) && !s:nocache()
    1   0.283191   0.000024 		cal ctrlp#utils#writecache(g:ctrlp_allfiles)
    1              0.000011 		let g:ctrlp_newcache = 0
    1              0.000002 	en

FUNCTION  <SNR>278_execextvar()
Called 9 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
    9              0.000072 	if !empty(g:ctrlp_ext_vars)
                            		cal map(filter(copy(g:ctrlp_ext_vars), 'has_key(v:val, a:key)'), 'eval(v:val[a:key])')
                            	en

FUNCTION  <SNR>257__find_mru_bufnr()
Called 1 time
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
    1              0.000019     let l:cur_buf_idx = index(w:buffergator_mru, bufnr("%"))
    1              0.000007     if len(w:buffergator_mru) < 1 " maybe should be 2?
                                    return bufnr("%")
                                endif
    1              0.000003     if l:cur_buf_idx < 0
                                    let l:target_buf_idx = 0
                                else
    1              0.000003         if a:dir < 0
    1              0.000010             let l:target_buf_idx = l:cur_buf_idx + 1 " deeper in list = older
    1              0.000003         else
                                        let l:target_buf_idx = l:cur_buf_idx - 1 " up list = newer
                                    endif
    1              0.000002     endif
    1              0.000003     if l:target_buf_idx < 0
                                    if g:buffergator_mru_cycle_loop
                                        let l:target_buf_idx = len(w:buffergator_mru) - 1
                                    else
                                        call s:_buffergator_messenger.send_info("already at most recent buffer")
                                        return -1
                                    endif
                                elseif l:target_buf_idx >= len(w:buffergator_mru)
                                    if g:buffergator_mru_cycle_loop
                                        let l:target_buf_idx = 0
                                    else
                                        call s:_buffergator_messenger.send_info("already at oldest buffer")
                                        return -1
                                    endif
                                endif
    1              0.000010     let l:target_bufnr = w:buffergator_mru[l:target_buf_idx]
    1              0.000021     if !bufexists(l:target_bufnr) || !buflisted(l:target_bufnr) || getbufvar(l:target_bufnr, "&filetype") == "netrw"
                                    call remove(w:buffergator_mru, l:target_buf_idx)
                                    return s:_find_mru_bufnr(a:dir)
                                else
    1              0.000003         return l:target_bufnr
                                endif

FUNCTION  <SNR>110_reset_untracked_cache()
Called 2 times
Total time:   0.000923
 Self time:   0.000843

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    2              0.000011   if !g:airline#init#vim_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
                              endif
                            
    2              0.000593   let file = expand("%:p")
    6              0.000029   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    4   0.000128   0.000048     call airline#extensions#branch#update_untracked_config(file, vcs)
    4              0.000027     let s:vcs_config[vcs].untracked = {}
    4              0.000007   endfor

FUNCTION  <SNR>12_SelectJavascript()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000014   if getline(1) =~# '^#!.*/bin/\%(env\s\+\)\?node\>'
                                set ft=javascript
                              endif

FUNCTION  322()
Called 3 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000028     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  323()
Called 3 times
Total time:   0.000493
 Self time:   0.000126

count  total (s)   self (s)
    3   0.000166   0.000029     let self._stamp = syntastic#util#stamp()
    6   0.000267   0.000037     for buf in self.getBuffers()
    3              0.000027         call setbufvar(buf, 'syntastic_loclist', self)
    3              0.000005     endfor

FUNCTION  324()
Called 3 times
Total time:   0.000356
 Self time:   0.000094

count  total (s)   self (s)
    6   0.000299   0.000037     for buf in self.getBuffers()
    3              0.000028         call setbufvar(buf, 'syntastic_loclist', {})
    3              0.000006     endfor

FUNCTION  <SNR>124_CheckDefined()
Called 8974 times
Total time:   0.441019
 Self time:   0.441019

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 8974              0.064939   if !exists("g:airline#highlighter#normal_fg_hi")
    2              0.000048     let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
    2              0.000004   endif
 8974              0.058429   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
 2758              0.006756     return a:colors
                              endif
                            
 8371              0.029444   for val in a:colors
 8064              0.043558     if !empty(val) && val !=# 'NONE'
 5909              0.014159       return a:colors
                                endif
 2155              0.003266   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
  307              0.001157   let fg = g:airline#highlighter#normal_fg_hi
  307              0.007283   let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
  307              0.000855   if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
  307              0.005621   return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>278_CurTypeName()
Called 178 times
Total time:   0.005831
 Self time:   0.005831

count  total (s)   self (s)
  178              0.000976 	if s:itemtype < len(s:coretypes)
  178              0.004521 		return filter(copy(s:coretypes), 'v:val[1]==g:ctrlp_types[s:itemtype]')[0]
                            	el
                            		return [s:getextvar("lname"), s:getextvar('sname')]
                            	en

FUNCTION  <SNR>77_BufEnterHook()
Called 23 times
Total time:   0.144134
 Self time:   0.003861

count  total (s)   self (s)
   23   0.026838   0.000357     let buf = syntastic#util#fname2buf(a:fname)
   23   0.001561   0.000755     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
   23              0.000207     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
   23              0.000279         let idx = index(reverse(copy(s:_check_stack)), buf)
   23              0.000057         if idx >= 0
    1              0.000009             if !has('vim_starting')
    1              0.000008                 call remove(s:_check_stack, -idx - 1)
    1   0.070445   0.000032                 call s:UpdateErrors(buf, 1, [])
    1              0.000001             endif
    1              0.000001         elseif &buftype ==# ''
   22   0.043056   0.000483             call s:notifiers.refresh(g:SyntasticLoclist.current())
   22              0.000042         endif
   23              0.000056     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  <SNR>134_remove_signs()
Called 7 times
Total time:   0.000854
 Self time:   0.000498

count  total (s)   self (s)
    7   0.000305   0.000124   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
    7   0.000271   0.000096     let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
    7              0.000098     execute "sign unplace * buffer=" . a:bufnr
    7              0.000021     if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
    7              0.000014   else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
                              endif

FUNCTION  <SNR>277_feedkeys()
Called 3 times
Total time:   0.000314
 Self time:   0.000314

count  total (s)   self (s)
    3              0.000012   while 1
    3              0.000115     let c = getchar(0)
    3              0.000026     let char_type = type(c)
                                " Checking type is important, when strings are compared with integers,
                                " strings are always converted to ints, and all strings are equal to 0
    3              0.000011     if char_type == 0
    3              0.000007       if c == 0
    3              0.000007         break
                                  else
                                    let s:saved_keys .= nr2char(c)
                                  endif
                                elseif char_type == 1 " char with more than 8 bits (as string)
                                  let s:saved_keys .= c
                                endif
                              endwhile
    3              0.000030   call feedkeys(a:keys)

FUNCTION  ctrlp#mrufiles#cachefile()
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000020 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
                            	en
    2              0.000004 	retu s:cafile

FUNCTION  332()
Called 3 times
Total time:   0.000401
 Self time:   0.000296

count  total (s)   self (s)
    3              0.000021     if !exists('w:syntastic_loclist_set')
                                    let w:syntastic_loclist_set = []
                                endif
    3              0.000024     if a:new || empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [self._owner, getbufvar(self._owner, 'changedtick')]
    3              0.000018         let replace = !a:new && g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
    3   0.000095   0.000036         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
    3   0.000061   0.000049         call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
    3              0.000004         try
                                        " Vim 7.4.2200 or later
    3              0.000035             call setloclist(0, [], 'r', { 'title': ':SyntasticCheck ' . self._name })
    3              0.000009         catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                        " do nothing
                                    endtry
    3   0.000059   0.000025         call syntastic#util#setLastTick(self._owner)
    3              0.000029         let w:syntastic_loclist_set = [self._owner, getbufvar(self._owner, 'syntastic_lasttick')]
    3              0.000005     endif

FUNCTION  335()
Called 3 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    3              0.000017     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    3              0.000010         let self._mode = 'active'
    3              0.000010         let self._activeFiletypes = []
    3              0.000009         let self._passiveFiletypes = []
    3              0.000003     endif

FUNCTION  336()
Called 3 times
Total time:   0.000510
 Self time:   0.000156

count  total (s)   self (s)
    3   0.000105   0.000043     let registry = g:SyntasticRegistry.Instance()
    3   0.000255   0.000034     let fts = registry.resolveFiletypes(a:filetype)
                            
    3   0.000043   0.000028     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    3   0.000081   0.000025         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  337()
Called 3 times
Total time:   0.000616
 Self time:   0.000106

count  total (s)   self (s)
    3              0.000027     let local_mode = getbufvar(a:buf, 'syntastic_mode')
    3              0.000014     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    3   0.000554   0.000044     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  338()
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000012     return self._mode ==# 'passive'

FUNCTION  nerdtree#checkForBrowse()
Called 23 times
Total time:   0.007248
 Self time:   0.007248

count  total (s)   self (s)
   23              0.007072     if !isdirectory(a:dir)
   23              0.000091         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>277_fire_pre_triggers()
Called 3 times
Total time:   0.000225
 Self time:   0.000201

count  total (s)   self (s)
    3              0.000018   if !s:before_function_called
    2   0.000128   0.000104     silent doautocmd User MultipleCursorsPre
    2              0.000024     if exists('*Multiple_cursors_before')
                                  exe "call Multiple_cursors_before()"
                                endif
    2              0.000010     let s:before_function_called = 1
    2              0.000003   endif

FUNCTION  airline#extensions#commandt#apply()
Called 37 times
Total time:   0.000573
 Self time:   0.000573

count  total (s)   self (s)
   37              0.000307   if bufname('%') ==# 'GoToFile'
                                call airline#extensions#apply_left_override('CommandT', '')
                              endif

FUNCTION  374()
Called 175 times
Total time:   0.005203
 Self time:   0.003723

count  total (s)   self (s)
  175              0.001305   let spc = empty(a:contents) ? '' : g:airline_symbols.space
  175   0.003625   0.002145   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  <SNR>110_update_branch()
Called 961 times
Total time:   0.802947
 Self time:   0.096999

count  total (s)   self (s)
 2883              0.013700   for vcs in keys(s:vcs_config)
 1922   0.734714   0.028766     call {s:vcs_config[vcs].update_branch}()
 1922              0.014961     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
 1922              0.002991   endfor

FUNCTION  ctrlspace#jumps#IncrementJumpCounter()
Called 24 times
Total time:   0.000272
 Self time:   0.000272

count  total (s)   self (s)
   24              0.000142 	let s:jumpCounter += 1
   24              0.000071 	return s:jumpCounter

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 235 times
Total time:   0.122267
 Self time:   0.009651

count  total (s)   self (s)
  235   0.015806   0.002801   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
  235              0.002071   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
  235   0.103896   0.004285   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  ctrlp#utils#readfile()
Called 2 times
Total time:   0.001868
 Self time:   0.001868

count  total (s)   self (s)
    2              0.000972 	if filereadable(a:file)
    2              0.000853 		let data = readfile(a:file)
    2              0.000018 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    2              0.000004 		retu data
                            	en
                            	retu []

FUNCTION  343()
Called 3 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    3              0.000052     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  345()
Called 25 times
Total time:   0.046007
 Self time:   0.016485

count  total (s)   self (s)
   25   0.002060   0.000635     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
   25   0.000836   0.000306     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
  150              0.000449     for type in self._enabled_types
  125              0.003585         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
  125   0.006381   0.002448         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
  100              0.000694             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
   25              0.000258                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
   25   0.002576   0.000524                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
   25   0.007738   0.000424                     call self._notifier[type].refresh(a:loclist)
   25   0.001579   0.000443                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
   25              0.000055                 endif
   25              0.000032             else
   75   0.014017   0.000885                 call self._notifier[type].refresh(a:loclist)
   75              0.000120             endif
  100              0.000135         endif
  125              0.000195     endfor

FUNCTION  348()
Called 5 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    5              0.000042     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
    5              0.000013     return s:SyntasticRegistryInstance

FUNCTION  <SNR>115_wordcount_update()
Called 1177 times
Total time:   0.115835
 Self time:   0.115835

count  total (s)   self (s)
 1177              0.008031   if empty(bufname(''))
                                return
                              endif
 1177              0.045201   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  gitgutter#diff#parse_diff()
Called 4 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
    4              0.000018   let hunks = []
    4              0.000050   for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
                              endfor
    4              0.000008   return hunks

FUNCTION  <SNR>278_fnesc()
Called 7670 times
Total time:   0.812874
 Self time:   0.095773

count  total (s)   self (s)
 7670   0.805806   0.088705 	retu call('ctrlp#utils#fnesc', a:000)

FUNCTION  airline#async#vim_vcs_untracked()
Called 20 times
Total time:   0.208362
 Self time:   0.208362

count  total (s)   self (s)
   20              0.000076     if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
   20              0.000258       let cmd = ['sh', '-c', a:config['cmd'] . shellescape(a:file)]
   20              0.000030     endif
                            
   20              0.000192     let options = {'cfg': a:config, 'buf': '', 'file': a:file}
   20              0.000121     if has_key(s:untracked_jobs, a:file)
   15              0.000234       if job_status(get(s:untracked_jobs, a:file)) == 'run'
   15              0.000123         return
                                  elseif has_key(s:untracked_jobs, a:file)
                                    call remove(s:untracked_jobs, a:file)
                                  endif
                                endif
    5              0.206919     let id = job_start(cmd, { 'err_io':   'out', 'out_cb':   function('s:on_stdout', options), 'close_cb': function('s:on_exit_untracked', options)})
    5              0.000087     let s:untracked_jobs[a:file] = id

FUNCTION  fugitive#foldtext()
Called 5378 times
Total time:   0.125243
 Self time:   0.125243

count  total (s)   self (s)
 5378              0.029837   if &foldmethod !=# 'syntax'
 5378              0.082593     return foldtext()
                              elseif getline(v:foldstart) =~# '^diff '
                                let [add, remove] = [-1, -1]
                                let filename = ''
                                for lnum in range(v:foldstart, v:foldend)
                                  if filename ==# '' && getline(lnum) =~# '^[+-]\{3\} [abciow12]/'
                                    let filename = getline(lnum)[6:-1]
                                  endif
                                  if getline(lnum) =~# '^+'
                                    let add += 1
                                  elseif getline(lnum) =~# '^-'
                                    let remove += 1
                                  elseif getline(lnum) =~# '^Binary '
                                    let binary = 1
                                  endif
                                endfor
                                if filename ==# ''
                                  let filename = matchstr(getline(v:foldstart), '^diff .\{-\} [abciow12]/\zs.*\ze [abciow12]/')
                                endif
                                if filename ==# ''
                                  let filename = getline(v:foldstart)[5:-1]
                                endif
                                if exists('binary')
                                  return 'Binary: '.filename
                                else
                                  return (add<10&&remove<100?' ':'') . add . '+ ' . (remove<10&&add<100?' ':'') . remove . '- ' . filename
                                endif
                              elseif getline(v:foldstart) =~# '^# .*:$'
                                let lines = getline(v:foldstart, v:foldend)
                                call filter(lines, 'v:val =~# "^#\t"')
                                cal map(lines,'s:sub(v:val, "^#\t%(modified: +|renamed: +)=", "")')
                                cal map(lines,'s:sub(v:val, "^([[:alpha:] ]+): +(.*)", "\\2 (\\1)")')
                                return getline(v:foldstart).' '.join(lines, ', ')
                              endif
                              return foldtext()

FUNCTION  <SNR>278_matchlens()
Called 283 times
Total time:   0.016610
 Self time:   0.010536

count  total (s)   self (s)
  283              0.003021 	if empty(a:pat) || index(['^', '$'], a:pat) >= 0 | retu {} | en
  121              0.000382 	let st   = a:0 ? a:1 : 0
  121              0.000437 	let lens = a:0 >= 2 ? a:2 : {}
  121              0.000347 	let nr   = a:0 >= 3 ? a:3 : 0
  121              0.000496 	if nr > 20 | retu {} | en
  121              0.001151 	if match(a:str, a:pat, st) >= 0
   67              0.001346 		let [mst, mnd] = [matchstr(a:str, a:pat, st), matchend(a:str, a:pat, st)]
   67              0.000891 		let lens = extend(lens, { nr : [strlen(mst), mst] })
   67              0.000886 		let lens = s:matchlens(a:str, a:pat, mnd, lens, nr + 1)
   67              0.000083 	en
  121              0.000217 	retu lens

FUNCTION  <SNR>110_has_fugitive()
Called 961 times
Total time:   0.008042
 Self time:   0.008042

count  total (s)   self (s)
  961              0.006796   return exists('*fugitive#head')

FUNCTION  <SNR>157_on_stderr_vim()
Called 72 times
Total time:   0.019271
 Self time:   0.009618

count  total (s)   self (s)
   72   0.012470   0.002817   call self.handler.err(self.buffer)
   72              0.000124   try
   72              0.005450     call ch_close(a:channel)  " so close_cb and its 'out' handler are not triggered
   66              0.000280   catch /E906/
                                " noop
    6              0.000024   endtry

FUNCTION  onedark#GetColors()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   return s:colors

FUNCTION  <SNR>55_get_airline_themes()
Called 7 times
Total time:   0.519036
 Self time:   0.519036

count  total (s)   self (s)
    7              0.516577   let files = split(globpath(&rtp, 'autoload/airline/themes/'.a:a.'*'), "\n")
    7              0.002412   return map(files, 'fnamemodify(v:val, ":t:r")')

FUNCTION  <SNR>124_Get()
Called 15092 times
Total time:   0.236079
 Self time:   0.236079

count  total (s)   self (s)
15092              0.094103   let res=get(a:dict, a:key, '')
15092              0.041481   if res is ''
 6297              0.010575     return ''
                              else
 8795              0.032134     return a:prefix. res
                              endif

FUNCTION  airline#extensions#tabline#tabs#map_keys()
Called 87 times
Total time:   0.001021
 Self time:   0.001021

count  total (s)   self (s)
   87              0.000661   if exists("s:airline_tabline_map_key")
   87              0.000152     return
                              endif
                              noremap <silent> <Plug>AirlineSelectTab1 :1tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab2 :2tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab3 :3tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab4 :4tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab5 :5tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab6 :6tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab7 :7tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab8 :8tabn<CR>
                              noremap <silent> <Plug>AirlineSelectTab9 :9tabn<CR>
                              noremap <silent> <Plug>AirlineSelectPrevTab gT
                              " tabn {count} goes to count tab does not go {count} tab pages forward!
                              noremap <silent> <Plug>AirlineSelectNextTab :<C-U>exe repeat(':tabn\|', v:count1)<cr>
                              let s:airline_tabline_map_key = 1

FUNCTION  <SNR>278_mfunc()
Called 3 times
Total time:   0.000459
 Self time:   0.000145

count  total (s)   self (s)
    3              0.000010 	let mfunc = 'match'
    3   0.000239   0.000035 	if s:byfname()
                            		let mfunc = 's:matchfname'
                            	elsei s:curtype() == 'buf'
                            		let mfunc = 's:matchbuf'
                            	elsei s:itemtype >= len(s:coretypes)
                            		let matchtypes = { 'tabs': 's:matchtabs', 'tabe': 's:matchtabe' }
                            		if has_key(matchtypes, s:matchtype)
                            			let mfunc = matchtypes[s:matchtype]
                            		en
                            	en
    3              0.000006 	retu mfunc

FUNCTION  350()
Called 3 times
Total time:   0.044778
 Self time:   0.000636

count  total (s)   self (s)
    3   0.000213   0.000031     let ftlist = self.resolveFiletypes(a:ftalias)
                            
    3              0.000038     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
    3              0.000008     let cnames = []
    3              0.000010     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
                                else
    6              0.000016         for ft in ftlist
    3   0.000173   0.000031             call self._sanityCheck(ft)
    3              0.000041             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
    3              0.000061             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
    3              0.000005         endfor
    3              0.000004     endif
    3   0.000210   0.000038     let cnames = syntastic#util#unique(cnames)
                            
    6   0.000246   0.000086     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
    3   0.043318   0.000033         call self._loadCheckersFor(ft, 0)
    3              0.000004     endfor
                            
    3   0.000254   0.000053     return self._filterCheckersByName(cnames)

FUNCTION  ctrlspace#roots#SetLastProjectRoot()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000007 	let s:lastProjectRoot = a:value
    1              0.000004 	return s:lastProjectRoot

FUNCTION  355()
Called 6 times
Total time:   0.000403
 Self time:   0.000211

count  total (s)   self (s)
    6   0.000395   0.000203     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  357()
Called 2 times
Total time:   0.000119
 Self time:   0.000102

count  total (s)   self (s)
    2   0.000030   0.000021     let ft = a:checker.getFiletype()
    2              0.000011     if !has_key(self._checkerMap, ft)
    1              0.000006         let self._checkerMap[ft] = {}
    1              0.000002     endif
                            
    2   0.000026   0.000018     let name = a:checker.getName()
    2              0.000011     if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
    2              0.000012     let self._checkerMap[ft][name] = a:checker

FUNCTION  ctrlspace#api#TabTitle()
Called 87 times
Total time:   0.010422
 Self time:   0.007532

count  total (s)   self (s)
   87              0.000373 	let bufname = a:bufname
   87              0.000250 	let bufnr   = a:bufnr
   87   0.003955   0.001065 	let title   = ctrlspace#util#Gettabvar(a:tabnr, "CtrlSpaceLabel")
                            
   87              0.000291 	if empty(title)
   87              0.001061 		if getbufvar(bufnr, "&ft") == "ctrlspace"
    2              0.000006 			if s:modes.Zoom.Enabled
                            				if s:modes.Zoom.Data.Buffer
                            					let bufnr = s:modes.Zoom.Data.Buffer
                            				endif
                            			else
    2              0.000013 				let bufnr = winbufnr(t:CtrlSpaceStartWindow)
    2              0.000002 			endif
                            
    2              0.000013 			let bufname = bufname(bufnr)
    2              0.000002 		endif
                            
   87              0.000335 		if empty(bufname)
                            			let title = "[" . bufnr . "*No Name]"
                            		else
   87              0.000751 			let title = "[" . fnamemodify(bufname, ':t') . "]"
   87              0.000118 		endif
   87              0.000092 	endif
                            
   87              0.000202 	return title

FUNCTION  <SNR>278_CloseCustomFuncs()
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000018 	if s:igntype == 4 && has_key(s:usrign, 'func-close') && s:usrign['func-close'] != ''
                            		exe call(s:usrign['func-close'], [])
                            	en

FUNCTION  airline#extensions#tabline#ctrlspace#invalidate()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000007   let s:current_bufnr = -1
    1              0.000003   let s:current_tabnr = -1

FUNCTION  <SNR>277_last_char()
Called 4 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    4              0.000048   return s:char[len(s:char)-1]

FUNCTION  airline#extensions#tabline#new_builder()
Called 33 times
Total time:   0.005096
 Self time:   0.002562

count  total (s)   self (s)
   33              0.000736   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
   33              0.000196   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
   33              0.000290     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
   33              0.000280     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
   33              0.000081   endif
                            
   33   0.002937   0.000403   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  airline#util#shorten()
Called 2435 times
Total time:   0.079702
 Self time:   0.079702

count  total (s)   self (s)
 2435              0.023413   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
 2435              0.005902     return a:text
                              endif

FUNCTION  <SNR>65_RehighlightBlame()
Called 2 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    2              0.000015   for [hash, cterm] in items(s:hash_colors)
                                if !empty(cterm) || has('gui_running') || has('termguicolors') && &termguicolors
                                  exe 'hi FugitiveblameHash'.hash.' guifg=#'.hash.get(s:hash_colors, hash, '')
                                else
                                  exe 'hi link FugitiveblameHash'.hash.' Identifier'
                                endif
                              endfor

FUNCTION  <SNR>278_remarksigns()
Called 4 times
Total time:   0.000070
 Self time:   0.000037

count  total (s)   self (s)
    4   0.000065   0.000032 	if !s:dosigns() | retu | en
                            	for ic in range(1, len(s:lines))
                            		let line = s:ispath ? fnamemodify(s:lines[ic - 1], ':p') : s:lines[ic - 1]
                            		let key = s:dictindex(s:marked, line)
                            		if key > 0
                            			exe 'sign place' key 'line='.ic.' name=ctrlpmark buffer='.s:bufnr
                            		en
                            	endfo

FUNCTION  <SNR>278_ifilter()
Called 1 time
Total time:   0.001840
 Self time:   0.001840

count  total (s)   self (s)
    1              0.000033 	let [rlist, estr] = [[], substitute(a:str, 'v:val', 'each', 'g')]
    6              0.000026 	for each in a:list
    5              0.000012 		try
    5              0.001626 			if eval(estr)
    1              0.000012 				cal add(rlist, each)
    1              0.000002 			en
    5              0.000017 		cat | con | endt
    5              0.000009 	endfo
    1              0.000003 	retu rlist

FUNCTION  361()
Called 3 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    3              0.000038     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
                                endif
                            
    3              0.000038     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  363()
Called 50 times
Total time:   0.002601
 Self time:   0.000868

count  total (s)   self (s)
   50   0.002525   0.000792     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  syntastic#util#rmrf()
Called 1 time
Total time:   0.014478
 Self time:   0.014478

count  total (s)   self (s)
                                " try to make sure we don't delete directories we didn't create
    1              0.000018     if a:what !~? 'vim-syntastic-'
                                    return
                                endif
                            
    1              0.000216     if  getftype(a:what) ==# 'dir'
    1              0.014216         call s:_delete(a:what, 'rf')
    1              0.000007     else
                                    silent! call delete(a:what)
                                endif

FUNCTION  366()
Called 25 times
Total time:   0.002433
 Self time:   0.002286

count  total (s)   self (s)
   25              0.000107     let loclist = a:loclist
   25   0.000348   0.000201     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  367()
Called 25 times
Total time:   0.000819
 Self time:   0.000819

count  total (s)   self (s)
   25              0.000172     if has('signs')
   25              0.000205         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
   25              0.000033     endif

FUNCTION  ctrlspace#util#Gettabvar()
Called 87 times
Total time:   0.002890
 Self time:   0.002890

count  total (s)   self (s)
   87              0.000762 	let value = gettabvar(a:nr, a:name)
                            
   87              0.000581 	if type(value) == 1 && empty(value)
   87              0.000218 		unlet value
   87              0.000521 		let value = gettabvar(a:nr, a:name)
   87              0.000113 	endif
                            
   87              0.000167 	return value

FUNCTION  <SNR>278_getextvar()
Called 10 times
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
   10              0.000079 	if s:itemtype >= len(s:coretypes) && len(g:ctrlp_ext_vars) > 0
                            		let vars = g:ctrlp_ext_vars[s:itemtype - len(s:coretypes)]
                            		if has_key(vars, a:key)
                            			retu vars[a:key]
                            		en
                            	en
   10              0.000092 	retu get(g:, 'ctrlp_' . s:matchtype . '_' . a:key, -1)

FUNCTION  <SNR>277_get_char()
Called 4 times
Total time:   0.000507
 Self time:   0.000507

count  total (s)   self (s)
    4              0.000348   let c = (a:0 == 0) ? getchar() : getchar(a:1)
                              " If the character is a number, then it's not a special key
    4              0.000053   if type(c) == 0
    4              0.000035     let c = nr2char(c)
    4              0.000011   endif
    4              0.000016   return c

FUNCTION  ctrlspace#context#PluginBuffer()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000005 	return s:pluginBuffer

FUNCTION  <SNR>110_update_hg_branch()
Called 961 times
Total time:   0.086892
 Self time:   0.078330

count  total (s)   self (s)
  961   0.018104   0.009542   if s:has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
  961              0.005037     let s:vcs_config['mercurial'].branch = ''
  961              0.001335   endif

FUNCTION  ctrlspace#bookmarks#FindActiveBookmark()
Called 1 time
Total time:   0.001276
 Self time:   0.000164

count  total (s)   self (s)
    1   0.000054   0.000046 	let root = ctrlspace#roots#CurrentProjectRoot()
                            
    1              0.000006 	if empty(root)
                            		let root = fnamemodify(".", ":p:h")
                            	endif
                            
    1   0.000602   0.000048 	let root = ctrlspace#util#NormalizeDirectory(root)
                            
    1              0.000006 	for bm in s:bookmarks
    1   0.000556   0.000019 		if ctrlspace#util#NormalizeDirectory(bm.Directory) == root
    1   0.000032   0.000019 			let bm.JumpCounter = ctrlspace#jumps#IncrementJumpCounter()
    1              0.000003 			return bm
                            		endif
                            	endfor
                            
                            	return {}

FUNCTION  airline#highlighter#add_separator()
Called 816 times
Total time:   1.043353
 Self time:   0.024027

count  total (s)   self (s)
  816              0.008881   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  816   1.033253   0.013927   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  373()
Called 69 times
Total time:   0.000610
 Self time:   0.000610

count  total (s)   self (s)
   69              0.000517   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  airline#highlighter#get_highlight()
Called 15133 times
Total time:   4.573364
 Self time:   1.875299

count  total (s)   self (s)
15133              0.128247   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
15133   1.391912   0.170349     let fg = s:get_syn(a:group, 'fg')
15133   1.359469   0.168846     let bg = s:get_syn(a:group, 'bg')
15133              0.475821     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
15133              0.284075     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
15133              0.043287     let opts = a:000
15133              0.027929     if bold
 3748              0.011352       let opts = ['bold']
 3748              0.004692     endif
15133   0.512286   0.226407     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
15133              0.022826   endif
15133              0.091667   let s:hl_groups[a:group] = res
15133              0.027954   return res

FUNCTION  <SNR>278_gethistloc()
Called 3 times
Total time:   0.000419
 Self time:   0.000202

count  total (s)   self (s)
    3   0.000085   0.000066 	let utilcadir = ctrlp#utils#cachedir()
    3   0.000172   0.000071 	let cache_dir = utilcadir.s:lash(utilcadir).'hist'
    3   0.000156   0.000059 	retu [cache_dir, cache_dir.s:lash(cache_dir).'cache.txt']

FUNCTION  ctrlspace#api#Buffers()
Called 23 times
Total time:   0.005701
 Self time:   0.004211

count  total (s)   self (s)
   23              0.000090 	let bufferList     = {}
   23   0.001783   0.000293 	let ctrlspaceList  = ctrlspace#buffers#Buffers(a:tabnr)
   23              0.000136 	let visibleBuffers = tabpagebuflist(a:tabnr)
                            
   91              0.000310 	for i in keys(ctrlspaceList)
   68              0.000315 		let i = str2nr(i)
                            
   68              0.000356 		let bufname = bufname(i)
                            
   68              0.000560 		if !strlen(bufname) && (getbufvar(i, '&modified') || (index(visibleBuffers, i) != -1))
                            			let bufname = '[' . i . '*No Name]'
                            		endif
                            
   68              0.000265 		if strlen(bufname)
   68              0.000398 			let bufferList[i] = bufname
   68              0.000098 		endif
   68              0.000085 	endfor
                            
   23              0.000046 	return bufferList

FUNCTION  <SNR>278_SetDefTxt()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000019 	if s:deftxt == '0' || ( s:deftxt == 1 && !s:ispath ) | retu | en
                            	let txt = s:deftxt
                            	if !type(txt)
                            		let path = s:crfpath.s:lash(s:crfpath)
                            		let txt = txt && !stridx(path, s:dyncwd) ? ctrlp#rmbasedir([path])[0] : ''
                            	en
                            	let s:prompt[0] = txt

FUNCTION  <SNR>65_can_diffoff()
Called 46 times
Total time:   0.001082
 Self time:   0.001082

count  total (s)   self (s)
   46              0.000993   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  airline#util#wrap()
Called 8661 times
Total time:   0.107534
 Self time:   0.107534

count  total (s)   self (s)
 8661              0.044589   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 8661              0.019291   return a:text

FUNCTION  gitgutter#debug#log()
Called 80 times
Total time:   0.007793
 Self time:   0.007793

count  total (s)   self (s)
   80              0.000320   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  airline#load_theme()
Called 9 times
Total time:   0.813448
 Self time:   0.000905

count  total (s)   self (s)
    9              0.000075   let g:airline_theme = get(g:, 'airline_theme', 'dark')
    9              0.000099   if exists('*airline#themes#{g:airline_theme}#refresh')
    3   0.004547   0.000032     call airline#themes#{g:airline_theme}#refresh()
    3              0.000005   endif
                            
    9              0.000053   let palette = g:airline#themes#{g:airline_theme}#palette
    9   0.034749   0.000109   call airline#themes#patch(palette)
                            
    9              0.000050   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    9   0.423259   0.000111   call airline#highlighter#load_theme()
    9   0.117610   0.000113   call airline#extensions#load_theme()
    9   0.232826   0.000083   call airline#update_statusline()

FUNCTION  <SNR>101_sync_active_winnr()
Called 1175 times
Total time:   0.160029
 Self time:   0.021233

count  total (s)   self (s)
 1175              0.012910   if exists('#airline') && winnr() != s:active_winnr
    6   0.138869   0.000073     call airline#update_statusline()
    6              0.000008   endif

FUNCTION  380()
Called 69 times
Total time:   1.542226
 Self time:   0.108284

count  total (s)   self (s)
   69              0.000216   let side = 1
   69              0.000166   let line = ''
   69              0.000152   let i = 0
   69              0.000341   let length = len(self._sections)
   69              0.000161   let split = 0
   69              0.000163   let is_empty = 0
   69              0.000178   let prev_group = ''
                            
  665              0.001654   while i < length
  596              0.002864     let section = self._sections[i]
  596              0.002635     let group = section[0]
  596              0.002555     let contents = section[1]
  596              0.001873     let pgroup = prev_group
  596   0.022009   0.006710     let prev_group = airline#builder#get_prev_group(self._sections, i)
  596              0.002930     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
  596              0.001079     if is_empty
                                  let prev_group = pgroup
                                endif
  596   0.021703   0.006746     let is_empty = s:section_is_empty(self, contents)
                            
  596              0.001166     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
  596              0.001550     if group == ''
                                  let line .= contents
                                elseif group == '|'
   69              0.000150       let side = 0
   69              0.000332       let line .= contents
   69              0.000152       let split = 1
   69              0.000084     else
  527              0.001476       if prev_group == ''
   69              0.000405         let line .= '%#'.group.'#'
   69              0.000130       elseif split
   69              0.000130         if !is_empty
   69   0.185319   0.001102           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   69              0.000114         endif
   69              0.000162         let split = 0
   69              0.000091       else
  389              0.000780         if !is_empty
  389   1.165207   0.005792           let line .= s:get_seperator(self, prev_group, group, side)
  389              0.000603         endif
  389              0.000463       endif
  527   0.069694   0.009640       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  527              0.000813     endif
                            
  596              0.002498     let i = i + 1
  596              0.001230   endwhile
                            
   69              0.000185   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    5              0.000636     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    5              0.000009   endif
   69              0.000179   return line

FUNCTION  383()
Called 23 times
Total time:   0.507459
 Self time:   0.007117

count  total (s)   self (s)
   23              0.000154   if has_key(self, '_left_position') && self._first_title <= self._last_title
                                let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
                                let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
                                let sep_size = s:tabline_evaluated_length(self._context.left_sep)
                                let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
                                let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
                                let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
                                let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
                                let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
                                if self._left_title > self._first_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
                                endif
                                if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
                                endif
                            
                                " Add the current title
                                let group = self.get_group(self._left_title)
                                if self._left_title == self._first_title
                                  let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
                                else
                                  let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
                                if self._left_title == self._last_title
                                  let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
                                else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
                                let left_group = group
                                let right_group = group
                                let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
                                if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
                                endif
                            
                                if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
                                endif
                            
                                while self._remaining_space > 0
                                  let done = 0
                                  if self._left_title >= self._first_title
                                    " Insert next title to the left
                                    let group = self.get_group(self._left_title)
                                    if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let left_group = group
                                    let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
                                    let self._left_title -= done
                                  endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
                                  if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
                                  endif
                                  if !done
                                    break
                                  endif
                                endwhile
                            
                                if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
                                endif
                            
                                if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
                                endif
                              endif
                            
   23   0.500620   0.000278   return self._build()

FUNCTION  <SNR>278_sublist()
Called 4 times
Total time:   0.037684
 Self time:   0.037684

count  total (s)   self (s)
    4              0.037666 	retu v:version > 701 ? a:l[(a:s):(a:e)] : s:sublist7071(a:l, a:s, a:e)

FUNCTION  <SNR>278_getparent()
Called 228 times
Total time:   0.021427
 Self time:   0.021427

count  total (s)   self (s)
  228              0.016256 	let parent = substitute(a:item, '[\/][^\/]\+[\/:]\?$', '', '')
  228              0.003087 	if parent == '' || parent !~ '[\/]'
    3              0.000017 		let parent .= s:lash
    3              0.000005 	en
  228              0.000526 	retu parent

FUNCTION  <SNR>278_lsCmd()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000005 	let cmd = s:usrcmd
    1              0.000005 	if type(cmd) == 1
    1              0.000002 		retu cmd
                            	elsei type(cmd) == 3 && len(cmd) >= 2 && cmd[:1] != ['', '']
                            		if s:findroot(s:dyncwd, cmd[0], 0, 1) == []
                            			retu len(cmd) == 3 ? cmd[2] : ''
                            		en
                            		let s:vcscmd = s:lash == '\'
                            		retu cmd[1]
                            	elsei type(cmd) == 4 && ( has_key(cmd, 'types') || has_key(cmd, 'fallback') )
                            		let fndroot = []
                            		if has_key(cmd, 'types') && cmd['types'] != {}
                            			let [markrs, cmdtypes] = [[], values(cmd['types'])]
                            			for pair in cmdtypes
                            				cal add(markrs, pair[0])
                            			endfo
                            			let fndroot = s:findroot(s:dyncwd, markrs, 0, 1)
                            		en
                            		if fndroot == []
                            			retu has_key(cmd, 'fallback') ? cmd['fallback'] : ''
                            		en
                            		for pair in cmdtypes
                            			if pair[0] == fndroot[0] | brea | en
                            		endfo
                            		let s:vcscmd = s:lash == '\'
                            		retu pair[1]
                            	en

FUNCTION  ctrlp#recordhist()
Called 3 times
Total time:   0.008274
 Self time:   0.000140

count  total (s)   self (s)
    3              0.000044 	let str = join(s:prompt, '')
    3              0.000025 	if empty(str) || !s:maxhst | retu | en
    1              0.000003 	let hst = s:hstry
    1              0.000006 	if len(hst) > 1 && hst[1] == str | retu | en
    1              0.000006 	cal extend(hst, [str], 1)
    1              0.000007 	if len(hst) > s:maxhst | cal remove(hst, s:maxhst, -1) | en
    1   0.008171   0.000037 	cal ctrlp#utils#writecache(hst, s:gethistloc()[0], s:gethistloc()[1])

FUNCTION  <SNR>257_NewCatalogViewer()
Called 2 times
Total time:   0.003451
 Self time:   0.002683

count  total (s)   self (s)
                            
                                " initialize
    2              0.000013     let catalog_viewer = {}
    2              0.000015     let catalog_viewer["bufname"] = a:name
    2              0.000014     let catalog_viewer["title"] = a:title
    2   0.000797   0.000071     let l:buffergator_bufs = s:_find_buffers_with_var("is_buffergator_buffer", 1)
    2              0.000014     if len(l:buffergator_bufs) > 0
                                    let catalog_viewer["bufnum"] = l:buffergator_bufs[0]
                                endif
    2              0.000014     let catalog_viewer["jump_map"] = {}
    2   0.000101   0.000059     let catalog_viewer["split_mode"] = s:_get_split_mode()
    2              0.000016     let catalog_viewer["sort_regime"] = g:buffergator_sort_regime
    2              0.000016     let catalog_viewer["display_regime"] = g:buffergator_display_regime
    2              0.000012     let catalog_viewer["is_zoomed"] = 0
    2              0.000012     let catalog_viewer["columns_expanded"] = 0
    2              0.000013     let catalog_viewer["lines_expanded"] = 0
    2              0.000015     let catalog_viewer["max_buffer_basename_len"] = 30
                            
                                " Initialize object state.
    2              0.000012     let catalog_viewer["bufnum"] = -1
                            
    2              0.000010     function! catalog_viewer.line_symbols(bufinfo) dict
                                  let l:line_symbols = ""
                                  " so we can control the order they are shown in
                                  let l:noted_status = s:buffergator_buffer_line_symbols_order
                                  for l:status in l:noted_status
                                    if a:bufinfo['is_' . l:status]
                                      let l:line_symbols .= s:buffergator_buffer_line_symbols[l:status]
                                    else
                                      let l:line_symbols .= " "
                                    endif
                                  endfor
                                  return l:line_symbols
                                endfunction
                            
    2              0.000006     function! catalog_viewer.list_buffers() dict
                                    let bcat = []
                                    redir => buffers_output
                                    execute('silent ls')
                                    redir END
                                    let self.max_buffer_basename_len = 0
                                    let l:buffers_output_rows = split(l:buffers_output, "\n")
                                    for l:buffers_output_row in l:buffers_output_rows
                                        let l:parts = matchlist(l:buffers_output_row, '^\s*\(\d\+\)\(.....\) "\(.*\)"')
                                        let l:info = {}
                                        let l:info["bufnum"] = l:parts[1] + 0
                                        if l:parts[2][0] == "u"
                                            let l:info["is_unlisted"] = 1
                                            let l:info["is_listed"] = 0
                                        else
                                            let l:info["is_unlisted"] = 0
                                            let l:info["is_listed"] = 1
                                        endif
                                        if l:parts[2][1] == "%"
                                            let l:info["is_current"] = 1
                                            let l:info["is_alternate"] = 0
                                        elseif l:parts[2][1] == "#"
                                            let l:info["is_current"] = 0
                                            let l:info["is_alternate"] = 1
                                        else
                                            let l:info["is_current"] = 0
                                            let l:info["is_alternate"] = 0
                                        endif
                                        if l:parts[2][2] == "a"
                                            let l:info["is_active"] = 1
                                            let l:info["is_loaded"] = 1
                                            let l:info["is_visible"] = 1
                                        elseif l:parts[2][2] == "h"
                                            let l:info["is_active"] = 0
                                            let l:info["is_loaded"] = 1
                                            let l:info["is_visible"] = 0
                                        else
                                            let l:info["is_active"] = 0
                                            let l:info["is_loaded"] = 0
                                            let l:info["is_visible"] = 0
                                        endif
                                        if l:parts[2][3] == "-"
                                            let l:info["is_modifiable"] = 0
                                            let l:info["is_readonly"] = 0
                                        elseif l:parts[2][3] == "="
                                            let l:info["is_modifiable"] = 1
                                            let l:info["is_readonly"] = 1
                                        else
                                            let l:info["is_modifiable"] = 1
                                            let l:info["is_readonly"] = 0
                                        endif
                                        if l:parts[2][4] == "+"
                                            let l:info["is_modified"] = 1
                                            let l:info["is_readerror"] = 0
                                        elseif l:parts[2][4] == "x"
                                            let l:info["is_modified"] = 0
                                            let l:info["is_readerror"] = 0
                                        else
                                            let l:info["is_modified"] = 0
                                            let l:info["is_readerror"] = 0
                                        endif
                                        let l:info["bufname"] = parts[3]
                                        let l:info["filepath"] = fnamemodify(l:info["bufname"], ":p")
                                        " if g:buffergator_show_full_directory_path
                                        "     let l:info["filepath"] = fnamemodify(l:info["bufname"], ":p")
                                        " else
                                        "     let l:info["filepath"] = fnamemodify(l:info["bufname"], ":.")
                                        " endif
                                        let l:info["basename"] = fnamemodify(l:info["bufname"], ":t")
                                        if len(l:info["basename"]) > self.max_buffer_basename_len
                                            let self.max_buffer_basename_len = len(l:info["basename"])
                                        endif
                                        let l:info["parentdir"] = fnamemodify(l:info["bufname"], ":p:h")
                                        if g:buffergator_show_full_directory_path
                                            let l:info["parentdir"] = fnamemodify(l:info["bufname"], ":p:h")
                                        else
                                            let l:info["parentdir"] = fnamemodify(l:info["bufname"], ":h")
                                        endif
                                        let l:info["extension"] = fnamemodify(l:info["bufname"], ":e")
                                        call add(bcat, l:info)
                                        " let l:buffers_info[l:info[l:key]] = l:info
                                    endfor
                                    let l:sort_func = "s:_compare_dicts_by_" . self.sort_regime
                                    return sort(bcat, l:sort_func)
                                endfunction
                            
                                " Opens viewer if closed, closes viewer if open.
    2              0.000008     function! catalog_viewer.toggle() dict
                                    " get buffer number of the catalog view buffer, creating it if neccessary
                                    if self.bufnum < 0 || !bufexists(self.bufnum)
                                        call self.open()
                                    else
                                        let l:bfwn = bufwinnr(self.bufnum)
                                        if l:bfwn >= 0
                                            call self.close(1)
                                        else
                                            call self.open()
                                        endif
                                    endif
                                endfunction
                            
                                " Creates a new buffer, renders and opens it.
    2              0.000006     function! catalog_viewer.create_buffer() dict
                                    " get a new buf reference
                                    let self.bufnum = bufnr(self.bufname, 1)
                                    " get a viewport onto it
                                    call self.activate_viewport()
                                    " initialize it (includes "claiming" it)
                                    call self.initialize_buffer()
                                    " render it
                                    call self.render_buffer()
                                endfunction
                            
                                " Opens a viewport on the buffer according, creating it if neccessary
                                " according to the spawn mode. Valid buffer number must already have been
                                " obtained before this is called.
    2              0.000007     function! catalog_viewer.activate_viewport() dict
                                    let l:bfwn = bufwinnr(self.bufnum)
                                    if l:bfwn == winnr()
                                        " viewport wth buffer already active and current
                                        return
                                    elseif l:bfwn >= 0
                                        " viewport with buffer exists, but not current
                                        execute(l:bfwn . " wincmd w")
                                    else
                                        " create viewport
                                        let self.split_mode = s:_get_split_mode()
                                        call self.expand_screen()
                                        execute("silent keepalt keepjumps " . self.split_mode . " " . self.bufnum)
                                        if g:buffergator_viewport_split_policy =~ '[RrLl]' && g:buffergator_vsplit_size
                                            execute("vertical resize " . g:buffergator_vsplit_size)
                                            setlocal winfixwidth
                                        elseif g:buffergator_viewport_split_policy =~ '[TtBb]' && g:buffergator_hsplit_size
                                            execute("resize " . g:buffergator_hsplit_size)
                                            setlocal winfixheight
                                        endif
                                    endif
                                endfunction
                            
                                " Sets up buffer environment.
    2              0.000007     function! catalog_viewer.initialize_buffer() dict
                                    call self.claim_buffer()
                                    call self.setup_buffer_opts()
                                    call self.setup_buffer_syntax()
                                    call self.setup_buffer_commands()
                                    call self.setup_buffer_keymaps()
                                    call self.setup_buffer_folding()
                                    call self.setup_buffer_statusline()
                                endfunction
                            
                                " 'Claims' a buffer by setting it to point at self.
    2              0.000006     function! catalog_viewer.claim_buffer() dict
                                    call setbufvar("%", "is_buffergator_buffer", 1)
                                    call setbufvar("%", "buffergator_catalog_viewer", self)
                                    call setbufvar("%", "buffergator_last_render_time", 0)
                                    call setbufvar("%", "buffergator_cur_line", 0)
                                endfunction
                            
                                " 'Unclaims' a buffer by stripping all buffergator vars
    2              0.000007     function! catalog_viewer.unclaim_buffer() dict
                                    for l:var in ["is_buffergator_buffer", "buffergator_catalog_viewer", "buffergator_last_render_time", "buffergator_cur_line" ]
                                        if exists("b:" . l:var)
                                            unlet b:{l:var}
                                        endif
                                    endfor
                                endfunction
                            
                                " Sets buffer options.
    2              0.000006     function! catalog_viewer.setup_buffer_opts() dict
                                    setlocal buftype=nofile
                                    setlocal noswapfile
                                    setlocal nowrap
                                    set bufhidden=hide
                                    setlocal nobuflisted
                                    setlocal nolist
                                    setlocal noinsertmode
                                    setlocal nonumber
                                    setlocal norelativenumber
                                    setlocal cursorline
                                    setlocal nospell
                                    setlocal matchpairs=""
                                    setlocal filetype=buffergator
                                endfunction
                            
                                " Sets buffer commands.
    2              0.000006     function! catalog_viewer.setup_buffer_commands() dict
                                    " command! -bang -nargs=* Bdfilter :call b:buffergator_catalog_viewer.set_filter('<bang>', <q-args>)
                                    augroup BuffergatorCatalogViewer
                                        au!
                                        autocmd BufLeave <buffer> let s:_buffergator_last_catalog_viewed = b:buffergator_catalog_viewer
                                    augroup END
                                endfunction
                            
    2              0.000007     function! catalog_viewer.disable_editing_keymaps() dict
                                    """" Disabling of unused modification keys
                                    for key in [".", "p", "P", "C", "x", "X", "r", "R", "i", "I", "a", "A", "D", "S", "U"]
                                        try
                                            execute "nnoremap <buffer> " . key . " <NOP>"
                                        catch //
                                        endtry
                                    endfor
                                endfunction
                            
                                " Sets buffer folding.
    2              0.000007     function! catalog_viewer.setup_buffer_folding() dict
                                    " if has("folding")
                                    "     "setlocal foldcolumn=3
                                    "     setlocal foldmethod=syntax
                                    "     setlocal foldlevel=4
                                    "     setlocal foldenable
                                    "     setlocal foldtext=BuffergatorFoldText()
                                    "     " setlocal fillchars=fold:\ "
                                    "     setlocal fillchars=fold:.
                                    " endif
                                endfunction
                            
                                " Close and quit the viewer.
    2              0.000008     function! catalog_viewer.close(restore_prev_window) dict
                                    if self.bufnum < 0 || !bufexists(self.bufnum)
                                        return
                                    endif
                                    call self.contract_screen()
                                    if a:restore_prev_window
                                        if !self.is_usable_viewport(winnr("#")) && self.first_usable_viewport() ==# -1
                                        else
                                            try
                                                if !self.is_usable_viewport(winnr("#"))
                                                    execute(self.first_usable_viewport() . "wincmd w")
                                                else
                                                    execute('wincmd p')
                                                endif
                                            catch //
                                            endtry
                                        endif
                                    endif
                                    execute("bwipe " . self.bufnum)
                                    let s:is_buffergator_buffers_open = 0
                                endfunction
                            
    2              0.000006     function! catalog_viewer.expand_screen() dict
                                    if has("gui_running") && g:buffergator_autoexpand_on_split
                                        if g:buffergator_viewport_split_policy =~ '[RL]' && g:buffergator_vsplit_size
                                            let self.pre_expand_columns = &columns
                                            let &columns += g:buffergator_vsplit_size
                                            let self.columns_expanded = &columns - self.pre_expand_columns
                                        else
                                            let self.columns_expanded = 0
                                        endif
                                        if g:buffergator_viewport_split_policy =~ '[TB]' && g:buffergator_hsplit_size
                                            let self.pre_expand_lines = &lines
                                            let &lines += g:buffergator_hsplit_size
                                            let self.lines_expanded = &lines - self.pre_expand_lines
                                        else
                                            let self.lines_expanded = 0
                                        endif
                                    endif
                                endfunction
                            
    2              0.000008     function! catalog_viewer.contract_screen() dict
                                    if self.columns_expanded && &columns - self.columns_expanded > 20
                                        let new_size  = &columns - self.columns_expanded
                                        if new_size < self.pre_expand_columns
                                            let new_size = self.pre_expand_columns
                                        endif
                                        let &columns = new_size
                                    endif
                                    if self.lines_expanded && &lines - self.lines_expanded > 20
                                        let new_size  = &lines - self.lines_expanded
                                        if new_size < self.pre_expand_lines
                                            let new_size = self.pre_expand_lines
                                        endif
                                        let &lines = new_size
                                    endif
                                endfunction
                            
    2              0.000006     function! catalog_viewer.highlight_current_line()
                                    if self.current_buffer_index
                                      execute ":" . self.current_buffer_index
                                      if self.current_buffer_index < line('w0')
                                        execute "silent! normal! zt"
                                      elseif self.current_buffer_index > line('w$')
                                        execute "silent! normal! zb"
                                      endif
                                    endif
                                endfunction
                            
                                " Clears the buffer contents.
    2              0.000006     function! catalog_viewer.clear_buffer() dict
                                    call cursor(1, 1)
                                    exec 'silent! normal! "_dG'
                                endfunction
                            
                                " from NERD_Tree, via VTreeExplorer: determine the number of windows open
                                " to this buffer number.
    2              0.000008     function! catalog_viewer.num_viewports_on_buffer(bnum) dict
                                    let cnt = 0
                                    let winnum = 1
                                    while 1
                                        let bufnum = winbufnr(winnum)
                                        if bufnum < 0
                                            break
                                        endif
                                        if bufnum ==# a:bnum
                                            let cnt = cnt + 1
                                        endif
                                        let winnum = winnum + 1
                                    endwhile
                                    return cnt
                                endfunction
                            
                                " from NERD_Tree: find the window number of the first normal window
    2              0.000007     function! catalog_viewer.first_usable_viewport() dict
                                    let i = 1
                                    while i <= winnr("$")
                                        let bnum = winbufnr(i)
                                        if bnum != -1 && getbufvar(bnum, '&buftype') ==# '' && !getwinvar(i, '&previewwindow') && (!getbufvar(bnum, '&modified') || &hidden)
                                            return i
                                        endif
                            
                                        let i += 1
                                    endwhile
                                    return -1
                                endfunction
                            
                                " from NERD_Tree: returns 0 if opening a file from the tree in the given
                                " window requires it to be split, 1 otherwise
    2              0.000008     function! catalog_viewer.is_usable_viewport(winnumber) dict
                                    "gotta split if theres only one window (i.e. the NERD tree)
                                    if winnr("$") ==# 1
                                        return 0
                                    endif
                                    let oldwinnr = winnr()
                                    execute(a:winnumber . "wincmd p")
                                    let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
                                    let modified = &modified
                                    execute(oldwinnr . "wincmd p")
                                    "if its a special window e.g. quickfix or another explorer plugin then we
                                    "have to split
                                    if specialWindow
                                        return 0
                                    endif
                                    if &hidden
                                        return 1
                                    endif
                                    return !modified || self.num_viewports_on_buffer(winbufnr(a:winnumber)) >= 2
                                endfunction
                            
                                " Acquires a viewport to show the source buffer. Returns the split command
                                " to use when switching to the buffer.
    2              0.000008     function! catalog_viewer.acquire_viewport(split_cmd)
                                    if self.split_mode == "buffer" && empty(a:split_cmd)
                                        " buffergator used original buffer's viewport,
                                        " so the the buffergator viewport is the viewport to use
                                        return ""
                                    endif
                                    if !self.is_usable_viewport(winnr("#")) && self.first_usable_viewport() ==# -1
                                        " no appropriate viewport is available: create new using default
                                        " split mode
                                        " TODO: maybe use g:buffergator_viewport_split_policy?
                                        if empty(a:split_cmd)
                                            return "sb"
                                        else
                                            return a:split_cmd
                                        endif
                                    else
                                        try
                                            if !self.is_usable_viewport(winnr("#"))
                                                execute(self.first_usable_viewport() . "wincmd w")
                                            else
                                                execute('wincmd p')
                                            endif
                                        catch /^Vim\%((\a\+)\)\=:E37/
                                            echo v:exception
                                        catch /^Vim\%((\a\+)\)\=:/
                                            echo v:exception
                                        endtry
                                        return a:split_cmd
                                    endif
                                endfunction
                            
                                " Finds next occurrence of specified pattern.
    2              0.000009     function! catalog_viewer.goto_pattern(pattern, direction) dict range
                                    if a:direction == "b" || a:direction == "p"
                                        let l:flags = "b"
                                        " call cursor(line(".")-1, 0)
                                    else
                                        let l:flags = ""
                                        " call cursor(line(".")+1, 0)
                                    endif
                                    if g:buffergator_move_wrap
                                        let l:flags .= "w"
                                    else
                                        let l:flags .= "W"
                                    endif
                                    let l:flags .= "e"
                                    let l:lnum = -1
                                    for i in range(v:count1)
                                        if search(a:pattern, l:flags) < 0
                                            break
                                        else
                                            let l:lnum = 1
                                        endif
                                    endfor
                                    if l:lnum < 0
                                        if l:flags[0] == "b"
                                            call s:_buffergator_messenger.send_info("No previous results")
                                        else
                                            call s:_buffergator_messenger.send_info("No more results")
                                        endif
                                        return 0
                                    else
                                        return 1
                                    endif
                                endfunction
                            
                                " Cycles sort regime.
    2              0.000007     function! catalog_viewer.cycle_sort_regime() dict
                                    let l:cur_regime = index(s:buffergator_catalog_sort_regimes, self.sort_regime)
                                    let l:cur_regime += 1
                                    if l:cur_regime < 0 || l:cur_regime >= len(s:buffergator_catalog_sort_regimes)
                                        let self.sort_regime = s:buffergator_catalog_sort_regimes[0]
                                    else
                                        let self.sort_regime = s:buffergator_catalog_sort_regimes[l:cur_regime]
                                    endif
                                    call self.open(1)
                                    let l:sort_desc = get(s:buffergator_catalog_sort_regime_desc, self.sort_regime, ["??", "in unspecified order"])[1]
                                    call s:_buffergator_messenger.send_info("sorted " . l:sort_desc)
                                endfunction
                            
                                " Cycles full/relative paths
    2              0.000008     function! catalog_viewer.cycle_directory_path_display() dict
                                    if self.display_regime != "basename"
                                        call s:_buffergator_messenger.send_info("cycling full/relative directory paths only makes sense when using the 'basename' display regime")
                                        return
                                    endif
                                    if g:buffergator_show_full_directory_path
                                        let g:buffergator_show_full_directory_path = 0
                                        call s:_buffergator_messenger.send_info("displaying relative directory path")
                                        call self.open(1)
                                    else
                                        let g:buffergator_show_full_directory_path = 1
                                        call s:_buffergator_messenger.send_info("displaying full directory path")
                                        call self.open(1)
                                    endif
                                endfunction
                            
                                " Cycles display regime.
    2              0.000008     function! catalog_viewer.cycle_display_regime() dict
                                    let l:cur_regime = index(s:buffergator_catalog_display_regimes, self.display_regime)
                                    let l:cur_regime += 1
                                    if l:cur_regime < 0 || l:cur_regime >= len(s:buffergator_catalog_display_regimes)
                                        let self.display_regime = s:buffergator_catalog_display_regimes[0]
                                    else
                                        let self.display_regime = s:buffergator_catalog_display_regimes[l:cur_regime]
                                    endif
                                    let b:did_syntax = 0
                                    call self.open(1)
                                    let l:display_desc = get(s:buffergator_catalog_display_regime_desc, self.display_regime, ["??", "in unspecified order"])[1]
                                    call s:_buffergator_messenger.send_info("displaying " . l:display_desc)
                                endfunction
                            
                                " Cycles window regime.
    2              0.000007     function! catalog_viewer.cycle_viewport_modes() dict
                                    let l:cur_mode = index(s:buffergator_viewport_split_modes_cycle_list, g:buffergator_viewport_split_policy)
                                    let l:cur_mode += 1
                                    if l:cur_mode < 0 || l:cur_mode >= len(s:buffergator_viewport_split_modes_cycle_list)
                                        let g:buffergator_viewport_split_policy = s:buffergator_viewport_split_modes_cycle_list[0]
                                    else
                                        let g:buffergator_viewport_split_policy = s:buffergator_viewport_split_modes_cycle_list[l:cur_mode]
                                    endif
                                    call buffergator#ReopenBuffergator()
                                endfunction
                            
                                " Cycles autodismiss modes
    2              0.000007     function! catalog_viewer.cycle_autodismiss_modes() dict
                                    if (g:buffergator_autodismiss_on_select)
                                        let g:buffergator_autodismiss_on_select = 0
                                    call s:_buffergator_messenger.send_info("will stay open on selection (autodismiss-on-select: OFF)")
                                    else
                                        let g:buffergator_autodismiss_on_select = 1
                                    call s:_buffergator_messenger.send_info("will close on selection (autodismiss-on-select: ON)")
                                    endif
                                endfunction
                            
                                " Rebuilds catalog.
    2              0.000008     function! catalog_viewer.rebuild_catalog() dict
                                    call self.open(1)
                                endfunction
                            
                                " Zooms/unzooms window.
    2              0.000006     function! catalog_viewer.toggle_zoom() dict
                                    let l:bfwn = bufwinnr(self.bufnum)
                                    if l:bfwn < 0
                                        return
                                    endif
                                    if self.is_zoomed
                                        " if s:_is_full_height_window(l:bfwn) && !s:_is_full_width_window(l:bfwn)
                                        if g:buffergator_viewport_split_policy =~ '[RrLl]'
                                            if !g:buffergator_vsplit_size
                                                let l:new_size = &columns / 3
                                            else
                                                let l:new_size = g:buffergator_vsplit_size
                                            endif
                                            if l:new_size > 0
                                                execute("vertical resize " . string(l:new_size))
                                            endif
                                            let self.is_zoomed = 0
                                        " elseif s:_is_full_width_window(l:bfwn) && !s:_is_full_height_window(l:bfwn)
                                        elseif g:buffergator_viewport_split_policy =~ '[TtBb]'
                                            if !g:buffergator_hsplit_size
                                                let l:new_size = &lines / 3
                                            else
                                                let l:new_size = g:buffergator_hsplit_size
                                            endif
                                            if l:new_size > 0
                                                execute("resize " . string(l:new_size))
                                            endif
                                            let self.is_zoomed = 0
                                        endif
                                    else
                                        " if s:_is_full_height_window(l:bfwn) && !s:_is_full_width_window(l:bfwn)
                                        if g:buffergator_viewport_split_policy =~ '[RrLl]'
                                            if &columns > 20
                                                execute("vertical resize " . string(&columns-10))
                                                let self.is_zoomed = 1
                                            endif
                                        " elseif s:_is_full_width_window(l:bfwn) && !s:_is_full_height_window(l:bfwn)
                                        elseif g:buffergator_viewport_split_policy =~ '[TtBb]'
                                            if &lines > 20
                                                execute("resize " . string(&lines-10))
                                                let self.is_zoomed = 1
                                            endif
                                        endif
                                    endif
                                endfunction
                            
                                " functions to be implemented by derived classes
    2              0.000008     function! catalog_viewer.update_buffers_info() dict
                                endfunction
                            
    2              0.000007     function! catalog_viewer.open(...) dict
                                endfunction
                            
    2              0.000007     function! catalog_viewer.setup_buffer_syntax() dict
                                endfunction
                            
    2              0.000006     function! catalog_viewer.setup_buffer_keymaps() dict
                                endfunction
                            
    2              0.000006     function! catalog_viewer.render_buffer() dict
                                endfunction
                            
    2              0.000006     function! catalog_viewer.setup_buffer_statusline() dict
                                endfunction
                            
    2              0.000008     function! catalog_viewer.append_line(text, jump_to_bufnum) dict
                                endfunction
                            
    2              0.000009     return catalog_viewer
                            

FUNCTION  <SNR>278_Reset()
Called 3 times
Total time:   0.009053
 Self time:   0.000315

count  total (s)   self (s)
    3              0.000036 	let opts = has_key(a:args, 'opts') ? [a:args['opts']] : []
    3   0.006721   0.000073 	cal call('s:opts', opts)
    3   0.000193   0.000055 	cal s:autocmds()
    3   0.001951   0.000064 	cal ctrlp#utils#opts()
    3   0.000138   0.000073 	cal s:execextvar('opts')

FUNCTION  airline#extensions#tabline#get()
Called 87 times
Total time:   0.605430
 Self time:   0.006698

count  total (s)   self (s)
   87              0.001035   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   87              0.000638   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   87              0.000491   let curtabcnt = tabpagenr('$')
   87              0.000314   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
   87              0.000746   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
   87              0.000189   if s:ctrlspace
   87   0.599775   0.001043     return airline#extensions#tabline#ctrlspace#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
                                return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  ctrlp#utils#fnesc()
Called 7671 times
Total time:   0.717185
 Self time:   0.717185

count  total (s)   self (s)
 7671              0.042864 	if exists('*fnameescape')
 7671              0.038874 		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
 7671              0.156878 			let path = fnameescape(a:path)
 7671              0.009578 		en
 7671              0.007512 	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
                            	en
 7671              0.063237 	retu a:0 ? escape(path, a:1) : path

FUNCTION  <SNR>110_update_untracked()
Called 961 times
Total time:   1.202486
 Self time:   0.965613

count  total (s)   self (s)
  961              0.600023   let file = expand("%:p")
  961              0.228505   if empty(file) || isdirectory(file)
                                return
                              endif
                            
  961              0.004054   let needs_update = 1
 2883              0.013502   for vcs in keys(s:vcs_config)
 1922              0.023327     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
 1922              0.013569     if has_key(s:vcs_config[vcs].untracked, file)
  951              0.002884       let needs_update = 0
  951   0.042729   0.014218       call airline#extensions#branch#update_untracked_config(file, vcs)
  951              0.001378     endif
 1922              0.003248   endfor
                            
  961              0.002160   if !needs_update
  951              0.001601     return
                              endif
                            
   30              0.000124   for vcs in keys(s:vcs_config)
   20              0.000093     let config = s:vcs_config[vcs]
   20              0.000057     if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
   20   0.208756   0.000394       call airline#async#vim_vcs_untracked(config, file)
   20              0.000035     else
                                  " nvim async or vim without job-feature
                                  call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
   20              0.000249   endfor

FUNCTION  ctrlspace#context#SetPluginBuffer()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000006 	let s:pluginBuffer = a:value
    1              0.000002 	return s:pluginBuffer

FUNCTION  <SNR>278_mixedsort()
Called 108 times
Total time:   0.156097
 Self time:   0.021024

count  total (s)   self (s)
  108   0.005539   0.000980 	let ct = s:curtype()
  108              0.000395 	if ct == 'buf'
                            		let pat = '[\/]\?\[\d\+\*No Name\]$'
                            		if a:1 =~# pat && a:2 =~# pat | retu 0
                            		elsei a:1 =~# pat | retu 1
                            		elsei a:2 =~# pat | retu -1 | en
                            	en
  108   0.023388   0.002629 	let [cln, cml] = [ctrlp#complen(a:1, a:2), s:compmatlen(a:1, a:2)]
  108              0.000249 	if s:ispath
  108              0.000269 		let ms = []
  108              0.000254 		if s:res_count < 21
  108   0.005662   0.001473 			let ms += [s:compfnlen(a:1, a:2)]
  108   0.071242   0.003283 			if ct !~ '^\(buf\|mru\)$' | let ms += [s:comptime(a:1, a:2)] | en
  108   0.037053   0.002301 			if !s:itemtype | let ms += [s:comparent(a:1, a:2)] | en
  108              0.000108 		en
  108              0.001261 		if ct =~ '^\(buf\|mru\)$'
                            			let ms += [s:compmref(a:1, a:2)]
                            			let cln = cml ? cln : 0
                            		en
  108              0.000638 		let ms += [cml, 0, 0, 0]
  108   0.004951   0.002096 		let mp = call('s:multipliers', ms[:3])
  108              0.001433 		retu cln + ms[0] * mp[0] + ms[1] * mp[1] + ms[2] * mp[2] + ms[3] * mp[3]
                            	en
                            	retu cln + cml * 2

FUNCTION  airline#util#getwinvar()
Called 561 times
Total time:   0.004675
 Self time:   0.004675

count  total (s)   self (s)
  561              0.004033     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  ctrlspace#api#Statusline()
Called 1 time
Total time:   0.000300
 Self time:   0.000132

count  total (s)   self (s)
    1              0.000077 	hi def link User1 CtrlSpaceStatus
                            
    1   0.000208   0.000040 	let statusline = "%1*" . s:config.Symbols.CS . "    " . ctrlspace#api#StatuslineModeSegment("    ")
                            
    1              0.000003 	if !&showtabline
                            		let statusline .= " %=%1* %<" . ctrlspace#api#StatuslineTabSegment()
                            	endif
                            
    1              0.000003 	return statusline

FUNCTION  airline#extensions#tabline#buffers#invalidate()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000011   let s:current_bufnr = -1

FUNCTION  gitgutter#highlight#define_sign_column_highlight()
Called 2 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    2              0.000008   if g:gitgutter_override_sign_column_highlight
    2              0.000063     highlight! link SignColumn LineNr
    2              0.000002   else
                                highlight default link SignColumn LineNr
                              endif

FUNCTION  gitgutter#hunk#hunks()
Called 4 times
Total time:   0.000337
 Self time:   0.000064

count  total (s)   self (s)
    4   0.000332   0.000059   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  syntastic#util#getbufvar()
Called 1950 times
Total time:   0.025143
 Self time:   0.025143

count  total (s)   self (s)
 1950              0.022407     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  ctrlp#syntax()
Called 3 times
Total time:   0.003805
 Self time:   0.002137

count  total (s)   self (s)
    3   0.000084   0.000040 	if ctrlp#nosy() | retu | en
  150   0.002421   0.000934 	for [ke, va] in items(s:hlgrps) | cal ctrlp#hicheck('CtrlP'.ke, va) | endfo
    3              0.000220 	let bgColor=synIDattr(synIDtrans(hlID('Normal')), 'bg')
    3              0.000072 	if bgColor !~ '^-1$\|^$'
                            		sil! exe 'hi CtrlPLinePre guifg='.bgColor.' ctermfg='.bgColor
                            	en
    3              0.000045 	sy match CtrlPNoEntries '^ == NO ENTRIES ==$'
    3              0.000066 	if hlexists('CtrlPLinePre')
                            		exe "sy match CtrlPLinePre '^".escape(get(g:, 'ctrlp_line_prefix', '>'),'^$.*~\')."'"
                            	en
                            
    3   0.000165   0.000028 	if s:curtype() == 'buf' && s:has_conceal
                            		sy region CtrlPBufferNr     matchgroup=CtrlPLinePre start='^>\s\+' end='\s'
                            		sy region CtrlPBufferInd    concealends matchgroup=Ignore start='<bi>' end='</bi>'
                            		sy region CtrlPBufferRegion concealends matchgroup=Ignore start='<bn>' end='</bn>' contains=CtrlPBufferHid,CtrlPBufferHidMod,CtrlPBufferVis,CtrlPBufferVisMod,CtrlPBufferCur,CtrlPBufferCurMod
                            		sy region CtrlPBufferHid    concealends matchgroup=Ignore     start='\s*{' end='}' contained
                            		sy region CtrlPBufferHidMod concealends matchgroup=Ignore    start='+\s*{' end='}' contained
                            		sy region CtrlPBufferVis    concealends matchgroup=Ignore   start='\*\s*{' end='}' contained
                            		sy region CtrlPBufferVisMod concealends matchgroup=Ignore  start='\*+\s*{' end='}' contained
                            		sy region CtrlPBufferCur    concealends matchgroup=Ignore  start='\*!\s*{' end='}' contained
                            		sy region CtrlPBufferCurMod concealends matchgroup=Ignore start='\*+!\s*{' end='}' contained
                            		sy region CtrlPBufferPath   concealends matchgroup=Ignore start='<bp>' end='</bp>'
                            	en

FUNCTION  airline#extensions#syntastic#get()
Called 1922 times
Total time:   0.534708
 Self time:   0.121883

count  total (s)   self (s)
 1922              0.015641   let _backup = get(g:, 'syntastic_stl_format', '')
 1922              0.009478   let is_err = (a:type  is# 'error')
 1922              0.003793   if is_err
  961              0.008529     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_err', '%E{[%e(#%fe)]}')
  961              0.001422   else
  961              0.008550     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_warn', '%W{[%w(#%fw)]}')
  961              0.001324   endif
 1922   0.431610   0.018785   let cnt = SyntasticStatuslineFlag()
 1922              0.008828   if !empty(_backup)
 1922              0.007687     let g:syntastic_stl_format = _backup
 1922              0.002615   endif
 1922              0.006832   if empty(cnt)
 1922              0.003462     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  <SNR>278_unmarksigns()
Called 7 times
Total time:   0.000185
 Self time:   0.000102

count  total (s)   self (s)
    7   0.000172   0.000089 	if !s:dosigns() | retu | en
                            	for key in keys(s:marked)
                            		exe 'sign unplace' key 'buffer='.s:bufnr
                            	endfo

FUNCTION  <SNR>124_hl_group_exists()
Called 7235 times
Total time:   0.276771
 Self time:   0.276771

count  total (s)   self (s)
 7235              0.094970   if !hlexists(a:group)
   28              0.000048     return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
  389              0.000667     return 0
                              endif
 6818              0.010119   return 1

FUNCTION  syntastic#util#isRunningWindows()
Called 3 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    3              0.000052     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>278_MapSpecs()
Called 3 times
Total time:   0.007640
 Self time:   0.007640

count  total (s)   self (s)
    3              0.000026 	if !( exists('s:smapped') && s:smapped == s:bufnr )
                            		" Correct arrow keys in terminal
    1              0.000016 		if ( has('termresponse') && v:termresponse =~ "\<ESC>" ) || &term =~? '\vxterm|<k?vt|gnome|screen|linux|ansi|tmux|st(-[-a-z0-9]*)?$'
    5              0.000018 			for each in ['\A <up>','\B <down>','\C <right>','\D <left>']
    4              0.000082 				exe s:lcmap.' <esc>['.each
    4              0.000004 			endfo
    1              0.000001 		en
    1              0.000001 	en
  369              0.001233 	for [ke, va] in items(s:prtmaps) | for kp in va
  159              0.004980 		exe s:lcmap kp ':<c-u>cal <SID>'.ke.'<cr>'
  264              0.000535 	endfo | endfo
    3              0.000011 	let s:smapped = s:bufnr

FUNCTION  airline#themes#patch()
Called 9 times
Total time:   0.034640
 Self time:   0.006715

count  total (s)   self (s)
  101              0.000363   for mode in keys(a:palette)
   92              0.000587     if !has_key(a:palette[mode], 'airline_warning')
   67              0.000595       let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
   67              0.000093     endif
   92              0.000526     if !has_key(a:palette[mode], 'airline_error')
   88              0.000677       let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
   88              0.000114     endif
   92              0.000523     if !has_key(a:palette[mode], 'airline_term')
                                  "let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
   91   0.029288   0.001363       let a:palette[mode]['airline_term'] = airline#highlighter#get_highlight('airline_c')
   91              0.000139     endif
   92              0.000156   endfor
                            
    9              0.000066   let a:palette.accents = get(a:palette, 'accents', {})
    9              0.000056   let a:palette.accents.none = [ '', '', '', '', '' ]
    9              0.000048   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    9              0.000058   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    9              0.000040   if !has_key(a:palette.accents, 'red')
    4              0.000021     let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
    4              0.000004   endif
    9              0.000040   if !has_key(a:palette.accents, 'green')
    9              0.000052     let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
    9              0.000013   endif
    9              0.000036   if !has_key(a:palette.accents, 'blue')
    9              0.000048     let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
    9              0.000012   endif
    9              0.000038   if !has_key(a:palette.accents, 'yellow')
    9              0.000048     let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
    9              0.000011   endif
    9              0.000034   if !has_key(a:palette.accents, 'orange')
    9              0.000047     let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
    9              0.000011   endif
    9              0.000037   if !has_key(a:palette.accents, 'purple')
    9              0.000048     let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
    9              0.000010   endif

FUNCTION  <SNR>278_lastvisual()
Called 3 times
Total time:   0.000755
 Self time:   0.000673

count  total (s)   self (s)
    3              0.000036 	let cview = winsaveview()
    3              0.000047 	let [ovreg, ovtype] = [getreg('v'), getregtype('v')]
    3              0.000043 	let [oureg, outype] = [getreg('"'), getregtype('"')]
    3              0.000079 	sil! norm! gV"vy
    3   0.000159   0.000077 	let selected = s:regisfilter('v')
    3              0.000037 	cal setreg('v', ovreg, ovtype)
    3              0.000029 	cal setreg('"', oureg, outype)
    3              0.000287 	cal winrestview(cview)
    3              0.000011 	retu selected

FUNCTION  AutoPairsInit()
Called 1 time
Total time:   0.001514
 Self time:   0.000968

count  total (s)   self (s)
    1              0.000005   let b:autopairs_loaded  = 1
    1              0.000005   if !exists('b:autopairs_enabled')
    1              0.000003     let b:autopairs_enabled = 1
    1              0.000002   end
    1              0.000004   let b:AutoPairsClosedPairs = {}
                            
    1              0.000004   if !exists('b:AutoPairs')
    1              0.000003     let b:AutoPairs = g:AutoPairs
    1              0.000002   end
                            
    1              0.000005   if !exists('b:AutoPairsMoveCharacter')
    1              0.000005     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    1              0.000001   end
                            
                              " buffer level map pairs keys
    7              0.000036   for [open, close] in items(b:AutoPairs)
    6   0.000468   0.000071     call AutoPairsMap(open)
    6              0.000022     if open != close
    3   0.000178   0.000029       call AutoPairsMap(close)
    3              0.000004     end
    6              0.000031     let b:AutoPairsClosedPairs[close] = open
    6              0.000008   endfor
                            
    9              0.000049   for key in split(b:AutoPairsMoveCharacter, '\s*')
    8              0.000095     let escaped_key = substitute(key, "'", "''", 'g')
    8              0.000231     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
    8              0.000020   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    1              0.000003   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    1              0.000022     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    1              0.000002   end
                            
    1              0.000003   if g:AutoPairsMapCh
    1              0.000021     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    1              0.000001   endif
                            
    1              0.000002   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    1              0.000002     let do_abbrev = ""
    1              0.000005     if v:version == 703 && has("patch489") || v:version > 703
    1              0.000003       let do_abbrev = "<C-]>"
    1              0.000001     endif
    1              0.000024     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    1              0.000002   end
                            
    1              0.000003   if g:AutoPairsShortcutFastWrap != ''
    1              0.000024     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    1              0.000001   end
                            
    1              0.000003   if g:AutoPairsShortcutBackInsert != ''
    1              0.000024     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    1              0.000001   end
                            
    1              0.000003   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    1              0.000022     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    1              0.000024     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    1              0.000001   end
                            
    1              0.000003   if g:AutoPairsShortcutJump != ''
    1              0.000024     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    1              0.000023     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    1              0.000001   end
                            

FUNCTION  <SNR>63_abs_path()
Called 676 times
Total time:   0.825197
 Self time:   0.825012

count  total (s)   self (s)
  676              0.815274   let p = resolve(expand('#'.a:bufnr.':p'))
  676   0.007757   0.007572   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>149_create_highlight()
Called 3 times
Total time:   0.004039
 Self time:   0.000343

count  total (s)   self (s)
    3              0.000024 		let color_idx = get( s:color_idx, a:color, -1 )
    3              0.000008 		if color_idx == -1
    3   0.003755   0.000059 			let color_idx = s:rgb2xterm(a:color)
    3              0.000016 			let s:color_idx[a:color] = color_idx
    3              0.000003 		endif
    3              0.000219 		exe 'hi BG'.a:color 'ctermbg='.color_idx 'ctermfg='.( a:is_bright ? 0 : 15 )                    'guibg=#'.a:color    'guifg=#'.( a:is_bright ? '000000' : 'ffffff' )

FUNCTION  <SNR>80_extinction()
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000017   if get(g:, 'startify_session_persistence') && exists('v:this_session') && filewritable(v:this_session)
                                call startify#session_write(fnameescape(v:this_session))
                              endif

FUNCTION  airline#extensions#syntastic#get_error()
Called 961 times
Total time:   0.269511
 Self time:   0.011027

count  total (s)   self (s)
  961   0.268397   0.009913   return airline#extensions#syntastic#get('error')

FUNCTION  <SNR>278_settype()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000020 	retu a:type < 0 ? exists('s:itemtype') ? s:itemtype : 0 : a:type

FUNCTION  <SNR>277_strpart()
Called 1 time
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
    1              0.000005   if a:l == 0
                                return ''
                              endif
    1              0.000008   let [s, l] = ['', 0]
    2              0.000082   for c in split(a:s[a:i :], '\zs')
    2              0.000013     let s .= c
    2              0.000015     let l += len(c)
    2              0.000015     if l >= a:l
    1              0.000003       break
                                endif
    1              0.000011   endfor
    1              0.000003   return s

FUNCTION  <SNR>277_get_visual_region()
Called 1 time
Total time:   0.000120
 Self time:   0.000062

count  total (s)   self (s)
    1   0.000052   0.000021   let left = s:pos("'<")
    1   0.000042   0.000015   let right = s:pos("'>")
    1              0.000005   if a:pos == left
                                let region = [right, left]
                              else
    1              0.000005     let region = [left, right]
    1              0.000001   endif
    1              0.000003   return region

FUNCTION  gitgutter#sign#remove_dummy_sign()
Called 3 times
Total time:   0.000178
 Self time:   0.000092

count  total (s)   self (s)
    3   0.000134   0.000048   if gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
                                execute "sign unplace" s:dummy_sign_id "buffer=" . a:bufnr
                                call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 0)
                              endif

FUNCTION  fugitive#extract_git_dir()
Called 1 time
Total time:   0.004610
 Self time:   0.002464

count  total (s)   self (s)
    1   0.000080   0.000031   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
    1              0.000226   if isdirectory(a:path)
                                let path = fnamemodify(a:path, ':p:s?[\/]$??')
                              else
    1              0.000263     let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
    1              0.000002   endif
    1   0.000326   0.000292   let root = s:shellslash(resolve(path))
    1              0.000003   let previous = ""
    5              0.000017   while root !=# previous
    4              0.000046     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
    4              0.000052     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
    4              0.000027     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
    4   0.001048   0.000060     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
    4   0.000147   0.000058     let dir = s:sub(root, '[\/]$', '') . '/.git'
    4              0.000832     let type = getftype(dir)
    4              0.000027     if type ==# 'dir' && fugitive#is_git_dir(dir)
                                  return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
    4              0.000014     let previous = root
    4              0.000024     let root = fnamemodify(root, ':h')
    4              0.000008   endwhile
    1              0.000002   return ''

FUNCTION  <SNR>8_LoadIndent()
Called 2 times
Total time:   0.036383
 Self time:   0.035547

count  total (s)   self (s)
    2              0.000016     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    2              0.000016     let s = expand("<amatch>")
    2              0.000008     if s != ""
    2              0.000012       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000041       for name in split(s, '\.')
    2   0.036217   0.035381 	exe 'runtime! indent/' . name . '.vim'
    2              0.000009       endfor
    2              0.000003     endif

FUNCTION  airline#highlighter#load_theme()
Called 9 times
Total time:   0.423148
 Self time:   0.000775

count  total (s)   self (s)
    9              0.000038   if pumvisible()
                                return
                              endif
    9              0.000137   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
                              endfor
    9   0.001643   0.000127   call airline#highlighter#highlight(['inactive'])
    9              0.000117   if getbufvar( bufnr('%'), '&modified'  )
    1   0.083603   0.000022     call airline#highlighter#highlight(['normal', 'modified'])
    1              0.000001   else
    8   0.337419   0.000143     call airline#highlighter#highlight(['normal'])
    8              0.000010   endif

FUNCTION  <SNR>65_buffer_getvar()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000008   return getbufvar(self['#'],a:var)

FUNCTION  <SNR>278_getenv()
Called 3 times
Total time:   0.003660
 Self time:   0.002882

count  total (s)   self (s)
    3              0.000083 	let [s:cwd, s:winres] = [getcwd(), [winrestcmd(), &lines, winnr('$')]]
    3              0.000106 	let [s:crword, s:crnbword] = [expand('<cword>', 1), expand('<cWORD>', 1)]
    3              0.000071 	let [s:crgfile, s:crline] = [expand('<cfile>', 1), getline('.')]
    3              0.000058 	let [s:winmaxh, s:crcursor] = [min([s:mw_max, &lines]), getpos('.')]
    3   0.000867   0.000112 	let [s:crbufnr, s:crvisual] = [bufnr('%'), s:lastvisual()]
    3              0.001316 	let s:crfile = bufname('%') == '' ? '['.s:crbufnr.'*No Name]' : expand('%:p', 1)
    3              0.001037 	let s:crfpath = expand('%:p:h', 1)
    3   0.000104   0.000081 	let s:mrbs = ctrlp#mrufiles#bufs()

FUNCTION  syntastic#util#var()
Called 191 times
Total time:   0.006026
 Self time:   0.003567

count  total (s)   self (s)
  191   0.005822   0.003363     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  <SNR>65_repo_head_ref()
Called 448 times
Total time:   0.444700
 Self time:   0.428820

count  total (s)   self (s)
  448   0.257406   0.250267   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
  448   0.183274   0.174533   return readfile(self.dir('HEAD'))[0]

FUNCTION  syntastic#util#compareLexi()
Called 25 times
Total time:   0.001224
 Self time:   0.001224

count  total (s)   self (s)
   27              0.000392     for idx in range(max([len(a:a), len(a:b)]))
   27              0.000275         let a_element = str2nr(get(a:a, idx, 0))
   27              0.000226         let b_element = str2nr(get(a:b, idx, 0))
   27              0.000091         if a_element != b_element
   25              0.000091             return a_element > b_element ? 1 : -1
                                    endif
    2              0.000003     endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  ctrlspace#window#Toggle()
Called 1 time
Total time:   0.138998
 Self time:   0.006493

count  total (s)   self (s)
    1              0.000007 	if !a:internal
    1   0.017344   0.000041 		call s:resetWindow()
    1              0.000001 	endif
                            
                            	" if we get called and the list is open --> close it
    1   0.000052   0.000044 	let pbuf = ctrlspace#context#PluginBuffer()
                            
    1              0.000009 	if bufexists(pbuf)
                            		if bufwinnr(pbuf) != -1
                            			call ctrlspace#window#Kill(pbuf, 1)
                            			return
                            		else
                            			call ctrlspace#window#Kill(pbuf, 0)
                            			if !a:internal
                            				let t:CtrlSpaceStartWindow = winnr()
                            				let t:CtrlSpaceWinrestcmd  = winrestcmd()
                            				let t:CtrlSpaceActivebuf   = bufnr("")
                            			endif
                            		endif
                            	elseif !a:internal
                            		" make sure zoom window is closed
    1              0.000008 		silent! exe "pclose"
    1              0.000008 		let t:CtrlSpaceStartWindow = winnr()
    1              0.000011 		let t:CtrlSpaceWinrestcmd  = winrestcmd()
    1              0.000008 		let t:CtrlSpaceActivebuf   = bufnr("")
    1              0.000001 	endif
                            
    1              0.000004 	if s:modes.Zoom.Enabled
                            		let t:CtrlSpaceActivebuf = bufnr("")
                            	endif
                            
                            	" create the buffer first & set it up
    1              0.005602 	silent! exe "noautocmd botright pedit CtrlSpace"
    1              0.000291 	silent! exe "noautocmd wincmd P"
    1              0.000038 	silent! exe "resize" s:config.Height
                            
                            	" zoom start window in Zoom Mode
    1              0.000006 	if s:modes.Zoom.Enabled
                            		silent! exe t:CtrlSpaceStartWindow . "wincmd w"
                            		vert resize | resize
                            		silent! exe "noautocmd wincmd P"
                            	endif
                            
    1   0.107585   0.000050 	call s:setUpBuffer()
                            
    1              0.000003 	if s:modes.Help.Enabled
                            		call ctrlspace#help#DisplayHelp(s:filler())
                            		call ctrlspace#util#SetStatusline()
                            		return
                            	endif
                            
    1   0.005260   0.000038 	let [b:patterns, b:indices, b:size, b:text] = ctrlspace#engine#Content()
                            
                            	" set up window height
    1              0.000004 	if b:size > s:config.Height
    1   0.000044   0.000027 		let maxHeight = ctrlspace#window#MaxHeight()
                            
    1              0.000002 		if b:size < maxHeight
    1              0.000025 			silent! exe "resize " . b:size
    1              0.000001 		else
                            			silent! exe "resize " . maxHeight
                            		endif
    1              0.000001 	endif
                            
    1   0.000020   0.000016 	silent! exe "set updatetime=" . s:config.SearchTiming
                            
    1   0.001582   0.000028 	call s:displayContent()
    1   0.000398   0.000036 	call ctrlspace#util#SetStatusline()
                            
                            	" display search patterns
    1              0.000003 	for pattern in b:patterns
                            		" escape ~ sign because of E874: (NFA) Could not pop the stack !
                            		call matchadd("CtrlSpaceSearch", "\\c" .substitute(pattern, '\~', '\\~', "g"))
                            	endfor
                            
    1   0.000527   0.000027 	call s:setActiveLine()
                            
    1              0.000012 	normal! zb

FUNCTION  ctrlp#hicheck()
Called 51 times
Total time:   0.001487
 Self time:   0.001487

count  total (s)   self (s)
   51              0.000654 	if !hlexists(a:grp)
   17              0.000601 		exe 'hi link' a:grp a:defgrp
   17              0.000018 	en

FUNCTION  ctrlp#utils#mkdir()
Called 4 times
Total time:   0.001530
 Self time:   0.001530

count  total (s)   self (s)
    4              0.000609 	if exists('*mkdir') && !isdirectory(a:dir)
    1              0.000871 		sil! cal mkdir(a:dir, 'p')
    1              0.000003 	en
    4              0.000012 	retu a:dir

FUNCTION  <SNR>257_NewMessenger()
Called 1 time
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
                            
                                " allocate a new pseudo-object
    1              0.000007     let messenger = {}
    1              0.000009     let messenger["name"] = a:name
    1              0.000007     if empty(a:name)
    1              0.000007         let messenger["title"] = "buffergator"
    1              0.000002     else
                                    let messenger["title"] = "buffergator (" . messenger["name"] . ")"
                                endif
                            
    1              0.000005     function! messenger.format_message(leader, msg) dict
                                    return self.title . ": " . a:leader.a:msg
                                endfunction
                            
    1              0.000005     function! messenger.format_exception( msg) dict
                                    return a:msg
                                endfunction
                            
    1              0.000004     function! messenger.send_error(msg) dict
                                    redraw
                                    echohl ErrorMsg
                                    echomsg self.format_message("[ERROR] ", a:msg)
                                    echohl None
                                endfunction
                            
    1              0.000004     function! messenger.send_warning(msg) dict
                                    redraw
                                    echohl WarningMsg
                                    echomsg self.format_message("[WARNING] ", a:msg)
                                    echohl None
                                endfunction
                            
    1              0.000003     function! messenger.send_status(msg) dict
                                    redraw
                                    echohl None
                                    echomsg self.format_message("", a:msg)
                                endfunction
                            
    1              0.000003     function! messenger.send_info(msg) dict
                                    redraw
                                    echohl None
                                    echo self.format_message("", a:msg)
                                endfunction
                            
    1              0.000004     return messenger
                            

FUNCTION  <SNR>277_revert_highlight_fix()
Called 4 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    4              0.000026   if type(s:saved_line) == 1
                                if s:from_mode ==# 'i'
                                  silent! undojoin | call setline('.', s:saved_line)
                                else
                                  call setline('.', s:saved_line)
                                endif
                              endif
    4              0.000013   let s:saved_line = 0

FUNCTION  syntastic#log#debugShowVariables()
Called 6 times
Total time:   0.000113
 Self time:   0.000074

count  total (s)   self (s)
    6   0.000093   0.000054     if !s:_isDebugEnabled(a:level)
    6              0.000008         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  ctrlspace#modes#Modes()
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000013 	return s:collection

FUNCTION  <SNR>278_sanstail()
Called 4 times
Total time:   0.000326
 Self time:   0.000326

count  total (s)   self (s)
    4              0.000101 	let str = s:spi ? substitute(a:str, '^\(@.*$\|\\\\\ze@\|\.\.\zs[.\/]\+$\)', '', 'g') : a:str
    4              0.000062 	let [str, pat] = [substitute(str, '\\\\', '\', 'g'), '\([^:]\|\\:\)*$']
    4              0.000012 	unl! s:optail
    4              0.000058 	if str =~ '\\\@<!:'.pat
                            		let s:optail = matchstr(str, '\\\@<!:\zs'.pat)
                            		let str = substitute(str, '\\\@<!:'.pat, '', '')
                            	en
    4              0.000037 	retu substitute(str, '\\\ze:', '', 'g')

FUNCTION  gitgutter#utility#extension()
Called 64 times
Total time:   0.058412
 Self time:   0.001373

count  total (s)   self (s)
   64   0.058296   0.001257   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>63_is_file_buffer()
Called 231 times
Total time:   0.004818
 Self time:   0.004818

count  total (s)   self (s)
  231              0.004209   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>274_displayContent()
Called 1 time
Total time:   0.001554
 Self time:   0.000248

count  total (s)   self (s)
    1   0.000017   0.000010 	setlocal modifiable
                            
    1              0.000003 	if b:size > 0
    1              0.000073 		silent! put! =b:text
    1              0.000052 		normal! GkJ
    1   0.001320   0.000031 		call s:fillBufferSpace()
    1   0.000014   0.000010 		call s:modes.Nop.Disable()
    1              0.000002 	else
                            		let emptyListMessage = "  List empty"
                            
                            		let sizes = ctrlspace#context#SymbolSizes()
                            
                            		if &columns < (strwidth(emptyListMessage) + 2)
                            			let emptyListMessage = strpart(emptyListMessage, 0, &columns - 2 - sizes.Dots) . s:config.Symbols.Dots
                            		endif
                            
                            		while strwidth(emptyListMessage) < &columns
                            			let emptyListMessage .= ' '
                            		endwhile
                            
                            		silent! put! =emptyListMessage
                            		normal! GkJ
                            
                            		call s:fillBufferSpace()
                            
                            		normal! 0
                            
                            		call s:modes.Nop.Enable()
                            	endif
                            
    1   0.000014   0.000008 	setlocal nomodifiable

FUNCTION  <SNR>274_goto()
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000003 	if b:size < 1
                            		return
                            	endif
                            
    1              0.000002 	if a:line < 1
                            		call s:goto(b:size - a:line)
                            	elseif a:line > b:size
                            		call s:goto(a:line - b:size)
                            	else
    1              0.000005 		call cursor(a:line, 1)
    1              0.000002 	endif

FUNCTION  288()
Called 1 time
Total time:   0.000067
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000020   0.000013     let leader = self.getCName() . ': '
    1              0.000002     if a:0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
                                else
    1   0.000034   0.000012         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
    1              0.000001     endif

FUNCTION  <SNR>110_update_git_branch()
Called 961 times
Total time:   0.619056
 Self time:   0.042027

count  total (s)   self (s)
  961   0.016502   0.008460   if !s:has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
  961   0.581450   0.012463   let s:vcs_config['git'].branch = fugitive#head(s:sha1size)
  961              0.007041   if s:vcs_config['git'].branch is# 'master' && winwidth(0) < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  ctrlp#utils#cachefile()
Called 4 times
Total time:   0.000440
 Self time:   0.000318

count  total (s)   self (s)
    4              0.000046 	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
    4              0.000183 	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
    4   0.000197   0.000075 	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file

FUNCTION  375()
Called 537 times
Total time:   0.004674
 Self time:   0.004674

count  total (s)   self (s)
  537              0.004084   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>128_section_is_empty()
Called 596 times
Total time:   0.014957
 Self time:   0.014957

count  total (s)   self (s)
  596              0.001892   let start=1
                            
                              " do not check for inactive windows or the tabline
  596              0.001782   if a:self._context.active == 0
   25              0.000045     return 0
                              elseif get(a:self._context, 'tabline', 0)
  206              0.000338     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
  365              0.002016   if get(g:, 'airline_skip_empty_sections', 0) == 0
  365              0.000632     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>278_nocache()
Called 3 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    3              0.000013 	if !s:caching
                            		retu 1
                            	elsei s:caching > 1
                            		if !( exists(s:ccex) && !{s:ccex} ) || has_key(s:ficounts, s:dyncwd)
                            			retu get(s:ficounts, s:dyncwd, [0, 0])[0] < s:caching
                            		elsei a:0 && filereadable(a:1)
                            			retu len(ctrlp#utils#readfile(a:1)) < s:caching
                            		en
                            		retu 1
                            	en
    3              0.000005 	retu 0

FUNCTION  <SNR>278_usrign()
Called 27903 times
Total time:   7.016750
 Self time:   7.016750

count  total (s)   self (s)
27903              0.176353 	if s:igntype == 1 | retu a:item =~ s:usrign | en
27903              0.055295 	if s:igntype == 2
                            		if call(s:usrign, [a:item, a:type])
                            			retu 1
                            		en
                            	elsei s:igntype == 4
27903              5.957631 		if has_key(s:usrign, a:type) && s:usrign[a:type] != '' && a:item =~ s:usrign[a:type]
  716              0.001901 			retu 1
                            		elsei has_key(s:usrign, 'func') && s:usrign['func'] != '' && call(s:usrign['func'], [a:item, a:type])
                            			retu 1
                            		en
27187              0.030849 	en
27187              0.042220 	retu 0

FUNCTION  ctrlspace#api#TabModified()
Called 87 times
Total time:   0.012239
 Self time:   0.006386

count  total (s)   self (s)
  272   0.008608   0.002755 	for b in map(keys(ctrlspace#buffers#Buffers(a:tabnr)), "str2nr(v:val)")
  235              0.001662 		if getbufvar(b, '&modified')
   50              0.000099 			return 1
                            		endif
  185              0.000319 	endfor
   37              0.000072 	return 0

FUNCTION  airline#parts#ffenc()
Called 965 times
Total time:   0.051748
 Self time:   0.051748

count  total (s)   self (s)
  965              0.009038   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  965              0.003832   let bomb     = &l:bomb ? '[BOM]' : ''
  965              0.016396   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  965              0.008939   if expected is# &fenc.bomb.ff
                                return ''
                              else
  965              0.006914     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>133_has_fresh_changes()
Called 205 times
Total time:   0.011121
 Self time:   0.004517

count  total (s)   self (s)
  205   0.010762   0.004158   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  gitgutter#utility#shellescape()
Called 440 times
Total time:   0.029722
 Self time:   0.026756

count  total (s)   self (s)
  440              0.019065   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
  312              0.001489     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
  128              0.001043     return shellescape(a:arg)
                              endif

FUNCTION  GitGutterGetHunkSummary()
Called 448 times
Total time:   0.025380
 Self time:   0.005530

count  total (s)   self (s)
  448   0.024849   0.004999   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#util#ignore_buf()
Called 966 times
Total time:   0.080571
 Self time:   0.080571

count  total (s)   self (s)
  966              0.017871   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify')
  966              0.060413   return match(a:name, pat) > -1

FUNCTION  gitgutter#sign#clear_signs()
Called 3 times
Total time:   0.002018
 Self time:   0.000233

count  total (s)   self (s)
    3   0.001202   0.000048   call s:find_current_signs(a:bufnr)
                            
    3   0.000160   0.000070   let sign_ids = map(values(gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')), 'v:val.id')
    3   0.000464   0.000050   call s:remove_signs(a:bufnr, sign_ids, 1)
    3   0.000176   0.000049   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', {})

FUNCTION  ctrlp#utils#opts()
Called 3 times
Total time:   0.001887
 Self time:   0.001594

count  total (s)   self (s)
    3   0.000079   0.000039 	let s:lash = ctrlp#utils#lash()
    3   0.000202   0.000077 	let usrhome = $HOME . s:lash( $HOME )
    3              0.000051 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
    3   0.001417   0.001289 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
    3              0.000027 	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
    3              0.000018 	let s:cache_dir = cadir

FUNCTION  ctrlp#utils#lash()
Called 6 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    6              0.000077 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  AutoPairsMap()
Called 9 times
Total time:   0.000546
 Self time:   0.000546

count  total (s)   self (s)
                              " | is special key which separate map command from text
    9              0.000029   let key = a:key
    9              0.000023   if key == '|'
                                let key = '<BAR>'
                              end
    9              0.000089   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
    9              0.000333   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
                            

FUNCTION  ctrlp#setdir()
Called 3 times
Total time:   0.002044
 Self time:   0.001667

count  total (s)   self (s)
    3              0.000019 	let cmd = a:0 ? a:1 : 'lc!'
    3   0.001930   0.001553 	sil! exe cmd s:fnesc(a:path, 'c')
    3              0.000082 	let [s:crfilerel, s:dyncwd] = [fnamemodify(s:crfile, ':.'), getcwd()]

FUNCTION  <SNR>63_winshell()
Called 128 times
Total time:   0.002966
 Self time:   0.002966

count  total (s)   self (s)
  128              0.002703   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  ctrlspace#context#Configuration()
Called 3 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    3              0.000022 	return s:conf

FUNCTION  <SNR>277_exit()
Called 4 times
Total time:   0.001753
 Self time:   0.000191

count  total (s)   self (s)
    4              0.000028   if s:char !=# g:multi_cursor_quit_key
    2              0.000006     return 0
                              endif
    2              0.000008   let exit = 0
    2              0.000009   if s:from_mode ==# 'n'
                                let exit = 1
                              elseif (s:from_mode ==# 'v' || s:from_mode ==# 'V') && g:multi_cursor_exit_from_visual_mode
    2              0.000006     let exit = 1
    2              0.000009   elseif s:from_mode ==# 'i' && g:multi_cursor_exit_from_insert_mode
                                stopinsert
                                let exit = 1
                              endif
    2              0.000017   if exit
    2   0.001595   0.000033     call s:cm.reset(1, 1, 1)
    2              0.000006     return 1
                              endif
                              return 0

FUNCTION  <SNR>55_on_colorscheme_changed()
Called 2 times
Total time:   0.225137
 Self time:   0.000146

count  total (s)   self (s)
    2   0.000037   0.000020   call s:init()
    2              0.000005   unlet! g:airline#highlighter#normal_fg_hi
    2   0.000829   0.000039   call airline#highlighter#reset_hlcache()
    2   0.000073   0.000036   let g:airline_gui_mode = airline#init#gui_mode()
    2              0.000006   if !s:theme_in_vimrc
                                call airline#switch_matching_theme()
                              endif
                            
                              " couldn't find a match, or theme was defined, just refresh
    2   0.224166   0.000019   call airline#load_theme()

FUNCTION  <SNR>277_highlight_region()
Called 3 times
Total time:   0.000690
 Self time:   0.000588

count  total (s)   self (s)
    3   0.000229   0.000127   let s = sort(copy(a:region), "s:compare_pos")
    3              0.000016   if s:to_mode ==# 'V'
                                let pattern = '\%>'.(s[0][0]-1).'l\%<'.(s[1][0]+1).'l.*\ze.\_$'
                              else
    3              0.000023     if (s[0][0] == s[1][0])
                                  " Same line
    3              0.000075       let pattern = '\%'.s[0][0].'l\%>'.(s[0][1]-1).'c.*\%<'.(s[1][1]+1).'c.'
    3              0.000007     else
                                  " Two lines
                                  let s1 = '\%'.s[0][0].'l.\%>'.s[0][1].'c.*'
                                  let s2 = '\%'.s[1][0].'l.*\%<'.s[1][1].'c..'
                                  let pattern = s1.'\|'.s2
                                  " More than two lines
                                  if (s[1][0] - s[0][0] > 1)
                                    let pattern = pattern.'\|\%>'.s[0][0].'l\%<'.s[1][0].'l.*\ze.\_$'
                                  endif
                                endif
    3              0.000006   endif
    3              0.000203   return matchadd(s:hi_group_visual, pattern)

FUNCTION  <SNR>278_match_window_opts()
Called 3 times
Total time:   0.000508
 Self time:   0.000508

count  total (s)   self (s)
    3              0.000105 	let s:mw_pos = s:mw =~ 'top\|bottom' ? matchstr(s:mw, 'top\|bottom') : exists('g:ctrlp_match_window_bottom') ? ( s:mwbottom ? 'bottom' : 'top' ) : 'bottom'
    3              0.000094 	let s:mw_order = s:mw =~ 'order:[^,]\+' ? matchstr(s:mw, 'order:\zs[^,]\+') : exists('g:ctrlp_match_window_reversed') ? ( s:mwreverse ? 'btt' : 'ttb' ) : 'btt'
    3              0.000073 	let s:mw_max = s:mw =~ 'max:[^,]\+' ? str2nr(matchstr(s:mw, 'max:\zs\d\+')) : exists('g:ctrlp_max_height') ? s:mxheight : 10
    3              0.000050 	let s:mw_min = s:mw =~ 'min:[^,]\+' ? str2nr(matchstr(s:mw, 'min:\zs\d\+')) : 1
    3              0.000062 	let [s:mw_max, s:mw_min] = [max([s:mw_max, 1]), max([s:mw_min, 1])]
    3              0.000027 	let s:mw_min = min([s:mw_min, s:mw_max])
    3              0.000075 	let s:mw_res = s:mw =~ 'results:[^,]\+' ? str2nr(matchstr(s:mw, 'results:\zs\d\+')) : min([s:mw_max, &lines])

FUNCTION  airline#builder#get_prev_group()
Called 596 times
Total time:   0.015299
 Self time:   0.015299

count  total (s)   self (s)
  596              0.002684   let x = a:i - 1
  665              0.001780   while x >= 0
  596              0.003237     let group = a:sections[x][0]
  596              0.002620     if group != '' && group != '|'
  527              0.001153       return group
                                endif
   69              0.000209     let x = x - 1
   69              0.000111   endwhile
   69              0.000112   return ''

FUNCTION  <SNR>65_buffer()
Called 1 time
Total time:   0.000513
 Self time:   0.000488

count  total (s)   self (s)
    1              0.000012   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    1              0.000030   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
    1   0.000043   0.000033   if buffer.getvar('git_dir') !=# ''
                                return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  <SNR>278_opts()
Called 3 times
Total time:   0.006648
 Self time:   0.006095

count  total (s)   self (s)
    3              0.000023 	unl! s:usrign s:usrcmd s:urprtmaps
   18              0.000142 	for each in ['byfname', 'regexp', 'extensions'] | if exists('s:'.each)
    6              0.000059 		let {each} = s:{each}
   13              0.000035 	en | endfo
  141              0.000943 	for [ke, va] in items(s:opts)
  138              0.002472 		let {va[0]} = exists(s:pref.ke) ? {s:pref.ke} : va[1]
  138              0.000384 	endfo
    3              0.000009 	unl va
   18              0.000132 	for [ke, va] in items(s:new_opts)
   15              0.000328 		let {va} = {exists(s:pref.ke) ? s:pref.ke : va}
   15              0.000044 	endfo
    3              0.000009 	unl va
   12              0.000095 	for [ke, va] in items(s:lc_opts)
    9              0.000082 		if exists(s:bpref.ke)
                            			unl {va}
                            			let {va} = {s:bpref.ke}
                            		en
    9              0.000030 	endfo
                            	" Match window options
    3   0.000591   0.000083 	cal s:match_window_opts()
                            	" One-time values
    3              0.000014 	if a:0 && a:1 != {}
                            		unl va
                            		for [ke, va] in items(a:1)
                            			let opke = substitute(ke, '\(\w:\)\?ctrlp_', '', '')
                            			if has_key(s:lc_opts, opke)
                            				let sva = s:lc_opts[opke]
                            				unl {sva}
                            				let {sva} = va
                            			en
                            		endfo
                            	en
   12              0.000079 	for each in ['byfname', 'regexp'] | if exists(each)
    4              0.000048 		let s:{each} = {each}
    8              0.000023 	en | endfo
    3              0.000038 	if !exists('g:ctrlp_tilde_homedir') | let g:ctrlp_tilde_homedir = 0 | en
    3              0.000033 	if !exists('g:ctrlp_newcache') | let g:ctrlp_newcache = 0 | en
    3              0.000035 	let s:maxdepth = min([s:maxdepth, 100])
    3              0.000016 	let s:glob = s:showhidden ? '.*\|*' : '*'
    3              0.000034 	let s:igntype = empty(s:usrign) ? -1 : type(s:usrign)
    3   0.000112   0.000067 	let s:lash = ctrlp#utils#lash()
    3              0.000010 	if s:keyloop
                            		let [s:lazy, s:glbs['imd']] = [0, 0]
                            	en
    3              0.000008 	if s:lazy
                            		cal extend(s:glbs, { 'ut': ( s:lazy > 1 ? s:lazy : 250 ) })
                            	en
                            	" Extensions
    3              0.000026 	if !( exists('extensions') && extensions == s:extensions )
    1              0.000004 		for each in s:extensions
                            			exe 'ru autoload/ctrlp/'.each.'.vim'
                            		endfo
    1              0.000001 	en
                            	" Keymaps
    3              0.000018 	if type(s:urprtmaps) == 4
                            		cal extend(s:prtmaps, s:urprtmaps)
                            	en

FUNCTION  airline#parts#paste()
Called 961 times
Total time:   0.006438
 Self time:   0.006438

count  total (s)   self (s)
  961              0.005201   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#extensions#load_theme()
Called 9 times
Total time:   0.117497
 Self time:   0.000160

count  total (s)   self (s)
    9   0.117485   0.000148   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  airline#update_statusline()
Called 40 times
Total time:   1.086847
 Self time:   0.006451

count  total (s)   self (s)
   40   0.000867   0.000515   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   45              0.000686   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
    5   0.000100   0.000050     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
    5              0.000037     call setwinvar(nr, 'airline_active', 0)
    5              0.000054     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    5   0.065042   0.000128     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    5              0.000009   endfor
                            
   40              0.000195   unlet! w:airline_render_left w:airline_render_right
   40              0.001232   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
   40              0.000129   let w:airline_active = 1
   40              0.000495   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   40   1.016384   0.001304   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>134_find_current_signs()
Called 7 times
Total time:   0.002312
 Self time:   0.001513

count  total (s)   self (s)
    7              0.000050   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    7              0.000029   let other_signs = []      " [<line_number (number),...]
    7              0.000024   let dummy_sign_placed = 0
                            
    7              0.000047   redir => signs
    7              0.000209     silent execute "sign place buffer=" . a:bufnr
    7              0.000043   redir END
                            
    7              0.000201   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
                              endfor
                            
    7   0.000410   0.000118   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
    7   0.000365   0.000105   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
    7   0.000338   0.000091   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  ctrlp#utils#cachedir()
Called 4 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    4              0.000020 	retu s:cache_dir

FUNCTION  <SNR>277_detect_bad_input()
Called 1 time
Total time:   0.000229
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000006   if !s:valid_input
                                " To invoke the appropriate `<Plug>(multiple-cursors-apply)` mapping, we
                                " need to revert back to the mode the user was in when the input was entered
    1   0.000194   0.000017     call s:revert_mode(s:to_mode, s:from_mode)
                                " We ignore the bad input and force invoke s:apply_user_input_next
    1              0.000013     call feedkeys("\<Plug>(multiple-cursors-apply)")
    1              0.000005     let s:bad_input += 1
    1              0.000002   endif

FUNCTION  SyntasticLoclistHide()
Called 3 times
Total time:   0.000094
 Self time:   0.000043

count  total (s)   self (s)
    3   0.000081   0.000030     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
    3              0.000007     silent! lclose

FUNCTION  <SNR>278_GlobPath()
Called 8 times
Total time: 1055.836252
 Self time:  88.879932

count  total (s)   self (s)
    8            145.537680 	let entries = split(globpath(a:dirs, s:glob), "\n")
    8  15.455745   0.000389 	let [dnf, depth] = [ctrlp#dirnfile(entries), a:depth + 1]
    8              0.008305 	cal extend(g:ctrlp_allfiles, dnf[1])
    8   0.000253   0.000188 	if !empty(dnf[0]) && !s:maxf(len(g:ctrlp_allfiles)) && depth <= s:maxdepth
    7   0.077963   0.000122 		sil! cal ctrlp#progress(len(g:ctrlp_allfiles), 1)
    7   0.877207   0.073408 		cal s:GlobPath(join(map(dnf[0], 's:fnesc(v:val, "g", ",")'), ','), depth)
    7              0.000023 	en

FUNCTION  airline#extensions#hunks#get_hunks()
Called 961 times
Total time:   0.260603
 Self time:   0.141955

count  total (s)   self (s)
  961              0.006601   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
  961              0.034854   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
  961   0.128292   0.009644   let hunks = s:get_hunks()
  961              0.002655   let string = ''
  961              0.003788   if !empty(hunks)
 1792              0.005230     for i in [0, 1, 2]
 1344              0.008362       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
 1344              0.017500         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
 1344              0.002453       endif
 1344              0.002605     endfor
  448              0.000583   endif
  961              0.003670   let b:airline_hunks = string
  961              0.003475   let b:airline_changenr = b:changedtick
  961              0.004720   let s:airline_winwidth = winwidth(0)
  961              0.002299   return string

FUNCTION  ctrlspace#window#MoveSelectionBar()
Called 1 time
Total time:   0.000266
 Self time:   0.000231

count  total (s)   self (s)
    1              0.000004 	if b:size < 1
                            		return
                            	endif
                            
    1              0.000002 	let newpos = 0
                            
    1              0.000005 	if !exists("b:lastline")
    1              0.000003 		let b:lastline = 0
    1              0.000000 	endif
                            
    1   0.000009   0.000008 	setlocal modifiable
                            
                            	" the mouse was pressed: remember which line
                            	" and go back to the original location for now
    1              0.000003 	if a:where == "mouse"
                            		let newpos = line(".")
                            		call s:goto(b:lastline)
                            	endif
                            
                            	" exchange the first char (>) with a space
    1              0.000017 	call setline(line("."), " " . strpart(getline(line(".")), 1))
                            
                            	" go where the user want's us to go
    1              0.000003 	if a:where == "up"
                            		call s:goto(line(".") - 1)
                            	elseif a:where == "down"
                            		call s:goto(line(".") + 1)
                            	elseif a:where == "mouse"
                            		call s:goto(newpos)
                            	elseif a:where == "pgup"
                            		let newpos = line(".") - winheight(0)
                            		if newpos < 1
                            			let newpos = 1
                            		endif
                            		call s:goto(newpos)
                            	elseif a:where == "pgdown"
                            		let newpos = line(".") + winheight(0)
                            		if newpos > line("$")
                            			let newpos = line("$")
                            		endif
                            		call s:goto(newpos)
                            	elseif a:where == "half_pgup"
                            		let newpos = line(".") - winheight(0) / 2
                            		if newpos < 1
                            			let newpos = 1
                            		endif
                            		call s:goto(newpos)
                            	elseif a:where == "half_pgdown"
                            		let newpos = line(".") + winheight(0) / 2
                            		if newpos > line("$")
                            			let newpos = line("$")
                            		endif
                            		call s:goto(newpos)
                            	else
    1   0.000053   0.000021 		call s:goto(a:where)
    1              0.000001 	endif
                            
                            	" and mark this line with a >
    1              0.000015 	call setline(line("."), ">" . strpart(getline(line(".")), 1))
                            
                            	" remember this line, in case the mouse is clicked
                            	" (which automatically moves the cursor there)
    1              0.000004 	let b:lastline = line(".")
                            
    1   0.000009   0.000007 	setlocal nomodifiable

FUNCTION  airline#themes#seagull#refresh()
Called 4 times
Total time:   0.005802
 Self time:   0.003936

count  total (s)   self (s)
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Options
                              """"""""""""""""""""""""""""""""""""""""""""""""
    4              0.000039   let s:background           = get(g:, 'airline_seagull_bg', &background)
    4              0.000035   let s:ansi_colors          = get(g:, 'seagull_termcolors', 16) != 256 && &t_Co >= 16 ? 1 : 0
    4              0.000026   let s:use_green            = get(g:, 'airline_seagull_normal_green', 0)
    4              0.000028   let s:dark_inactive_border = get(g:, 'airline_seagull_dark_inactive_border', 0)
    4              0.000014   let s:tty                  = &t_Co == 8
                            
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Colors
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Base colors
    4              0.000028   let s:base03  = {'t': 234, 'g': '#0b141a'}
    4              0.000022   let s:base02  = {'t': 235, 'g': '#1d252b'}
    4              0.000022   let s:base01  = {'t': 240, 'g': '#61707a'}
    4              0.000020   let s:base00  = {'t': 241, 'g': '#6d767d'}
    4              0.000022   let s:base0   = {'t': 244, 'g': '#787e82'}
    4              0.000020   let s:base1   = {'t': 245, 'g': '#808487'}
    4              0.000018   let s:base2   = {'t': 254, 'g': '#e6eaed'}
    4              0.000019   let s:base3   = {'t': 230, 'g': '#ffffff'}
    4              0.000024   let s:yellow  = {'t': 136, 'g': '#bf8c00'}
    4              0.000020   let s:orange  = {'t': 166, 'g': '#ff6200'}
    4              0.000019   let s:red     = {'t': 160, 'g': '#ff4053'}
    4              0.000024   let s:magenta = {'t': 125, 'g': '#ff549b'}
    4              0.000022   let s:violet  = {'t': 61,  'g': '#9854ff'}
    4              0.000022   let s:blue    = {'t': 33,  'g': '#0099ff'}
    4              0.000019   let s:cyan    = {'t': 37,  'g': '#00a5ab'}
    4              0.000020   let s:green   = {'t': 64,  'g': '#11ab00'}
                            
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Simple mappings
                              " NOTE: These are easily tweakable mappings. The actual mappings get
                              " the specific gui and terminal colors from the base color dicts.
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Normal mode
    4              0.000012   if s:background == 'dark'
    4              0.000031     let s:N1 = [s:base3, (s:use_green ? s:green : s:base1), 'bold']
    4              0.000022     let s:N2 = [s:base2, (s:tty ? s:base01 : s:base00), '']
    4              0.000018     let s:N3 = [s:base01, s:base02, '']
    4              0.000008   else
                                let s:N1 = [s:base2, (s:use_green ? s:green : s:base00), 'bold']
                                let s:N2 = [(s:tty ? s:base01 : s:base2), s:base1, '']
                                let s:N3 = [s:base1, s:base2, '']
                              endif
    4              0.000033   let s:NF = [s:orange, s:N3[1], '']
    4              0.000020   let s:NW = [s:base3, s:orange, '']
    4              0.000013   if s:background == 'dark'
    4              0.000021     let s:NM = [s:base1, s:N3[1], '']
    4              0.000025     let s:NMi = [s:base2, s:N3[1], '']
    4              0.000006   else
                                let s:NM = [s:base01, s:N3[1], '']
                                let s:NMi = [s:base02, s:N3[1], '']
                              endif
                            
                              " Insert mode
    4              0.000030   let s:I1 = [s:N1[0], s:cyan, 'bold']
    4              0.000010   let s:I2 = s:N2
    4              0.000008   let s:I3 = s:N3
    4              0.000008   let s:IF = s:NF
    4              0.000007   let s:IM = s:NM
                            
                              " Visual mode
    4              0.000027   let s:V1 = [s:N1[0], s:green, 'bold']
    4              0.000008   let s:V2 = s:N2
    4              0.000007   let s:V3 = s:N3
    4              0.000010   let s:VF = s:NF
    4              0.000009   let s:VM = s:NM
                            
                              " Replace mode
    4              0.000030   let s:R1 = [s:N1[0], s:red, '']
    4              0.000016   let s:R2 = s:N2
    4              0.000014   let s:R3 = s:N3
    4              0.000015   let s:RM = s:NM
    4              0.000016   let s:RF = s:NF
                            
                              " Inactive, according to VertSplit in seagull
                              " (bg dark: base00; bg light: base0)
    4              0.000012   if s:background == 'dark'
    4              0.000009     if s:dark_inactive_border
                                  let s:IA = [s:base01, s:base02, '']
                                else
    4              0.000028       let s:IA = [s:base02, s:base00, '']
    4              0.000005     endif
    4              0.000003   else
                                let s:IA = [s:base2, s:base0, '']
                              endif
                            
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Actual mappings
                              " WARNING: Don't modify this section unless necessary.
                              """"""""""""""""""""""""""""""""""""""""""""""""
    4              0.000044   let s:NFa = [s:NF[0].g, s:NF[1].g, s:NF[0].t, s:NF[1].t, s:NF[2]]
    4              0.000048   let s:IFa = [s:IF[0].g, s:IF[1].g, s:IF[0].t, s:IF[1].t, s:IF[2]]
    4              0.000045   let s:VFa = [s:VF[0].g, s:VF[1].g, s:VF[0].t, s:VF[1].t, s:VF[2]]
    4              0.000046   let s:RFa = [s:RF[0].g, s:RF[1].g, s:RF[0].t, s:RF[1].t, s:RF[2]]
                            
    4              0.000081   let g:airline#themes#seagull#palette.accents = { 'red': s:NFa, }
                            
    4   0.000589   0.000205   let g:airline#themes#seagull#palette.inactive = airline#themes#generate_color_map( [s:IA[0].g, s:IA[1].g, s:IA[0].t, s:IA[1].t, s:IA[2]], [s:IA[0].g, s:IA[1].g, s:IA[0].t, s:IA[1].t, s:IA[2]], [s:IA[0].g, s:IA[1].g, s:IA[0].t, s:IA[1].t, s:IA[2]])
    4              0.000084   let g:airline#themes#seagull#palette.inactive_modified = { 'airline_c': [s:NMi[0].g, '', s:NMi[0].t, '', s:NMi[2]]}
                            
    4   0.000736   0.000325   let g:airline#themes#seagull#palette.normal = airline#themes#generate_color_map( [s:N1[0].g, s:N1[1].g, s:N1[0].t, s:N1[1].t, s:N1[2]], [s:N2[0].g, s:N2[1].g, s:N2[0].t, s:N2[1].t, s:N2[2]], [s:N3[0].g, s:N3[1].g, s:N3[0].t, s:N3[1].t, s:N3[2]])
                            
    4              0.000052   let g:airline#themes#seagull#palette.normal.airline_warning = [ s:NW[0].g, s:NW[1].g, s:NW[0].t, s:NW[1].t, s:NW[2]]
                            
    4              0.000044   let g:airline#themes#seagull#palette.normal.airline_error = [ s:NW[0].g, s:NW[1].g, s:NW[0].t, s:NW[1].t, s:NW[2]]
                            
    4              0.000174   let g:airline#themes#seagull#palette.normal_modified = { 'airline_c': [s:NM[0].g, s:NM[1].g, s:NM[0].t, s:NM[1].t, s:NM[2]]}
                            
    4              0.000026   let g:airline#themes#seagull#palette.normal_modified.airline_warning = g:airline#themes#seagull#palette.normal.airline_warning
                            
    4   0.000596   0.000234   let g:airline#themes#seagull#palette.insert = airline#themes#generate_color_map( [s:I1[0].g, s:I1[1].g, s:I1[0].t, s:I1[1].t, s:I1[2]], [s:I2[0].g, s:I2[1].g, s:I2[0].t, s:I2[1].t, s:I2[2]], [s:I3[0].g, s:I3[1].g, s:I3[0].t, s:I3[1].t, s:I3[2]])
                            
    4              0.000024   let g:airline#themes#seagull#palette.insert.airline_warning = g:airline#themes#seagull#palette.normal.airline_warning
                            
    4              0.000114   let g:airline#themes#seagull#palette.insert_modified = { 'airline_c': [s:IM[0].g, s:IM[1].g, s:IM[0].t, s:IM[1].t, s:IM[2]]}
                            
    4              0.000024   let g:airline#themes#seagull#palette.insert_modified.airline_warning = g:airline#themes#seagull#palette.normal.airline_warning
                            
    4   0.000632   0.000278   let g:airline#themes#seagull#palette.visual = airline#themes#generate_color_map( [s:V1[0].g, s:V1[1].g, s:V1[0].t, s:V1[1].t, s:V1[2]], [s:V2[0].g, s:V2[1].g, s:V2[0].t, s:V2[1].t, s:V2[2]], [s:V3[0].g, s:V3[1].g, s:V3[0].t, s:V3[1].t, s:V3[2]])
                            
    4              0.000023   let g:airline#themes#seagull#palette.visual.airline_warning = g:airline#themes#seagull#palette.normal.airline_warning
                            
    4              0.000122   let g:airline#themes#seagull#palette.visual_modified = { 'airline_c': [s:VM[0].g, s:VM[1].g, s:VM[0].t, s:VM[1].t, s:VM[2]]}
                            
    4              0.000024   let g:airline#themes#seagull#palette.visual_modified.airline_warning = g:airline#themes#seagull#palette.normal.airline_warning
                            
    4   0.000553   0.000198   let g:airline#themes#seagull#palette.replace = airline#themes#generate_color_map( [s:R1[0].g, s:R1[1].g, s:R1[0].t, s:R1[1].t, s:R1[2]], [s:R2[0].g, s:R2[1].g, s:R2[0].t, s:R2[1].t, s:R2[2]], [s:R3[0].g, s:R3[1].g, s:R3[0].t, s:R3[1].t, s:R3[2]])
                            
    4              0.000024   let g:airline#themes#seagull#palette.replace.airline_warning = g:airline#themes#seagull#palette.normal.airline_warning
                            
    4              0.000076   let g:airline#themes#seagull#palette.replace_modified = { 'airline_c': [s:RM[0].g, s:RM[1].g, s:RM[0].t, s:RM[1].t, s:RM[2]]}
                            
    4              0.000026   let g:airline#themes#seagull#palette.replace_modified.airline_warning = g:airline#themes#seagull#palette.normal.airline_warning
                            
    4              0.000039   let g:airline#themes#seagull#palette.tabline = {}
                            
    4              0.000053   let g:airline#themes#seagull#palette.tabline.airline_tab = [ s:I2[0].g, s:I2[1].g, s:I2[0].t, s:I2[1].t, s:I2[2]]
                            
    4              0.000054   let g:airline#themes#seagull#palette.tabline.airline_tabtype = [ s:N2[0].g, s:N2[1].g, s:N2[0].t, s:N2[1].t, s:N2[2]]

FUNCTION  BuffergatorUpdateMRU()
Called 26 times
Total time:   0.003205
 Self time:   0.003205

count  total (s)   self (s)
   26              0.000174     if len(g:buffergator_mru) < 1 " maybe should be 2?
                                    if g:buffergator_mru_cycle_loop
                                        let g:buffergator_mru = []
                                        for l:bni in range(bufnr("$"), 1, -1)
                                            if buflisted(l:bni)   && getbufvar(l:bni, "&filetype") != "netrw"
                                                call add(g:buffergator_mru, l:bni)
                                            endif
                                        endfor
                                    endif
                                endif
   26              0.000178     if !exists("w:buffergator_mru")
                                    let w:buffergator_mru = g:buffergator_mru[:]
                                endif
   26              0.000066     if g:buffergator_track_mru
   25              0.000232         let bnum = a:acmd_bufnr + 0
                                    " if bnum == 0 || !buflisted(bnum) || !(empty(getbufvar(bnum, "netrw_browser_active")))
   25              0.000319         if bnum == 0 || !buflisted(bnum) || getbufvar(bnum, "&filetype") == "netrw"
                                        return
                                    endif
   25              0.000366         call filter(g:buffergator_mru, 'v:val !=# bnum')
   25              0.000153         call insert(g:buffergator_mru, bnum, 0)
   25              0.000303         call filter(w:buffergator_mru, 'v:val !=# bnum')
   25              0.000137         call insert(w:buffergator_mru, bnum, 0)
   25              0.000038     endif

FUNCTION  <SNR>277_exit_visual_mode()
Called 3 times
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
    3              0.000076   exec "normal! \<Esc>gv\<Esc>"
                            
                              " Call before function if exists only once until it is canceled (<Esc>)
    3              0.000037   if exists('*Multiple_cursors_before') && !s:before_function_called
                                exe "call Multiple_cursors_before()"
                                let s:before_function_called = 1
                              endif

FUNCTION  <SNR>133_clear()
Called 3 times
Total time:   0.003012
 Self time:   0.000247

count  total (s)   self (s)
    3   0.002083   0.000065   call gitgutter#sign#clear_signs(a:bufnr)
    3   0.000253   0.000075   call gitgutter#sign#remove_dummy_sign(a:bufnr, 1)
    3   0.000429   0.000034   call gitgutter#hunk#reset(a:bufnr)
    3   0.000235   0.000061   call s:reset_tick(a:bufnr)

FUNCTION  <SNR>157_build_command()
Called 72 times
Total time:   0.001150
 Self time:   0.001150

count  total (s)   self (s)
   72              0.000485   if has('unix')
   72              0.000461     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  airline#parts#readonly()
Called 965 times
Total time:   0.122086
 Self time:   0.041588

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files, 
                              " but not special ones like e.g. NERDTree)
  965   0.100493   0.019995   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
  965              0.005783   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  965              0.003361     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>159_save_last_seen_change()
Called 4 times
Total time:   0.000203
 Self time:   0.000066

count  total (s)   self (s)
    4   0.000199   0.000062   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>110_has_custom_scm()
Called 513 times
Total time:   0.005285
 Self time:   0.005285

count  total (s)   self (s)
  513              0.004603   return !empty(get(g:, 'airline#extensions#branch#custom_head', ''))

FUNCTION  <SNR>278_modevar()
Called 3 times
Total time:   0.000935
 Self time:   0.000242

count  total (s)   self (s)
    3   0.000081   0.000049 	let s:matchtype = s:mtype()
    3   0.000065   0.000039 	let s:ispath = s:ispathitem()
    3   0.000499   0.000040 	let s:mfunc = s:mfunc()
    3   0.000137   0.000045 	let s:nolim = s:getextvar('nolim')
    3   0.000122   0.000038 	let s:dosort = s:getextvar('sort')
    3              0.000020 	let s:spi = !s:itemtype || s:getextvar('specinput') > 0

FUNCTION  <SNR>63_unc_path()
Called 72 times
Total time:   0.073586
 Self time:   0.001812

count  total (s)   self (s)
   72   0.073472   0.001698   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>277_compare_pos()
Called 6 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
                              " If number lines are the same, compare columns
    6              0.000083   return a:l[0] ==# a:r[0] ? a:l[1] - a:r[1] : a:l[0] - a:r[0]

FUNCTION  syntastic#util#bufIsActive()
Called 25 times
Total time:   0.001232
 Self time:   0.001232

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
   25              0.000195     let buf = str2nr(a:buffer)
                            
   25              0.000199     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
   25              0.000236     for tab in range(1, tabpagenr('$'))
   25              0.000207         if index(tabpagebuflist(tab), buf) >= 0
   25              0.000062             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>159_write_buffer()
Called 64 times
Total time:   0.846871
 Self time:   0.846871

count  total (s)   self (s)
   64              0.023654   let bufcontents = getbufline(a:bufnr, 1, '$')
   64              0.000769   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
   64              0.821535   call writefile(bufcontents, a:file)

FUNCTION  gitgutter#utility#setbufvar()
Called 195 times
Total time:   0.008391
 Self time:   0.008391

count  total (s)   self (s)
  195              0.003479   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  195              0.001198   let needs_setting = empty(dict)
  195              0.001257   let dict[a:varname] = a:val
  195              0.000474   if needs_setting
    3              0.000029     call setbufvar(a:buffer, 'gitgutter', dict)
    3              0.000005   endif

FUNCTION  <SNR>228_Highlight_Matching_Pair()
Called 662 times
Total time:   1.070545
 Self time:   0.049774

count  total (s)   self (s)
                                " Remove any previous match.
  662              0.004850     if exists('w:tag_hl_on') && w:tag_hl_on
  178              0.000832         2match none
  178              0.000512         let w:tag_hl_on = 0
  178              0.000234     endif
                            
                                " Avoid that we remove the popup menu.
                                " Return when there are no colors (looks like the cursor jumps).
  662              0.004793     if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                    return
                                endif
                            
                                "get html tag under cursor
  662   0.083451   0.007184     let tagname = s:GetCurrentCursorTag()
  662              0.002972     if tagname == ""|return|endif
                            
  376              0.001931     if tagname[0] == '/'
   73   0.074717   0.001625         let position = s:SearchForMatchingTag(tagname[1:], 0)
   73              0.000154     else
  303   0.850882   0.004503         let position = s:SearchForMatchingTag(tagname, 1)
  303              0.000672     endif
  376   0.029974   0.004941     call s:HighlightTagAtPosition(position)

FUNCTION  <SNR>278_walker()
Called 8 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    8              0.000047 	retu a:d >= 0 ? a:p < a:m ? a:p + a:d : 0 : a:p > 0 ? a:p + a:d : a:m

FUNCTION  airline#builder#should_change_group()
Called 389 times
Total time:   0.258122
 Self time:   0.016454

count  total (s)   self (s)
  389              0.001572   if a:group1 == a:group2
   13              0.000023     return 0
                              endif
  376   0.127705   0.004143   let color1 = airline#highlighter#get_highlight(a:group1)
  376   0.122256   0.004150   let color2 = airline#highlighter#get_highlight(a:group2)
  376              0.001294   if g:airline_gui_mode ==# 'gui'
  376              0.002837     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  airline#highlighter#exec()
Called 8974 times
Total time:   4.954012
 Self time:   1.332464

count  total (s)   self (s)
 8974              0.035943   if pumvisible()
                                return
                              endif
 8974              0.026724   let colors = a:colors
 8974              0.020517   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 8974   2.765404   0.097725   let old_hi = airline#highlighter#get_highlight(a:group)
 8974              0.036013   if len(colors) == 4
 2697              0.012801     call add(colors, '')
 2697              0.003331   endif
 8974              0.029754   if g:airline_gui_mode ==# 'gui'
 8974              0.089028     let new_hi = [colors[0], colors[1], '', '', colors[4]]
 8974              0.013801   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
 8974   0.529330   0.088311   let colors = s:CheckDefined(colors)
 8974   0.370864   0.094093   if old_hi != new_hi || !s:hl_group_exists(a:group)
 2156   0.381125   0.145046     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
 2156              0.057990     exe cmd
 2156              0.013163     if has_key(s:hl_groups, a:group)
 2156              0.010562       let s:hl_groups[a:group] = colors
 2156              0.002952     endif
 2156              0.002289   endif

FUNCTION  multiple_cursors#new()
Called 3 times
Total time:   0.087309
 Self time:   0.012147

count  total (s)   self (s)
                              " Call before function if exists only once until it is canceled (<Esc>)
    3   0.000302   0.000077   call s:fire_pre_triggers()
    3              0.000017   let s:use_word_boundary = a:word_boundary
    3              0.000014   if a:mode ==# 'n'
                                " Reset all existing cursors, don't restore view and setting
    2   0.000408   0.000042     call s:cm.reset(0, 0)
                            
                                " Select the word under cursor to set the '< and '> marks
    2              0.010839     exec "normal! viw"
    2   0.000187   0.000079     call s:exit_visual_mode()
                            
                                " Add cursor with the current visual selection
    2   0.002319   0.000136     call s:cm.add(s:pos("'>"), s:region("'<", "'>"))
    2   0.068051   0.000067     call s:wait_for_user_input('v')
    2              0.000005   elseif a:mode ==# 'v'
                                " If the visual area covers the same line, then do a search for next
                                " occurrence
    1              0.000007     let start = line("'<")
    1              0.000006     let finish = line("'>")
    1              0.000004     if start != finish
                                  call s:cm.reset(0, 0)
                                  let col = col("'<")
                                  for line in range(line("'<"), line("'>"))
                                    let pos = [line, col]
                                    call s:cm.add(pos)
                                  endfor
                                  " Start in normal mode
                                  call s:wait_for_user_input('n')
                                else
                                  " Came directly from visual mode
    1   0.000034   0.000012       if s:cm.is_empty()
                                    call s:cm.reset(0, 0)
                            
                                    if visualmode() ==# 'V'
                                      let left = [line('.'), 1]
                                      let right = [line('.'), col('$')-1]
                                      if right[1] == 0 " empty line
                                        return
                                      endif
                                      call s:cm.add(right, [left, right])
                                    else
                                      call s:cm.add(s:pos("'>"), s:region("'<", "'>"))
                                    endif
                                  endif
    1   0.000411   0.000046       let content = s:get_text(s:region("'<", "'>"))
    1   0.001777   0.000044       let next = s:find_next(content)
    1   0.000105   0.000018       if s:cm.add(next[1], next)
                                    call s:update_visual_markers(next)
                                  else
    1   0.000026   0.000017         call cursor(s:cm.get_current().position)
    1              0.000159         echohl WarningMsg | echo 'No more matches' | echohl None
    1              0.000002       endif
    1   0.002097   0.000017       call s:wait_for_user_input('v')
    1              0.000002     endif
    1              0.000001   endif

FUNCTION  <SNR>277_get_text()
Called 1 time
Total time:   0.000284
 Self time:   0.000098

count  total (s)   self (s)
    1              0.000021   let lines = getline(a:region[0][0], a:region[1][0])
    1   0.000237   0.000051   let lines[-1] = s:strpart(lines[-1], 0, a:region[1][1])
    1              0.000013   let lines[0] = lines[0][a:region[0][1] - 1:]
    1              0.000008   return join(lines, "\n")

FUNCTION  <SNR>278_findroot()
Called 12 times
Total time:   0.081988
 Self time:   0.002888

count  total (s)   self (s)
   12              0.000137 	let [depth, fnd] = [a:depth + 1, 0]
   12              0.000072 	if type(a:mark) == 1
                            		let fnd = s:glbpath(s:fnesc(a:curr, 'g', ','), a:mark, 1) != ''
                            	elsei type(a:mark) == 3
   72              0.000290 		for markr in a:mark
   60   0.030130   0.002010 			if s:glbpath(s:fnesc(a:curr, 'g', ','), markr, 1) != ''
                            				let fnd = 1
                            				brea
                            			en
   60              0.000143 		endfo
   12              0.000022 	en
   12              0.000033 	if fnd
                            		if !a:type | cal ctrlp#setdir(a:curr) | en
                            		retu [exists('markr') ? markr : a:mark, a:curr]
                            	elsei depth > s:maxdepth
                            		cal ctrlp#setdir(s:cwd)
                            	el
   12   0.001111   0.000212 		let parent = s:getparent(a:curr)
   12              0.000064 		if parent != a:curr
    9              0.000119 			retu s:findroot(parent, a:mark, depth, a:type)
                            		en
    3              0.000004 	en
    3              0.000006 	retu []

FUNCTION  <SNR>113_check_mixed_indent()
Called 24 times
Total time:   0.358136
 Self time:   0.358136

count  total (s)   self (s)
   24              0.000234   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
   24              0.000061   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
   24              0.357236     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  510()
Called 2 times
Total time:   0.000327
 Self time:   0.000291

count  total (s)   self (s)
    2              0.000023   if !empty(self.saved_settings)
    2   0.000082   0.000066     let &virtualedit = self.saved_settings['virtualedit']
    2   0.000040   0.000036     let &cursorline = self.saved_settings['cursorline']
    2   0.000030   0.000027     let &lazyredraw = self.saved_settings['lazyredraw']
    2   0.000043   0.000034     let &paste = self.saved_settings['paste']
    2   0.000035   0.000031     let &clipboard = self.saved_settings['clipboard']
    2              0.000004   endif
                            
                              " Restore original contents and type of unnamed register. This method is
                              " called from reset, which calls us only when restore_setting argument is
                              " true, which happens only when we leave multicursor mode. This should be
                              " symmetrical to saving of unnamed register upon the start of multicursor
                              " mode.
    2              0.000032   call setreg('"', s:paste_buffer_temporary_text, s:paste_buffer_temporary_type)

FUNCTION  airline#extensions#whitespace#check()
Called 961 times
Total time:   0.677701
 Self time:   0.267904

count  total (s)   self (s)
  961              0.008682   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  961              0.011032   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
  961              0.012561   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  961              0.007045   if !exists('b:airline_whitespace_check')
   24              0.000090     let b:airline_whitespace_check = ''
   24              0.000263     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
   24              0.000063     let trailing = 0
   24              0.000067     let check = 'trailing'
   24              0.000362     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   24              0.000040       try
   24              0.000184         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
   24              0.049904         let trailing = search(regexp, 'nw')
   24              0.000108       catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
   24              0.000028     endif
                            
   24              0.000072     let mixed = 0
   24              0.000072     let check = 'indent'
   24              0.000454     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   24   0.359004   0.000868       let mixed = s:check_mixed_indent()
   24              0.000187     endif
                            
   24              0.000133     let mixed_file = ''
   24              0.000087     let check = 'mixed-indent-file'
   24              0.000752     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   24   0.021620   0.000598       let mixed_file = s:check_mixed_indent_file()
   24              0.000032     endif
                            
   24              0.000062     let long = 0
   24              0.000136     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
   24              0.000122     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
   24              0.000125       let b:airline_whitespace_check = s:symbol
   24              0.000116       if strlen(s:symbol) > 0
   24              0.000119         let space = (g:airline_symbols.space)
   24              0.000035       else
                                    let space = ''
                                  endif
                            
   24              0.000047       if s:show_message
   24              0.000050         if trailing != 0
   24              0.000214           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
   24              0.000419           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
   24              0.000039         endif
   24              0.000049         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
   24              0.000048         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
   24              0.000111         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
   24              0.000028       endif
   24              0.000024     endif
   24              0.000027   endif
  961   0.041360   0.010721   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#extensions#tabline#ctrlspace#add_buffer_section()
Called 33 times
Total time:   0.022441
 Self time:   0.007963

count  total (s)   self (s)
   33              0.000094   if a:pos == 0
   33              0.000107     let pos_extension = ''
   33              0.000047   else
                                let pos_extension = '_right'
                              endif
                            
   33   0.013151   0.000680   let s:buffer_list = ctrlspace#api#BufferList(a:cur_tab)
                              " add by tenfy(tenfyzhong@qq.com)
                              " if the current buffer no in the buffer list
                              " return false and no redraw tabline. 
                              " Fixes #1515. if there a BufEnter autocmd execute redraw. The tabline may no update.
   33              0.000479   let bufnr_list = map(copy(s:buffer_list), 'v:val["index"]')
   33              0.000167   if index(bufnr_list, a:cur_buf) == -1
   10              0.000018     return 0
                              endif
                            
   91              0.000213   for buffer in s:buffer_list
   68              0.000197       if a:cur_buf == buffer.index
   23              0.000042         if buffer.modified
    6              0.000029           let group = 'airline_tabmod'.pos_extension
    6              0.000008         else
   17              0.000075           let group = 'airline_tabsel'.pos_extension
   17              0.000024         endif
   23              0.000027       else
   45              0.000085         if buffer.modified
   12              0.000060           let group = 'airline_tabmod_unsel'.pos_extension
   12              0.000033         elseif buffer.visible
                                      let group = 'airline_tab'.pos_extension
                                    else
   33              0.000147           let group = 'airline_tabhid'.pos_extension
   33              0.000044         endif
   45              0.000052       endif
                            
   68              0.000556       let buf_name = '%(%{airline#extensions#tabline#get_buffer_name('.buffer.index.')}%)'
                            
   68              0.000486       if has("tablineat")
                                    let buf_name = '%'.buffer.index.'@airline#extensions#tabline#buffers#clickbuf@'.buf_name.'%X'
                                  endif
                            
   68   0.002736   0.000729       call a:builder.add_section_spaced(group, buf_name)
   68              0.000118   endfor
                              " add by tenfy(tenfyzhong@qq.com)
                              " if the selected buffer was updated
                              " return true
   23              0.000041   return 1

FUNCTION  <SNR>277_apply_user_input_next()
Called 1 time
Total time:   0.001402
 Self time:   0.000251

count  total (s)   self (s)
    1              0.000007   let s:valid_input = 1
                            
                              " Save the current mode, only if we haven't already
    1              0.000007   if empty(s:to_mode)
    1              0.000005     let s:to_mode = a:mode
    1              0.000005     if s:to_mode ==# 'v'
    1              0.000006       if visualmode() ==# 'V'
                                    let s:to_mode = 'V'
                                  endif
    1              0.000002     endif
    1              0.000001   endif
                            
                              " Update the current cursor's information
    1   0.000949   0.000023   let changed = s:cm.update_current()
                            
                              " Advance the cursor index
    1   0.000057   0.000016   call s:cm.next()
                            
                              " We're done if we're made the full round
    1   0.000024   0.000017   if s:cm.loop_done()
    1              0.000005     if s:to_mode ==# 'v' || s:to_mode ==# 'V'
                                  " This is necessary to set the "'<" and "'>" markers properly
    1   0.000196   0.000055       call s:update_visual_markers(s:cm.get_current().visual)
    1              0.000002     endif
    1              0.000013     call feedkeys("\<Plug>(multiple-cursors-wait)")
    1   0.000083   0.000047     call s:handle_visual_IA_to_insert()
    1              0.000001   else
                                " Continue to next
                                call feedkeys("\<Plug>(multiple-cursors-input)")
                              endif

FUNCTION  ctrlp#setpathmode()
Called 6 times
Total time:   0.036283
 Self time:   0.000618

count  total (s)   self (s)
    6              0.000089 	if a:pmode == 'c' || ( a:pmode == 'a' && stridx(s:crfpath, s:cwd) < 0 )
    3   0.000147   0.000125 		if exists('+acd') | let [s:glb_acd, &acd] = [&acd, 0] | en
    3   0.002111   0.000067 		cal ctrlp#setdir(s:crfpath)
    3              0.000009 		retu 1
                            	elsei a:pmode == 'r'
    3              0.000018 		let spath = a:0 ? a:1 : s:crfpath
    3              0.000027 		let markers = ['.git', '.hg', '.svn', '.bzr', '_darcs']
    3              0.000030 		if type(s:rmarkers) == 3 && !empty(s:rmarkers)
                            			if s:findroot(spath, s:rmarkers, 0, 0) != [] | retu 1 | en
                            			cal filter(markers, 'index(s:rmarkers, v:val) < 0')
                            			let markers = s:rmarkers + markers
                            		en
    3   0.033681   0.000082 		if s:findroot(spath, markers, 0, 0) != [] | retu 1 | en
    3              0.000004 	en
    3              0.000007 	retu 0

FUNCTION  <SNR>252_bufferEntry()
Called 3 times
Total time:   0.001475
 Self time:   0.001475

count  total (s)   self (s)
    3              0.001269 	let bufname  = fnamemodify(bufname(a:bufnr), ":.")
    3              0.000031 	let modified = getbufvar(a:bufnr, "&modified")
    3              0.000018 	let winnr    = bufwinnr(a:bufnr)
                            
    3              0.000017 	if !strlen(bufname) && (modified || (winnr != -1))
                            		let bufname = "[" . a:bufnr . "*No Name]"
                            	endif
                            
    3              0.000011 	if strlen(bufname)
    3              0.000008 		let indicators = ""
                            
    3              0.000005 		if modified
    1              0.000006 			let indicators .= s:config.Symbols.IM
    1              0.000001 		endif
                            
    3              0.000009 		if winnr == t:CtrlSpaceStartWindow
    1              0.000004 			let indicators .= s:config.Symbols.IA
    1              0.000002 		elseif winnr != -1
                            			let indicators .= s:config.Symbols.IV
                            		endif
                            
    3              0.000023 		return { "index": a:bufnr, "text": bufname, "indicators": indicators }
                            	else
                            		return {}
                            	endif

FUNCTION  css_color#init()
Called 1 time
Total time:   0.004226
 Self time:   0.000427

count  total (s)   self (s)
    1              0.000013 	let new_type = index( s:type, a:type )
    1              0.000011 	let old_type = index( s:pat_for_type, get( b:, 'css_color_pat', '$^' ) )
                            
    1              0.000016 	let b:css_color_pat = s:pat_for_type[ max( [ old_type, new_type ] ) ]
    1              0.000024 	let b:css_color_grp = extend( get( b:, 'css_color_grp', [] ), split( a:groups, ',' ), 0 )
    1              0.000005 	let b:css_color_hi  = {}
    1              0.000004 	let b:css_color_syn = {}
                            
    1              0.000005 	augroup CSSColor
    1              0.000279 		autocmd! * <buffer>
    1              0.000010 		autocmd ColorScheme <buffer> call css_color#reinit()
    1              0.000007 		autocmd BufWinEnter <buffer> call s:create_matches()
    1              0.000007 		autocmd BufWinLeave <buffer> call s:clear_matches()
    1              0.000001 	augroup END
                            
    1   0.003822   0.000023 	call css_color#enable()
                            
    1              0.000004 	if a:keywords != 'none'
                            		exe 'syntax include syntax/colornames/'.a:keywords.'.vim'
                            		call extend( s:color_bright, b:css_color_hi )
                            	endif

FUNCTION  <SNR>36_chop()
Called 2 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000042 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    2              0.000005 	retu a:mrufs

FUNCTION  512()
Called 2 times
Total time:   0.000304
 Self time:   0.000078

count  total (s)   self (s)
    2   0.000301   0.000075   call s:select_in_visual_mode(self.get_current().visual)

FUNCTION  <SNR>66_SetUpForNewFiletype()
Called 26 times
Total time:   0.006494
 Self time:   0.004283

count  total (s)   self (s)
   26              0.000141     let ft = a:filetype
                            
                                "for compound filetypes, if we don't know how to handle the full filetype
                                "then break it down and use the first part that we know how to handle
   26              0.000323     if ft =~ '\.' && !has_key(s:delimiterMap, ft)
                                    let filetypes = split(a:filetype, '\.')
                                    for i in filetypes
                                        if has_key(s:delimiterMap, i)
                                            let ft = i
                                            break
                                        endif
                                    endfor
                                endif
                            
   26              0.000121     let b:NERDSexyComMarker = ''
                            
   26              0.000187     if has_key(s:delimiterMap, ft)
    6              0.000038         let b:NERDCommenterDelims = s:delimiterMap[ft]
   30              0.000121         for i in ['left', 'leftAlt', 'right', 'rightAlt']
   24              0.000166             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = ''
                                        endif
   24              0.000046         endfor
   18              0.000070         for i in ['nested', 'nestedAlt']
   12              0.000075             if !has_key(b:NERDCommenterDelims, i)
                                            let b:NERDCommenterDelims[i] = 0
                                        endif
   12              0.000019         endfor
                                    " if g:NERD_<filetype>_alt_style is defined, use the alternate style
    6              0.000060         let b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")
    6              0.000077         if exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirstInit
                                        call s:SwitchToAlternativeDelimiters(0)
                                        let b:NERDCommenterFirstInit = 1
                                    endif
    6              0.000007     else
   20   0.002553   0.000342         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
   20              0.000046     endif
                            

FUNCTION  airline#extensions#tabline#ctrlspace#get()
Called 87 times
Total time:   0.598732
 Self time:   0.014870

count  total (s)   self (s)
   87              0.000691   let cur_buf = bufnr('%')
   87              0.000735   let buffer_label = get(g:, 'airline#extensions#tabline#buffers_label', 'buffers')
   87              0.000647   let tab_label = get(g:, 'airline#extensions#tabline#tabs_label', 'tabs')
   87              0.000707   let switch_buffers_and_tabs = get(g:, 'airline#extensions#tabline#switch_buffers_and_tabs', 0)
                            
   87              0.000145   try
   87   0.001951   0.000930     call airline#extensions#tabline#tabs#map_keys()
   87              0.000145   catch
                                " no-op
                              endtry
   87   0.036143   0.001368   let s:tab_list = ctrlspace#api#TabList()
  174              0.000480   for tab in s:tab_list
   87              0.000213     if tab.current
   87              0.000269       let cur_tab = tab.index
   87              0.000112     endif
   87              0.000116   endfor
                            
   87              0.000362   if cur_buf == s:current_bufnr && cur_tab == s:current_tabnr
   54              0.000198     return s:current_tabline
                              endif
                            
   33   0.005464   0.000368   let builder = airline#extensions#tabline#new_builder()
                            
                              " Add left tabline content
   33              0.000218   if get(g:, 'airline#extensions#tabline#show_buffers', 1) == 0
                                  call airline#extensions#tabline#ctrlspace#add_tab_section(builder, 0)
                              elseif get(g:, 'airline#extensions#tabline#show_tabs', 1) == 0
                                  " add by tenfy(tenfyzhong@qq.com)
                                  " if current buffer no in the buffer list, does't update tabline
                                  if airline#extensions#tabline#ctrlspace#add_buffer_section(builder, cur_tab, cur_buf, 0) == 0
                                    return s:current_tabline
                                  endif
                              else
   33              0.000077     if switch_buffers_and_tabs == 0
   33   0.001414   0.000362       call builder.add_section_spaced('airline_tabtype', buffer_label)
                                  " add by tenfy(tenfyzhong@qq.com)
                                  " if current buffer no in the buffer list, does't update tabline
   33   0.022948   0.000507       if airline#extensions#tabline#ctrlspace#add_buffer_section(builder, cur_tab, cur_buf, 0) == 0
   10              0.000036         return s:current_tabline
                                  endif
   23              0.000028     else
                                  call builder.add_section_spaced('airline_tabtype', tab_label)
                                  call airline#extensions#tabline#ctrlspace#add_tab_section(builder, 0)
                                endif
   23              0.000029   endif
                            
   23   0.000374   0.000198   call builder.add_section('airline_tabfill', '')
   23   0.000351   0.000159   call builder.split()
   23   0.000360   0.000182   call builder.add_section('airline_tabfill', '')
                            
                              " Add right tabline content
   23              0.000148   if get(g:, 'airline#extensions#tabline#show_buffers', 1) == 0
                                  call builder.add_section_spaced('airline_tabtype', tab_label)
                              elseif get(g:, 'airline#extensions#tabline#show_tabs', 1) == 0
                                  call builder.add_section_spaced('airline_tabtype', buffer_label)
                              else
   23              0.000056     if switch_buffers_and_tabs == 0
   23   0.011124   0.000280       call airline#extensions#tabline#ctrlspace#add_tab_section(builder, 1)
   23   0.000855   0.000227       call builder.add_section_spaced('airline_tabtype', tab_label)
   23              0.000030     else
                                  " add by tenfy(tenfyzhong@qq.com)
                                  " if current buffer no in the buffer list, does't update tabline
                                  if airline#extensions#tabline#ctrlspace#add_buffer_section(builder, cur_tab, cur_buf, 1) == 0
                                    return s:current_tabline
                                  endif
                                  call builder.add_section_spaced('airline_tabtype', buffer_label)
                                endif
   23              0.000025   endif
                            
   23              0.000080   let s:current_bufnr = cur_buf
   23              0.000068   let s:current_tabnr = cur_tab
   23   0.507733   0.000274   let s:current_tabline = builder.build()
   23              0.000068   return s:current_tabline

FUNCTION  <SNR>124_exec_separator()
Called 2658 times
Total time:   3.312897
 Self time:   0.210606

count  total (s)   self (s)
 2658              0.010798   if pumvisible()
                                return
                              endif
 2658   0.898473   0.030784   let l:from = airline#themes#get_highlight(a:from.a:suffix)
 2658   0.885290   0.030577   let l:to = airline#themes#get_highlight(a:to.a:suffix)
 2658              0.018469   let group = a:from.'_to_'.a:to.a:suffix
 2658              0.005304   if a:inverse
 1163              0.012231     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
 1163              0.001783   else
 1495              0.015351     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
 1495              0.002216   endif
 2658              0.014919   let a:dict[group] = colors
 2658   1.413371   0.033482   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>109_get_hunks()
Called 961 times
Total time:   0.118648
 Self time:   0.055159

count  total (s)   self (s)
  961              0.011440   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1              0.000006     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
    1              0.000004       let b:source_func = 's:get_hunks_gitgutter'
    1              0.000003     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
    1              0.000001   endif
  961   0.076289   0.012800   return {b:source_func}()

FUNCTION  <SNR>124_get_array()
Called 15133 times
Total time:   0.285879
 Self time:   0.285879

count  total (s)   self (s)
15133              0.121706   let opts=empty(a:opts) ? '' : join(a:opts, ',')
15133              0.139457   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  <SNR>278_MatchIt()
Called 4 times
Total time:   0.058455
 Self time:   0.020546

count  total (s)   self (s)
    4              0.000025 	let [lines, id] = [[], 0]
    4   0.000284   0.000059 	let pat = s:byfname() ? map(split(a:pat, '^[^;]\+\\\@<!\zs;', 1), 's:martcs.v:val') : s:martcs.a:pat
  125              0.000309 	for item in a:items
  125              0.000267 		let id += 1
  125              0.000195 		try
  125              0.001862 			if (s:matchcrfile || !( s:ispath && item == a:exc )) &&call(s:mfunc, [item, pat]) >= 0
   40              0.000200 				cal add(lines, item)
   40              0.000056 			en
  125              0.000190 		cat | brea | endt
  129              0.000609 		if a:limit > 0 && len(lines) >= a:limit | brea | en
  121              0.000225 	endfo
    4   0.052901   0.015217 	let s:mdata = [s:dyncwd, s:itemtype, s:regexp, s:sublist(a:items, id, -1)]
    4              0.000064 	retu lines

FUNCTION  ctrlspace#api#TabList()
Called 87 times
Total time:   0.034775
 Self time:   0.012114

count  total (s)   self (s)
   87              0.000322 	let tabList     = []
   87              0.000456 	let lastTab    = tabpagenr("$")
   87              0.000364 	let currentTab = tabpagenr()
                            
  174              0.000808 	for t in range(1, lastTab)
   87              0.000494 		let winnr       = tabpagewinnr(t)
   87              0.000469 		let buflist     = tabpagebuflist(t)
   87              0.000592 		let bufnr       = buflist[winnr - 1]
   87              0.000564 		let bufname     = bufname(bufnr)
   87   0.011601   0.001179 		let tabTitle    = ctrlspace#api#TabTitle(t, bufnr, bufname)
   87   0.013235   0.000996 		let tabModified = ctrlspace#api#TabModified(t)
   87              0.000373 		let tabCurrent  = t == currentTab
                            
   87              0.001173 		call add(tabList, { "index": t, "title": tabTitle, "current": tabCurrent, "modified": tabModified })
   87              0.000307         endfor
                            
   87              0.000193         return tabList

FUNCTION  <SNR>109_is_branch_empty()
Called 961 times
Total time:   0.016390
 Self time:   0.016390

count  total (s)   self (s)
  961              0.014936   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  <SNR>135_reset_summary()
Called 71 times
Total time:   0.003645
 Self time:   0.001067

count  total (s)   self (s)
   71   0.003568   0.000990   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>277_wait_for_user_input()
Called 4 times
Total time:   0.098283
 Self time:   0.094302

count  total (s)   self (s)
    4   0.000520   0.000083   call s:display_error()
                            
    4              0.000020   let s:from_mode = a:mode
    4              0.000024   if empty(a:mode)
    1              0.000005     let s:from_mode = s:to_mode
    1              0.000001   endif
    4              0.000016   let s:to_mode = ''
                            
                              " Right before redraw, apply the highlighting bug fix
    4   0.000244   0.000078   call s:apply_highlight_fix()
                            
    4              0.090810   redraw
                            
                              " Immediately revert the change to leave the user's buffer unchanged
    4   0.000195   0.000071   call s:revert_highlight_fix()
                            
    4   0.000287   0.000058   call s:end_latency_measure()
                            
    4              0.000025   let s:char = s:retry_keys . s:saved_keys
    4              0.000021   if len(s:saved_keys) == 0
    4   0.000603   0.000096     let s:char .= s:get_char()
    4   0.000292   0.000141     call s:handle_visual_IA_to_normal()
    4              0.000009   else
                                let s:saved_keys = ""
                              endif
                            
                              " ambiguous mappings are note supported; e.g.:
                              "   imap jj JJ
                              "   imap jjj JJJ
                              " will always trigger the 'jj' mapping
    4              0.000032   if s:from_mode ==# 'i' && mapcheck(s:char, "i") != ""
                                let map_dict = {}
                                let s_time = s:get_time_in_ms()
                                while 1
                                  let map_dict = maparg(s:char, "i", 0, 1)
                                  " break if chars exactly match mapping or if chars don't match beging of mapping anymore
                                  if map_dict != {} || mapcheck(s:char, "i") == ""
                                    if get(map_dict, 'expr', 0)
                                      " handle case where {rhs} is a function
                                      exec 'let char_mapping = ' . map_dict['rhs']
                                    else
                                      let char_mapping = get(map_dict, 'rhs', s:char)
                                    endif
                                    " handle case where mapping is <esc>
                                    exec 'let s:char = "'.substitute(char_mapping, '<', '\\<', 'g').'"'
                                    break
                                  endif
                                  if s:get_time_in_ms() > (s_time + &timeoutlen)
                                    break
                                  endif
                                  let new_char = s:get_char(0)
                                  let s:char .= new_char
                                  if new_char == ''
                                    sleep 50m
                                  endif
                                endwhile
                              elseif s:from_mode !=# 'i' && s:char[0] ==# ":"
                                call feedkeys(s:char)
                                call s:cm.reset(1, 1)
                                return
                              elseif s:from_mode ==# 'n' || s:from_mode =~# 'v\|V'
    4   0.000188   0.000131     while match(s:last_char(), "\\d") == 0
                                  if match(s:char, '\(^\|\a\)0') == 0
                                    " fixes an edge case concerning the `0` key.
                                    " The 0 key behaves differently from [1-9].
                                    " It's consumed immediately when it is the
                                    " first key typed while we're waiting for input.
                                    " References: issue #152, pull #241
                                    break
                                  endif
                                  let s:char .= s:get_char()
                                endwhile
    4              0.000007   endif
                            
    4   0.000172   0.000107   call s:start_latency_measure()
                            
                              " Clears any echoes we might've added
    4              0.000472   normal! :<Esc>
                            
                              " add chars to s:char if it start like a special/quit key
    4              0.000027   let is_special_key = 0
    4              0.000053   let sk_list = get(s:special_keys, s:from_mode, [])
    4              0.000044   let is_special_key = (index(sk_list, s:char) != -1)
    4              0.000016   let is_quit_key = 0
    4   0.000264   0.000085   let s_time = s:get_time_in_ms()
    4              0.000015   while 1
    4              0.000201     let start_special_key = (index(map(sk_list[:], 'v:val[0:len(s:char)-1] == s:char'), 1) > -1)
    4              0.000067     let start_quit_key = (g:multi_cursor_quit_key[0:len(s:char)-1] == s:char)
    4              0.000023     if start_special_key == 0 && start_quit_key == 0
    1              0.000002       break
                                else
    3              0.000026       let is_special_key = (index(sk_list, s:char) != -1)
    3              0.000022       let is_quit_key = (g:multi_cursor_quit_key == s:char)
    3              0.000015       if is_special_key == 1 || is_quit_key == 1
    3              0.000008         break
                                  else
                                    if s:get_time_in_ms() > (s_time + &timeoutlen)
                                      break
                                    endif
                                    let new_char = s:get_char(0)
                                    let s:char .= new_char
                                    if new_char == ''
                                      sleep 50m
                                    endif
                                  endif
                                end
                              endwhile
                            
    4   0.001846   0.000093   if s:exit()
    2              0.000004     return
                              endif
                            
                              " If the key is a special key and we're in the right mode, handle it
    2              0.000007   if is_special_key == 1
    1   0.000231   0.000050     call s:handle_special_key(s:char, s:from_mode)
    1   0.000060   0.000047     call s:skip_latency_measure()
    1              0.000002   else
    1   0.000029   0.000016     call s:cm.start_loop()
    1   0.000151   0.000045     call s:feedkeys("\<Plug>(multiple-cursors-input)")
    1              0.000002   endif

FUNCTION  <SNR>103_invoke_funcrefs()
Called 45 times
Total time:   1.079994
 Self time:   0.004093

count  total (s)   self (s)
   45   0.002913   0.000502   let builder = airline#builder#new(a:context)
   45   0.106287   0.001149   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   45              0.000092   if err == 1
   42   0.968980   0.000665     let a:context.line = builder.build()
   42              0.000489     let s:contexts[a:context.winnr] = a:context
   42   0.000919   0.000882     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   42              0.000064   endif

FUNCTION  gitgutter#utility#repo_path()
Called 252 times
Total time:   0.019184
 Self time:   0.006446

count  total (s)   self (s)
  252   0.011336   0.003664   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
  252   0.007245   0.002179   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>277_handle_visual_IA_to_normal()
Called 4 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
    4              0.000099   if s:char =~# 'I\|A' && s:from_mode =~# 'v\|V'
                                let s:saved_char = s:char
                                let s:char = s:from_mode " spoof a 'v' or 'V' input to transiton from Visual into Normal mode
                              endif

FUNCTION  airline#switch_theme()
Called 7 times
Total time:   1.156096
 Self time:   0.054173

count  total (s)   self (s)
    7              0.000013   try
    7   0.063772   0.053309     let palette = g:airline#themes#{a:name}#palette "also lazy loads the theme
    7              0.000032     let g:airline_theme = a:name
    7              0.000012   catch
                                echohl WarningMsg | echo 'The specified theme cannot be found.' | echohl NONE
                                if exists('g:airline_theme')
                                  return
                                else
                                  let g:airline_theme = 'dark'
                                endif
                              endtry
                            
    7              0.000028   let w:airline_lastmode = ''
    7   0.589400   0.000099   call airline#load_theme()
                            
    7   0.000624   0.000390   silent doautocmd User AirlineAfterTheme
                            
                              " this is required to prevent clobbering the startup info message, i don't know why...
    7   0.502040   0.000115   call airline#check_mode(winnr())

FUNCTION  <SNR>134_upsert_new_gitgutter_signs()
Called 4 times
Total time:   0.000530
 Self time:   0.000350

count  total (s)   self (s)
    4   0.000160   0.000065   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    4   0.000130   0.000045   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
    4              0.000020   for line in a:modified_lines
                                let line_number = line[0]  " <number>
                                if index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = s:highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
                                  endif
                                endif
                              endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  <SNR>278_byfname()
Called 17 times
Total time:   0.001096
 Self time:   0.000204

count  total (s)   self (s)
   17   0.001070   0.000178 	retu s:curtype() != 'buf' && s:ispath && s:byfname

FUNCTION  <SNR>200_on_stdout()
Called 3 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    3              0.000074     let self.buf .= a:msg

FUNCTION  <SNR>75__normalise_filetype()
Called 6 times
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
    6              0.000056     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    6              0.000041     let ft = get(g:syntastic_filetype_map, ft, ft)
    6              0.000064     let ft = substitute(ft, '\m-', '_', 'g')
    6              0.000015     return ft

FUNCTION  ctrlp#clra()
Called 1 time
Total time:   0.010640
 Self time:   0.001541

count  total (s)   self (s)
    1   0.000024   0.000015 	let cadir = ctrlp#utils#cachedir()
    1              0.000243 	if isdirectory(cadir)
    1   0.007287   0.000062 		let cafiles = split(s:glbpath(s:fnesc(cadir, 'g', ','), '**', 1), "\n")
    1              0.000012 		let eval = '!isdirectory(v:val) && v:val !~ ''\v[\/]cache[.a-z]+$|\.log$'''
    1   0.002980   0.001140 		sil! cal map(s:ifilter(cafiles, eval), 'delete(v:val)')
    1              0.000006 	en
    1   0.000077   0.000052 	cal ctrlp#clr()

FUNCTION  ZoomWin#CleanupSessionFile()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                            "  call Dfunc("ZoomWin#CleanupSessionFile()")
    1              0.000009   if exists("s:sessionfile") && filereadable(s:sessionfile)
                            "   call Decho("sessionfile exists and is readable; deleting it")
                               sil! call delete(s:sessionfile)
                               unlet s:sessionfile
                              endif
                            "  call Dret("ZoomWin#CleanupSessionFile")

FUNCTION  <SNR>128_get_seperator()
Called 389 times
Total time:   1.159415
 Self time:   0.010303

count  total (s)   self (s)
  389   0.262381   0.004259   if airline#builder#should_change_group(a:prev_group, a:group)
  339   0.895700   0.004710     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
   50              0.000246     return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 653 times
Total time:   0.025222
 Self time:   0.025222

count  total (s)   self (s)
  653              0.004714   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
  653              0.008272   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
  653              0.005019   if getbufvar(a:bufnr, '&modified') == 1
  150              0.000854     let _ .= s:buf_modified_symbol
  150              0.000228   endif
  653              0.001330   return _

FUNCTION  <SNR>278_setupblank()
Called 3 times
Total time:   0.000541
 Self time:   0.000541

count  total (s)   self (s)
    3              0.000168 	setl noswf nonu nobl nowrap nolist nospell nocuc wfh
    3              0.000161 	setl fdc=0 fdl=99 tw=0 bt=nofile bh=unload
    3              0.000025 	if v:version > 702
    3              0.000075 		setl nornu noudf cc=0
    3              0.000006 	en
    3              0.000011 	if s:has_conceal
    3              0.000066 		setl cole=2 cocu=nc
    3              0.000007 	en

FUNCTION  <SNR>65_repo()
Called 896 times
Total time:   0.049660
 Self time:   0.049660

count  total (s)   self (s)
  896              0.013746   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
  896              0.002870   if dir !=# ''
  896              0.004698     if has_key(s:repos, dir)
  896              0.005267       let repo = get(s:repos, dir)
  896              0.001416     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
  896              0.011584     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  airline#parts#spell()
Called 961 times
Total time:   0.050779
 Self time:   0.050779

count  total (s)   self (s)
  961              0.022134   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  961              0.003860   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
  961              0.001710   return ''

FUNCTION  <SNR>110_init_buffer()
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000005   let b:buffer_vcs_config = {}
    3              0.000013   for vcs in keys(s:vcs_config)
    2              0.000019     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',   }
    2              0.000003   endfor
    1              0.000003   unlet! b:airline_head

FUNCTION  airline#extensions#tabline#load_theme()
Called 9 times
Total time:   0.077683
 Self time:   0.003014

count  total (s)   self (s)
    9              0.000040   if pumvisible()
                                return
                              endif
    9              0.000061   let colors    = get(a:palette, 'tabline', {})
    9              0.000073   let tablabel  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
                              " Theme for tabs on the left
    9              0.000052   let tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
    9              0.000051   let tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
    9              0.000055   let tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
    9              0.000051   let tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
    9              0.000050   let tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
    9              0.000050   let tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
    9              0.000070   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    6              0.000040     let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
    6              0.000007   else
                                "Fall back to normal airline_c if modified airline_c isn't present
    3              0.000018     let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
    3              0.000004   endif
    9   0.005618   0.000109   call airline#highlighter#exec('airline_tablabel', tablabel)
    9   0.005663   0.000111   call airline#highlighter#exec('airline_tab', tab)
    9   0.006034   0.000140   call airline#highlighter#exec('airline_tabsel', tabsel)
    9   0.005843   0.000128   call airline#highlighter#exec('airline_tabtype', tabtype)
    9   0.005812   0.000128   call airline#highlighter#exec('airline_tabfill', tabfill)
    9   0.005949   0.000128   call airline#highlighter#exec('airline_tabmod', tabmod)
    9   0.005840   0.000121   call airline#highlighter#exec('airline_tabmod_unsel', tabmodu)
    9   0.005838   0.000126   call airline#highlighter#exec('airline_tabhid', tabhid)
                            
                              " Theme for tabs on the right
    9              0.000072   let tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
    9              0.000061   let tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
    9              0.000057   let tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
    9              0.000058   let tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
    9              0.000071   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
    6              0.000042     let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
    6              0.000009   else
                                "Fall back to normal airline_c if modified airline_c isn't present
    3              0.000020     let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
    3              0.000005   endif
    9   0.005996   0.000127   call airline#highlighter#exec('airline_tab_right',    tab_right)
    9   0.005930   0.000137   call airline#highlighter#exec('airline_tabsel_right', tabsel_right)
    9   0.006115   0.000140   call airline#highlighter#exec('airline_tabmod_right', tabmod_right)
    9   0.005864   0.000137   call airline#highlighter#exec('airline_tabhid_right', tabhid_right)
    9   0.005829   0.000130   call airline#highlighter#exec('airline_tabmod_unsel_right', tabmodu_right)

FUNCTION  <SNR>277_highlight_cursor()
Called 2 times
Total time:   0.000300
 Self time:   0.000300

count  total (s)   self (s)
                              " Give cursor highlight high priority, to overrule visual selection
    2              0.000292   return matchadd(s:hi_group_cursor, '\%'.a:pos[0].'l\%'.a:pos[1].'c', 99999)

FUNCTION  gitgutter#async#available()
Called 72 times
Total time:   0.000441
 Self time:   0.000441

count  total (s)   self (s)
   72              0.000315   return s:available

FUNCTION  <SNR>278_autocmds()
Called 3 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    3              0.000031 	if !has('autocmd') | retu | en
    3              0.000048 	if exists('#CtrlPLazy')
                            		au! CtrlPLazy
                            	en
    3              0.000007 	if s:lazy
                            		aug CtrlPLazy
                            			au!
                            			au CursorHold ControlP cal s:ForceUpdate()
                            		aug END
                            	en

FUNCTION  ctrlp#progress()
Called 7 times
Total time:   0.077841
 Self time:   0.077611

count  total (s)   self (s)
    7              0.000120 	if has('macunix') || has('mac') | sl 1m | en
    7              0.000034 	let txt = a:0 ? '(press ctrl-c to abort)' : ''
    7              0.000033 	if s:status != {}
    7              0.000063 		let argms = has_key(s:status, 'arg_type') && s:status['arg_type'] == 'dict' ? [{ 'str': a:enum }] : [a:enum]
    7   0.000532   0.000302 		let &l:stl = call(s:status['prog'], argms, s:status)
    7              0.000011 	el
                            		let &l:stl = '%#CtrlPStats# '.a:enum.' %* '.txt.'%=%<%#CtrlPMode2# %{getcwd()} %*'
                            	en
    7              0.076977 	redraws

FUNCTION  <SNR>252_contentSource()
Called 1 time
Total time:   0.001802
 Self time:   0.000067

count  total (s)   self (s)
    1   0.000037   0.000032 	let clv = ctrlspace#modes#CurrentListView()
                            
    1              0.000004 	if clv.Name ==# "Buffer"
    1   0.001758   0.000028 		return s:bufferListContent(clv)
                            	elseif clv.Name ==# "File"
                            		return s:fileListContent(clv)
                            	elseif clv.Name ==# "Tab"
                            		return s:tabContent(clv)
                            	elseif clv.Name ==# "Workspace"
                            		return s:workspaceListContent(clv)
                            	elseif clv.Name ==# "Bookmark"
                            		return s:bookmarkListContent(clv)
                            	endif

FUNCTION  <SNR>278_getinput()
Called 4 times
Total time:   0.000354
 Self time:   0.000354

count  total (s)   self (s)
    4              0.000030 	let [prt, spi] = [s:prompt, ( a:0 ? a:1 : '' )]
    4              0.000016 	if s:abbrev != {}
                            		let gmd = has_key(s:abbrev, 'gmode') ? s:abbrev['gmode'] : ''
                            		let str = ( gmd =~ 't' && !a:0 ) || spi == 'c' ? prt[0] : join(prt, '')
                            		if gmd =~ 't' && gmd =~ 'k' && !a:0 && matchstr(str, '.$') =~ '\k'
                            			retu join(prt, '')
                            		en
                            		let [pf, rz] = [( s:byfname() ? 'f' : 'p' ), ( s:regexp ? 'r' : 'z' )]
                            		for dict in s:abbrev['abbrevs']
                            			let dmd = has_key(dict, 'mode') ? dict['mode'] : ''
                            			let pat = escape(dict['pattern'], '~')
                            			if ( dmd == '' || ( dmd =~ pf && dmd =~ rz && !a:0 ) || dmd =~ '['.spi.']' ) && str =~ pat
                            				let [str, s:did_exp] = [join(split(str, pat, 1), dict['expanded']), 1]
                            			en
                            		endfo
                            		if gmd =~ 't' && !a:0
                            			let prt[0] = str
                            		el
                            			retu str
                            		en
                            	en
    4              0.000055 	retu spi == 'c' ? prt[0] : join(prt, '')

FUNCTION  <SNR>5_StarSetf()
Called 1 time
Total time:   0.243193
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000021   if expand("<amatch>") !~ g:ft_ignore_pat
    1   0.243166   0.000019     exe 'setf ' . a:ft
    1              0.000002   endif

FUNCTION  SyntasticStatuslineFlag()
Called 1922 times
Total time:   0.412825
 Self time:   0.032866

count  total (s)   self (s)
 1922   0.410334   0.030375     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  <SNR>278_strwidth()
Called 40 times
Total time:   0.000575
 Self time:   0.000575

count  total (s)   self (s)
   40              0.000519 	retu exists('*strdisplaywidth') ? strdisplaywidth(a:str) : strlen(a:str)

FUNCTION  <SNR>274_resetWindow()
Called 1 time
Total time:   0.017303
 Self time:   0.011597

count  total (s)   self (s)
    1   0.000036   0.000028 	call s:modes.Help.Disable()
    1   0.000018   0.000012 	call s:modes.Nop.Disable()
    1   0.000016   0.000010 	call s:modes.Search.Disable()
    1   0.000015   0.000010 	call s:modes.NextTab.Disable()
                            
    1   0.000155   0.000014 	call s:modes.Buffer.Enable()
    1   0.000043   0.000028 	call s:modes.Buffer.SetData("SubMode", "single")
                            
    1   0.000024   0.000012 	call s:modes.Search.SetData("NewSearchPerformed", 0)
    1   0.000023   0.000012 	call s:modes.Search.SetData("Restored", 0)
    1   0.000023   0.000012 	call s:modes.Search.SetData("Letters", [])
    1   0.000023   0.000012 	call s:modes.Search.SetData("HistoryIndex", -1)
                            
    1   0.000022   0.000011 	call s:modes.Workspace.SetData("LastBrowsed", 0)
    1   0.000024   0.000012 	call s:modes.Workspace.SetData("SubMode", "load")
                            
    1   0.000923   0.000097 	call ctrlspace#roots#SetCurrentProjectRoot(ctrlspace#roots#FindProjectRoot())
    1   0.001354   0.000064 	call s:modes.Bookmark.SetData("Active", ctrlspace#bookmarks#FindActiveBookmark())
                            
    1   0.000075   0.000031 	call s:modes.Search.RemoveData("LastSearchedDirectory")
                            
    1   0.000068   0.000054 	if ctrlspace#roots#LastProjectRoot() != ctrlspace#roots#CurrentProjectRoot()
    1   0.012947   0.010840 		call ctrlspace#files#ClearAll()
    1   0.000079   0.000057 		call ctrlspace#roots#SetLastProjectRoot(ctrlspace#roots#CurrentProjectRoot())
    1   0.001038   0.000052 		call ctrlspace#workspaces#SetWorkspaceNames()
    1              0.000002 	endif
                            
    1   0.000148   0.000144 	set guicursor+=n:block-CtrlSpaceSelected-blinkon0
                            
    1   0.000218   0.000054 	call ctrlspace#util#HandleVimSettings("start")

FUNCTION  ctrlp#rmbasedir()
Called 1 time
Total time:   0.055266
 Self time:   0.055236

count  total (s)   self (s)
    1              0.000003 	if a:items == []
                            		retu a:items
                            	en
    1   0.000044   0.000014 	let cwd = s:dyncwd.s:lash()
    1              0.000008 	let first = a:items[0]
    1              0.000013 	if has('win32') || has('win64')
                            		let cwd = tr(cwd, '\', '/')
                            		let first = tr(first, '\', '/')
                            	en
    1              0.000006 	if !stridx(first, cwd)
    1              0.000004 		let idx = strlen(cwd)
    1              0.055166 		retu map(a:items, 'strpart(v:val, idx)')
                            	en
                            	retu a:items

FUNCTION  <SNR>277_skip_latency_measure()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000006   if g:multi_cursor_debug_latency
                                let s:skip_latency_measure = 1
                              endif

FUNCTION  ctrlspace#keys#Keypressed()
Called 1 time
Total time:   0.213767
 Self time:   0.000143

count  total (s)   self (s)
    1              0.000015 	let key = (s:keyEscSequence && (a:key ==# "Z")) ? "S-Tab" : a:key
    1              0.000005 	let s:keyEscSequence = 0
                            
    1              0.000005 	if s:modes.Help.Enabled
                            		let mapName = "Help"
                            	elseif s:modes.Search.Enabled
                            		let mapName = "Search"
                            	elseif s:modes.Nop.Enabled
                            		let mapName = "Nop"
                            	else
    1   0.000032   0.000023 		let mapName = ctrlspace#modes#CurrentListView().Name
    1              0.000002 	endif
                            
    1   0.213669   0.000054 	call s:keyMap[mapName][key](key)

FUNCTION  ctrlspace#roots#LastProjectRoot()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	return s:lastProjectRoot

FUNCTION  gitgutter#init_buffer()
Called 23 times
Total time:   0.450788
 Self time:   0.001338

count  total (s)   self (s)
   23   0.086592   0.000332   if gitgutter#utility#is_active(a:bufnr)
   23   0.001642   0.000367     let p = gitgutter#utility#repo_path(a:bufnr, 0)
   23              0.000226     if type(p) != s:t_string || empty(p)
    8   0.362075   0.000160       call gitgutter#utility#set_repo_path(a:bufnr)
    8              0.000010     endif
   23              0.000033   endif

FUNCTION  airline#parts#crypt()
Called 961 times
Total time:   0.011653
 Self time:   0.011653

count  total (s)   self (s)
  961              0.010205   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  360()
Called 3 times
Total time:   0.043285
 Self time:   0.040982

count  total (s)   self (s)
    3              0.000021     if !a:force && has_key(self._checkerMap, a:filetype)
    2              0.000003         return
                                endif
                            
    1   0.043233   0.040930     execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
    1              0.000011     if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  airline#extensions#keymap#status()
Called 961 times
Total time:   0.023341
 Self time:   0.023341

count  total (s)   self (s)
  961              0.011249   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  961              0.009738     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  css_color#enable()
Called 1 time
Total time:   0.003799
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000052 	if len( b:css_color_grp ) | exe 'syn cluster colorableGroup add=' . join( b:css_color_grp, ',' ) | endif
    1              0.000014 	autocmd CSSColor CursorMoved,CursorMovedI <buffer> call s:parse_screen()
    1              0.000004 	let b:css_color_off = 0
    1   0.003727   0.000010 	call s:parse_screen()

FUNCTION  fugitive#is_git_dir()
Called 8 times
Total time:   0.001974
 Self time:   0.001822

count  total (s)   self (s)
    8   0.000256   0.000104   let path = s:sub(a:path, '[\/]$', '') . '/'
    8              0.001701   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  ctrlspace#buffers#AddBuffer()
Called 23 times
Total time:   0.002972
 Self time:   0.002713

count  total (s)   self (s)
   23              0.000246 	let current = bufnr('%')
                            
   23              0.000483 	if !getbufvar(current, "&buflisted") || getbufvar(current, "&ft") ==? "ctrlspace"
                            		return
                            	endif
                            
   23              0.000243 	if !has_key(s:allBuffers, current)
    1              0.000009 		let s:allBuffers[current] = len(s:allBuffers) + 1
    1              0.000002 	endif
                            
   23              0.000093 	if s:modes.Zoom.Enabled
                            		return
                            	endif
                            
   23   0.000601   0.000342 	let b:CtrlSpaceJumpCounter = ctrlspace#jumps#IncrementJumpCounter()
                            
   23              0.000173 	if !exists("t:CtrlSpaceList")
                            		let t:CtrlSpaceList = {}
                            	endif
                            
   23              0.000171 	if !has_key(t:CtrlSpaceList, current)
    1              0.000008 		let t:CtrlSpaceList[current] = len(t:CtrlSpaceList) + 1
    1              0.000001 	endif

FUNCTION  airline#extensions#branch#head()
Called 961 times
Total time:   2.191058
 Self time:   0.158760

count  total (s)   self (s)
  961              0.006550   if !exists('b:buffer_vcs_config')
    1   0.000082   0.000030     call s:init_buffer()
    1              0.000001   endif
                            
  961   0.812707   0.009760   call s:update_branch()
  961   1.213719   0.011233   call s:update_untracked()
                            
  961              0.009106   if exists('b:airline_head') && !empty(b:airline_head)
  448              0.001295     return b:airline_head
                              endif
                            
  513              0.001611   let b:airline_head = ''
  513              0.005038   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
  513              0.001422   let heads = []
 1539              0.003957   for vcs in vcs_priority
 1026              0.006311     if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
 1026              0.001628   endfor
                            
  513              0.001522   for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let b:airline_head .= b:buffer_vcs_config[vcs].untracked
                              endfor
                            
  513              0.001920   if empty(heads)
  513   0.010213   0.004683     if s:has_vcscommand()
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
  513              0.000588   endif
                            
  513              0.001734   if empty(heads)
  513   0.009385   0.004100     if s:has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
  513              0.000594   endif
                            
  513              0.003897   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
  513              0.004606   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  513   0.022288   0.006290   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
  513              0.001364   return b:airline_head

FUNCTION  syntastic#log#debugDump()
Called 3 times
Total time:   0.000051
 Self time:   0.000035

count  total (s)   self (s)
    3   0.000041   0.000025     if !s:_isDebugEnabled(a:level)
    3              0.000006         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>277_process_user_input()
Called 1 time
Total time:   0.000630
 Self time:   0.000242

count  total (s)   self (s)
                              " Grr this is frustrating. In Insert mode, between the feedkey call and here,
                              " the current position could actually CHANGE for some odd reason. Forcing a
                              " position reset here
    1   0.000033   0.000022   let cursor_position = s:cm.get_current()
    1              0.000009   call cursor(cursor_position.position)
                            
                              " Before applying the user input, we need to revert back to the mode the user
                              " was in when the input was entered
    1   0.000263   0.000040   call s:revert_mode(s:to_mode, s:from_mode)
                            
                              " Update the line length BEFORE applying any actions. TODO(terryma): Is there
                              " a better place to do this?
                              " let cursor_position = s:cm.get_current()
    1   0.000052   0.000017   call cursor_position.update_line_length()
    1              0.000008   let s:saved_linecount = line('$')
                            
                              " Restore unnamed register only in Normal mode. This should happen before user
                              " input is processed.
    1              0.000008   if s:from_mode ==# 'n' || s:from_mode ==# 'v' || s:from_mode ==# 'V'
    1   0.000044   0.000026     call cursor_position.restore_unnamed_register()
    1              0.000002   endif
                            
                              " Apply the user input. Note that the above could potentially change mode, we
                              " use the mapping below to help us determine what the new mode is
                              " Note that it's possible that \<Plug>(multiple-cursors-apply) never gets called, we have a
                              " detection mechanism using \<Plug>(multiple-cursors-detect). See its documentation for more details
                            
                              " Assume that input is not valid
    1              0.000005   let s:valid_input = 0
                            
                              " If we're coming from insert mode or going into insert mode, always chain the
                              " undos together.
                              " FIXME(terryma): Undo always places the cursor at the beginning of the line.
                              " Figure out why.
    1              0.000007   if s:from_mode ==# 'i' || s:to_mode ==# 'i'
                                silent! undojoin | call s:feedkeys(s:char."\<Plug>(multiple-cursors-apply)")
                              else
    1   0.000122   0.000021     call s:feedkeys(s:char."\<Plug>(multiple-cursors-apply)")
    1              0.000002   endif
                            
                              " Even when s:char produces invalid input, this method is always called. The
                              " 't' here is important
    1              0.000014   call feedkeys("\<Plug>(multiple-cursors-detect)", 't')

FUNCTION  <SNR>278_SplitPattern()
Called 4 times
Total time:   0.000718
 Self time:   0.000621

count  total (s)   self (s)
    4              0.000014 	let str = a:str
    4              0.000012 	let s:savestr = str
    4              0.000006 	if s:regexp
                            		let pat = s:regexfilter(str)
                            	el
    4              0.000040 		let lst = split(str, '\zs')
    4              0.000025 		if exists('+ssl') && !&ssl
                            			cal map(lst, 'escape(v:val, ''\'')')
                            		en
   16              0.000047 		for each in ['^', '$', '.']
   12              0.000069 			cal map(lst, 'escape(v:val, each)')
   12              0.000040 		endfo
    4              0.000004 	en
    4              0.000016 	if exists('lst')
    4              0.000010 		let pat = ''
    4              0.000013 		if !empty(lst)
    1   0.000068   0.000016 			if s:byfname() && index(lst, ';') > 0
                            				let fbar = index(lst, ';')
                            				let lst_1 = s:sublist(lst, 0, fbar - 1)
                            				let lst_2 = len(lst) - 1 > fbar ? s:sublist(lst, fbar + 1, -1) : ['']
                            				let pat = s:buildpat(lst_1).';'.s:buildpat(lst_2)
                            			el
    1   0.000067   0.000022 				let pat = s:buildpat(lst)
    1              0.000001 			en
    1              0.000001 		en
    4              0.000007 	en
    4              0.000018 	retu escape(pat, '~')

FUNCTION  <SNR>277_find_next()
Called 1 time
Total time:   0.001733
 Self time:   0.001691

count  total (s)   self (s)
    1              0.000024   let pattern = substitute(escape(a:text, '\'), '\n', '\\n', 'g')
    1              0.000004   if s:use_word_boundary == 1
    1              0.000008       let pattern = '\<'.pattern.'\>'
    1              0.000002   endif
    1              0.000005   let pattern = '\V\C'.pattern
    1              0.000821   call search(pattern)
    1   0.000040   0.000018   let start = s:pos('.')
    1              0.000776   call search(pattern, 'ce')
    1   0.000038   0.000018   let end = s:pos('.')
    1              0.000005   return [start, end]

FUNCTION  gitgutter#diff#run_diff()
Called 68 times
Total time:   4.577833
 Self time:   0.202115

count  total (s)   self (s)
   97   0.007141   0.001793   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
   29   0.155600   0.155100     sleep 5m
   29              0.000337   endwhile
                            
   68   0.004352   0.000887   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
    4            186.630910     throw 'gitgutter not tracked'
                              endif
                            
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
   64              0.000249   let cmd = '('
                            
                              " Append buffer number to avoid race conditions between writing and reading
                              " the files when asynchronously processing multiple buffers.
                              "
                              " Without the buffer number, index_file would have a race in the shell
                              " between the second process writing it (with git-show) and the first
                              " reading it (with git-diff).
   64              0.000683   let index_file = s:temp_index.'.'.a:bufnr
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
   64              0.000567   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
   64   0.059579   0.001167   let extension = gitgutter#utility#extension(a:bufnr)
   64              0.000428   if !empty(extension)
                                let index_file .= '.'.extension
                                let buff_file .= '.'.extension
                              endif
                            
                              " Write file from index to temporary file.
   64   0.010416   0.001320   let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
   64              0.001057   let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.index_file.' && '
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
   64   0.866727   0.019856   call s:write_buffer(a:bufnr, buff_file)
                            
                              " Call git-diff with the temporary files.
   64              0.001303   let cmd .= g:gitgutter_git_executable.' --no-pager'
   64              0.000280   if s:c_flag
   64              0.000464     let cmd .= ' -c "diff.autorefreshindex=0"'
   64              0.000408     let cmd .= ' -c "diff.noprefix=false"'
   64              0.000425     let cmd .= ' -c "core.safecrlf=false"'
   64              0.000207   endif
   64              0.001106   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.index_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
   64              0.000754   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
   64   0.008176   0.001790     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
   64              0.000140   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
   64              0.000410   let cmd .= ' || exit 0'
                            
   64              0.000366   let cmd .= ')'
                            
   64   0.138369   0.001141   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
   64   0.001362   0.000967   if g:gitgutter_async && gitgutter#async#available()
   64   3.310702   0.002685     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
   64              0.000386     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>77__skip_file()
Called 6 times
Total time:   0.005566
 Self time:   0.003781

count  total (s)   self (s)
    6              0.000042     let fname = bufname(a:buf)
    6   0.005439   0.003654     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    6              0.000015     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    6              0.000014     return skip

FUNCTION  airline#parts#mode()
Called 961 times
Total time:   0.049587
 Self time:   0.016522

count  total (s)   self (s)
  961   0.048093   0.015028   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>228_GetCurrentCursorTag()
Called 662 times
Total time:   0.076267
 Self time:   0.076267

count  total (s)   self (s)
                                "returns the tag under the cursor, includes the '/' if on a closing tag.
                            
  662              0.003587     let c_col  = col('.')
  662              0.029750     let matched = matchstr(getline('.'), '\(<[^<>]*\%'.c_col.'c.\{-}>\)\|\(\%'.c_col.'c<.\{-}>\)')
  662              0.005581     if matched =~ '/>$'
                                    return ""
                                elseif matched == ""
                                    " The tag itself may be spread over multiple lines.
  100              0.002069         let matched = matchstr(getline('.'), '\(<[^<>]*\%'.c_col.'c.\{-}$\)\|\(\%'.c_col.'c<.\{-}$\)')
  100              0.000309         if matched == ""
  100              0.000177             return ""
                                    endif
                                endif
                            
                                " XML Tag definition is
                                "   (Letter | '_' | ':') (Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender)*
                                " Instead of dealing with CombiningChar and Extender, and because Vim's
                                " [:alpha:] only includes 8-bit characters, let's include all non-ASCII
                                " characters.
  562              0.015738     let tagname = matchstr(matched, '<\zs/\?\%([[:alpha:]_:]\|[^\x00-\x7F]\)\%([-._:[:alnum:]]\|[^\x00-\x7F]\)*')
  562              0.001690     return tagname

FUNCTION  <SNR>278_PrtFocusMap()
Called 1 time
Total time:   0.333489
 Self time:   0.000038

count  total (s)   self (s)
    1   0.333488   0.000037 	cal call(( s:focus ? 's:PrtAdd' : 's:PrtSelectJump' ), [a:char])

FUNCTION  <SNR>228_HighlightTagAtPosition()
Called 376 times
Total time:   0.025033
 Self time:   0.025033

count  total (s)   self (s)
  376              0.001917     if a:position == [0, 0]
  199              0.000315         return
                                endif
                            
  177              0.000798     let [m_lnum, m_col] = a:position
  177              0.019560     exe '2match MatchParen /\(\%' . m_lnum . 'l\%' . m_col .  'c<\zs.\{-}\ze[\n >]\)\|' .'\(\%' . line('.') . 'l\%' . col('.') .  'c<\zs.\{-}\ze[\n >]\)\|' .'\(\%' . line('.') . 'l<\zs[^<> ]*\%' . col('.') . 'c.\{-}\ze[\n >]\)\|' .'\(\%' . line('.') . 'l<\zs[^<>]\{-}\ze\s[^<>]*\%' . col('.') . 'c.\{-}[\n>]\)/'
  177              0.000667     let w:tag_hl_on = 1

FUNCTION  <SNR>278_PrtAdd()
Called 1 time
Total time:   0.333451
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000004 	unl! s:hstgot
    1              0.000004 	let s:act_add = 1
    1              0.000007 	let s:prompt[0] .= a:char
    1   0.333429   0.000019 	cal s:BuildPrompt(1)
    1              0.000003 	unl s:act_add

FUNCTION  <SNR>278_highlight()
Called 4 times
Total time:   0.001375
 Self time:   0.001272

count  total (s)   self (s)
    4              0.000031 	if s:matcher != {} | retu | en
    4              0.000017 	cal clearmatches()
    4              0.000017 	if !empty(a:pat) && s:ispath
    1              0.000002 		if s:regexp
                            			let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            			cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C' ).pat)
                            		el
    1              0.000003 			let pat = a:pat
                            
                            			" get original characters so we can rebuild pat
    1              0.000059 			let chars = split(pat, '\[\^\\\?.\]\\{-}')
                            
                            			" Build a pattern like /a.*b.*c/ from abc (but with .\{-} non-greedy
                            			" matchers instead)
    1              0.000008 			let pat = join(chars, '.\{-}')
                            			" Ensure we match the last version of our pattern
    1              0.000005 			let ending = '\(.*'.pat.'\)\@!'
                            			" Case sensitive?
    1              0.000007 			let beginning = ( s:martcs == '' ? '\c' : '\C' ).'^.*'
    1   0.000113   0.000010 			if s:byfname()
                            				" Make sure there are no slashes in our match
                            				let beginning = beginning.'\([^\/]*$\)\@='
                            			en
                            
    2              0.000011 			for i in range(len(chars))
                            				" Surround our current target letter with \zs and \ze so it only
                            				" actually matches that one letter, but has all preceding and trailing
                            				" letters as well.
                            				" \zsa.*b.*c
                            				" a\(\zsb\|.*\zsb)\ze.*c
    1              0.000006 				let charcopy = copy(chars)
    1              0.000003 				if i == 0
    1              0.000008 					let charcopy[i] = '\zs'.charcopy[i].'\ze'
    1              0.000007 					let middle = join(charcopy, '.\{-}')
    1              0.000003 				el
                            					let before = join(charcopy[0:i-1], '.\{-}')
                            					let after = join(charcopy[i+1:-1], '.\{-}')
                            					let c = charcopy[i]
                            					" for abc, match either ab.\{-}c or a.*b.\{-}c in that order
                            					let cpat = '\(\zs'.c.'\|'.'.*\zs'.c.'\)\ze.*'
                            					let middle = before.cpat.after
                            				en
                            
                            				" Now we matchadd for each letter, the basic form being:
                            				" ^.*\zsx\ze.*$, but with our pattern we built above for the letter,
                            				" and a negative lookahead ensuring that we only highlight the last
                            				" occurrence of our letters. We also ensure that our matcher is case
                            				" insensitive or sensitive depending.
    1              0.000033 				cal matchadd(a:grp, beginning.middle.ending)
    1              0.000003 			endfo
    1              0.000001 		en
                            
    1              0.000475 		cal matchadd('CtrlPLinePre', '^>')
    1              0.000025 	elseif !empty(a:pat) && s:regexp && exists('g:ctrlp_regex_always_higlight') && g:ctrlp_regex_always_higlight
                            		let pat = substitute(a:pat, '\\\@<!\^', '^> \\zs', 'g')
                            		cal matchadd(a:grp, ( s:martcs == '' ? '\c' : '\C').pat)
                            	en

FUNCTION  <SNR>63_exists_file()
Called 228 times
Total time:   0.464467
 Self time:   0.134432

count  total (s)   self (s)
  228   0.464001   0.133966   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>129_build_sections()
Called 79 times
Total time:   0.064047
 Self time:   0.009422

count  total (s)   self (s)
  400              0.001100   for key in a:keys
  321              0.001737     if (key == 'warning' || key == 'error') && !a:context.active
   10              0.000017       continue
                                endif
  311   0.058266   0.003641     call s:add_section(a:builder, a:context, key)
  311              0.000536   endfor

FUNCTION  airline#extensions#tabline#buflist#invalidate()
Called 30 times
Total time:   0.000339
 Self time:   0.000339

count  total (s)   self (s)
   30              0.000251   unlet! s:current_buffer_list

FUNCTION  494()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000016   call setreg('"', self.paste_buffer_text, self.paste_buffer_type)

FUNCTION  airline#extensions#quickfix#apply()
Called 40 times
Total time:   0.000819
 Self time:   0.000819

count  total (s)   self (s)
   40              0.000206   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  <SNR>278_compmatlen()
Called 108 times
Total time:   0.018783
 Self time:   0.004878

count  total (s)   self (s)
                            	" By match length
  108   0.009470   0.002101 	let mln1 = s:shortest(s:matchlens(a:1, s:compat))
  108   0.008514   0.001978 	let mln2 = s:shortest(s:matchlens(a:2, s:compat))
  108              0.000455 	retu mln1 == mln2 ? 0 : mln1 > mln2 ? 1 : -1

FUNCTION  gitgutter#async#execute()
Called 72 times
Total time:   3.647598
 Self time:   3.639252

count  total (s)   self (s)
   72   0.008403   0.001207   call gitgutter#debug#log('[async] '.a:cmd)
                            
   72              0.000973   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
   72   0.002257   0.001107   let command = s:build_command(a:cmd)
                            
   72              0.000639   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
   72              3.632373     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
   72              0.000697   endif

FUNCTION  gitgutter#diff#handler()
Called 4 times
Total time:   0.005281
 Self time:   0.000740

count  total (s)   self (s)
    4   0.000326   0.000039   call gitgutter#debug#log(a:diff)
                            
    4   0.000739   0.000109   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    4   0.000587   0.000150   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    4              0.000026   let signs_count = len(modified_lines)
    4              0.000015   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    4              0.000015     if g:gitgutter_signs || g:gitgutter_highlight_lines
    4   0.003073   0.000089       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    4              0.000004     endif
    4              0.000003   endif
                            
    4   0.000271   0.000068   call s:save_last_seen_change(a:bufnr)
    4              0.000066   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  368()
Called 25 times
Total time:   0.000447
 Self time:   0.000447

count  total (s)   self (s)
   25              0.000200     if !exists('b:syntastic_private_sign_ids')
    1              0.000004         let b:syntastic_private_sign_ids = []
    1              0.000001     endif
   25              0.000082     return b:syntastic_private_sign_ids

FUNCTION  <SNR>14_LoadFTPlugin()
Called 2 times
Total time:   0.080059
 Self time:   0.078976

count  total (s)   self (s)
    2              0.000015     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    2              0.000013     let s = expand("<amatch>")
    2              0.000006     if s != ""
    2              0.000031       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000029       for name in split(s, '\.')
    2   0.079887   0.078804 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    2              0.000016       endfor
    2              0.000003     endif

FUNCTION  <SNR>55_on_window_changed()
Called 30 times
Total time:   0.717880
 Self time:   0.002387

count  total (s)   self (s)
   30              0.000195   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   30              0.000590   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
   30              0.000452   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    5              0.000011     return
                              endif
   25              0.000151   let g:airline_last_window_changed = l:key
   25   0.000472   0.000287   call s:init()
   25   0.715571   0.000263   call airline#update_statusline()

FUNCTION  syntastic#util#fname2buf()
Called 49 times
Total time:   0.048515
 Self time:   0.048515

count  total (s)   self (s)
   49              0.000327     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
   49              0.000140     let buf = -1
   49              0.000330     for md in [':~:.', ':~', ':p']
   49              0.000087         try
                                        " Older versions of Vim can throw E94 here
   49              0.044437             let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
   49              0.000258         catch
                                        " catch everything
                                    endtry
   49              0.000143         if buf != -1
   49              0.000090             break
                                    endif
                                endfor
   49              0.000122     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
                                endif
                            
   49              0.000253     if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
   49              0.000099     return buf

FUNCTION  <SNR>252_bufferListContent()
Called 1 time
Total time:   0.001730
 Self time:   0.000188

count  total (s)   self (s)
    1              0.000004 	let content = []
                            
    1              0.000004 	if a:clv.Data.SubMode ==# "single"
    1   0.000099   0.000032 		let buffers = map(keys(ctrlspace#buffers#Buffers(tabpagenr())), "str2nr(v:val)")
    1              0.000003 	elseif a:clv.Data.SubMode ==# "all"
                            		let buffers = map(keys(ctrlspace#buffers#Buffers(0)), "str2nr(v:val)")
                            	elseif a:clv.Data.SubMode ==# "visible"
                            		let buffers = filter(map(keys(ctrlspace#buffers#Buffers(tabpagenr())), "str2nr(v:val)"), "bufwinnr(v:val) != -1")
                            	endif
                            
    4              0.000010 	for i in buffers
    3   0.001525   0.000050 		let entry = s:bufferEntry(i)
    3              0.000012 		if !empty(entry)
    3              0.000013 			call add(content, entry)
    3              0.000004 		endif
    3              0.000011 	endfor
                            
    1              0.000002 	return content

FUNCTION  ctrlspace#keys#common#Close()
Called 1 time
Total time:   0.213615
 Self time:   0.000055

count  total (s)   self (s)
    1   0.213612   0.000052 	call ctrlspace#window#Kill(0, 1)

FUNCTION  <SNR>278_compfnlen()
Called 108 times
Total time:   0.004189
 Self time:   0.004189

count  total (s)   self (s)
                            	" By filename length
  108              0.001782 	let len1 = strlen(split(a:1, s:lash)[-1])
  108              0.001554 	let len2 = strlen(split(a:2, s:lash)[-1])
  108              0.000504 	retu len1 == len2 ? 0 : len1 > len2 ? 1 : -1

FUNCTION  ctrlspace#keys#KeyNames()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000004 	return s:keyNames

FUNCTION  <SNR>277_handle_visual_IA_to_insert()
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000010   if !empty(s:saved_char) && s:char =~# 'v\|V' && s:to_mode ==# 'n'
                                if s:saved_char ==# 'I'
                                  call s:cm.reposition_all_within_region(1)
                                endif
                                call feedkeys(tolower(s:saved_char))
                                let s:saved_char = ''
                              endif

FUNCTION  499()
Called 17 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
   17              0.000114   return len(self.cursors)

FUNCTION  airline#extensions#wordcount#apply()
Called 37 times
Total time:   0.001831
 Self time:   0.001831

count  total (s)   self (s)
   37              0.001486   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  <SNR>77_BufReadPostHook()
Called 1 time
Total time:   0.000197
 Self time:   0.000051

count  total (s)   self (s)
    1   0.000138   0.000012     let buf = syntastic#util#fname2buf(a:fname)
    1              0.000003     if g:syntastic_check_on_open && buf > 0
    1   0.000041   0.000021         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
    1              0.000005         if index(s:_check_stack, buf) == -1
    1              0.000005             call add(s:_check_stack, buf)
    1              0.000002         endif
    1              0.000001     endif

FUNCTION  <SNR>77__ignore_file()
Called 6 times
Total time:   0.001583
 Self time:   0.001583

count  total (s)   self (s)
    6              0.001459     let fname = fnamemodify(a:filename, ':p')
    6              0.000037     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    6              0.000011     return 0

FUNCTION  <SNR>257__find_buffers_with_var()
Called 2 times
Total time:   0.000726
 Self time:   0.000726

count  total (s)   self (s)
    2              0.000011     let l:results = []
   12              0.000058     for l:bni in range(1, bufnr("$"))
   10              0.000068         if !bufexists(l:bni)
    2              0.000006             continue
                                    endif
    8              0.000070         let l:bvar = getbufvar(l:bni, "")
    8              0.000050         if empty(a:varname)
                                        call add(l:results, l:bni)
                                    elseif has_key(l:bvar, a:varname) && empty(a:expr)
                                        call add(l:results, l:bni)
                                    elseif has_key(l:bvar, a:varname) && l:bvar[a:varname] =~ a:expr
                                        call add(l:results, l:bni)
                                    endif
    8              0.000014     endfor
    2              0.000007     return l:results

FUNCTION  airline#extensions#tabline#builder#new()
Called 33 times
Total time:   0.002534
 Self time:   0.000982

count  total (s)   self (s)
   33   0.001903   0.000351   let builder = airline#builder#new(a:context)
   33              0.000147   let builder._build = builder.build
   33              0.000331   call extend(builder, s:prototype, 'force')
   33              0.000066   return builder

FUNCTION  ctrlp#clr()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000022 	let [s:matches, g:ctrlp_new{ a:0 ? a:1 : 'cache' }] = [1, 1]

FUNCTION  <SNR>278_dohighlight()
Called 4 times
Total time:   0.000114
 Self time:   0.000060

count  total (s)   self (s)
    4   0.000108   0.000054 	retu s:mathi[0] && exists('*clearmatches') && !ctrlp#nosy()

FUNCTION  gitgutter#utility#file()
Called 4 times
Total time:   0.003490
 Self time:   0.000054

count  total (s)   self (s)
    4   0.003486   0.000050   return s:abs_path(a:bufnr, 1)

FUNCTION  <SNR>12_isAnsible()
Called 1 time
Total time:   0.000441
 Self time:   0.000441

count  total (s)   self (s)
    1              0.000309   let filepath = expand("%:p")
    1              0.000008   let filename = expand("%:t")
    1              0.000027   if filepath =~ '\v/(tasks|roles|handlers)/.*\.ya?ml$' | return 1 | en
    1              0.000020   if filepath =~ '\v/(group|host)_vars/' | return 1 | en
    1              0.000022   if filename =~ '\v(playbook|site|main|local)\.ya?ml$' | return 1 | en
                            
    1              0.000008   let shebang = getline(1)
    1              0.000023   if shebang =~# '^#!.*/bin/env\s\+ansible-playbook\>' | return 1 | en
    1              0.000015   if shebang =~# '^#!.*/bin/ansible-playbook\>' | return 1 | en
                            
    1              0.000001   return 0

FUNCTION  <SNR>130__isDebugEnabled_smart()
Called 229 times
Total time:   0.001981
 Self time:   0.001981

count  total (s)   self (s)
  229              0.001692     return and(g:syntastic_debug, a:level)

FUNCTION  508()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005   return self.current_index == self.starting_index

FUNCTION  gitgutter#hunk#reset()
Called 67 times
Total time:   0.009521
 Self time:   0.002466

count  total (s)   self (s)
   67   0.004959   0.001348   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
   67   0.004286   0.000842   call s:reset_summary(a:bufnr)

FUNCTION  airline#extensions#apply()
Called 42 times
Total time:   0.008760
 Self time:   0.004260

count  total (s)   self (s)
   42              0.000242   let s:active_winnr = winnr()
                            
   42   0.004926   0.000426   if s:is_excluded_window()
                                return -1
                              endif
                            
   42              0.000187   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   42              0.000090   if &previewwindow
    4              0.000017     let w:airline_section_a = 'Preview'
    4              0.000013     let w:airline_section_b = ''
    4              0.000040     let w:airline_section_c = bufname(winbufnr(winnr()))
    4              0.000008   endif
                            
   42              0.000415   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
   42              0.000287   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  <SNR>278_curtype()
Called 175 times
Total time:   0.007446
 Self time:   0.001704

count  total (s)   self (s)
  175   0.007295   0.001553 	return s:CurTypeName()[1]

FUNCTION  <SNR>65_cpath()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000008   if exists('+fileignorecase') && &fileignorecase
    1              0.000007     return tolower(a:path)
                              else
                                return a:path
                              endif

FUNCTION  346()
Called 3 times
Total time:   0.001575
 Self time:   0.001103

count  total (s)   self (s)
    3   0.000107   0.000041     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   18              0.000044     for type in self._enabled_types
   15              0.000343         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   15              0.000128         if has_key(g:{class}, 'reset')
    9   0.000515   0.000109             call self._notifier[type].reset(a:loclist)
    9              0.000013         endif
                            
                                    " also reset stamps
   15              0.000084         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    6              0.000045             let b:syntastic_private_{type}_stamp = []
    6              0.000011         endif
   15              0.000022     endfor

FUNCTION  349()
Called 2 times
Total time:   0.000660
 Self time:   0.000165

count  total (s)   self (s)
    2   0.000072   0.000024     let registry = g:SyntasticRegistry.Instance()
                            
    2              0.000010     if has_key(a:args, 'redirect')
                                    let [ft, name] = split(a:args['redirect'], '/')
                                    call registry._loadCheckersFor(ft, 1)
                            
                                    let clone = get(registry._checkerMap[ft], name, {})
                                    if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
                                    let checker = g:SyntasticChecker.New(a:args, clone)
                                else
    2   0.000354   0.000026         let checker = g:SyntasticChecker.New(a:args)
    2              0.000002     endif
    2   0.000155   0.000036     call registry._registerChecker(checker)

FUNCTION  gitgutter#utility#is_active()
Called 231 times
Total time:   0.821437
 Self time:   0.015418

count  total (s)   self (s)
  231   0.820872   0.014853   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr) && !s:vimdiff(a:bufnr)

FUNCTION  265()
Called 9 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    9              0.000066 	let self.Data[a:key] = a:value
    9              0.000027 	return a:value

FUNCTION  266()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000008 	return has_key(self.Data, a:key)

FUNCTION  267()
Called 1 time
Total time:   0.000044
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000029   0.000019 	if self.HasData(a:key)
                            		call remove(self.Data, a:key)
                            		return 1
                            	endif
    1              0.000002 	return 0

FUNCTION  268()
Called 1 time
Total time:   0.000141
 Self time:   0.000113

count  total (s)   self (s)
    1              0.000005 	if self.ListView
    6              0.000018 		for m in s:lists
    5   0.000074   0.000046 			call m.Disable()
    5              0.000011 		endfor
                            
    1              0.000005 		let s:currentListView = self
    1              0.000002 	endif
                            
    1              0.000003 	let self.Enabled = 1

FUNCTION  269()
Called 10 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
   10              0.000043 	let self.Enabled = 0

FUNCTION  <SNR>129_get_section()
Called 432 times
Total time:   0.035622
 Self time:   0.032017

count  total (s)   self (s)
  432              0.002643   if has_key(s:section_truncate_width, a:key)
  311              0.001890     if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
  311              0.000345   endif
  432              0.001541   let spc = g:airline_symbols.space
  432              0.003897   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
  432   0.010371   0.006766   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  432              0.006194   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  432              0.003518   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>64_get_background_colors()
Called 4 times
Total time:   0.000836
 Self time:   0.000287

count  total (s)   self (s)
    4              0.000021   redir => highlight
    4              0.000117   silent execute 'silent highlight ' . a:group
    4              0.000017   redir END
                            
    4              0.000093   let link_matches = matchlist(highlight, 'links to \(\S\+\)')
    4              0.000017   if len(link_matches) > 0 " follow the link
    2              0.000019     return s:get_background_colors(link_matches[1])
                              endif
                            
    2   0.000106   0.000041   let ctermbg = s:match_highlight(highlight, 'ctermbg=\([0-9A-Za-z]\+\)')
    2   0.000073   0.000024   let guibg   = s:match_highlight(highlight, 'guibg=\([#0-9A-Za-z]\+\)')
    2              0.000007   return [guibg, ctermbg]

FUNCTION  ctrlspace#context#SymbolSizes()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003 	return s:symbolSizes

FUNCTION  <SNR>65_winshell()
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000026   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>257__get_split_mode()
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000021     if has_key(s:buffergator_viewport_split_modes, g:buffergator_viewport_split_policy)
    2              0.000015         return s:buffergator_viewport_split_modes[g:buffergator_viewport_split_policy]
                                else
                                    call s:_buffergator_messenger.send_error("Unrecognized split mode specified by 'g:buffergator_viewport_split_policy': " . g:buffergator_viewport_split_policy)
                                endif

FUNCTION  ctrlspace#api#TabBuffersNumber()
Called 23 times
Total time:   0.007624
 Self time:   0.001923

count  total (s)   self (s)
   23   0.006050   0.000349 	let buffersNumber = len(ctrlspace#api#Buffers(a:tabnr))
   23              0.000070 	let numberToShow  = ""
                            
   23              0.000049 	if buffersNumber > 1
   23              0.000062 		if s:config.UseUnicode
   23              0.000180 			let smallNumbers = ["⁰", "¹", "²", "³", "⁴", "⁵", "⁶", "⁷", "⁸", "⁹"]
   23              0.000160 			let numberStr    = string(buffersNumber)
                            
   46              0.000218 			for i in range(len(numberStr))
   23              0.000227 				let numberToShow .= smallNumbers[str2nr(numberStr[i])]
   23              0.000040 			endfor
   23              0.000028 		else
                            			let numberToShow = string(buffersNumber)
                            		endif
   23              0.000026 	endif
                            
   23              0.000048 	return numberToShow

FUNCTION  <SNR>278_mtype()
Called 3 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    3              0.000028 	retu s:itemtype >= len(s:coretypes) ? s:getextvar('type') : 'path'

FUNCTION  ctrlspace#modes#CurrentListView()
Called 4 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    4              0.000014 	return s:currentListView

FUNCTION  500()
Called 6 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    6              0.000051   return self.cursors[self.current_index]

FUNCTION  syntastic#util#setLastTick()
Called 6 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    6              0.000065     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  AutoPairsInsert()
Called 1 time
Total time:   0.000692
 Self time:   0.000692

count  total (s)   self (s)
    1              0.000014   if !b:autopairs_enabled
                                return a:key
                              end
                            
    1              0.000022   let line = getline('.')
    1              0.000019   let pos = col('.') - 1
    1              0.000010   let before = strpart(line, 0, pos)
    1              0.000008   let after = strpart(line, pos)
    1              0.000231   let next_chars = split(after, '\zs')
    1              0.000013   let current_char = get(next_chars, 0, '')
    1              0.000009   let next_char = get(next_chars, 1, '')
    1              0.000014   let prev_chars = split(before, '\zs')
    1              0.000008   let prev_char = get(prev_chars, -1, '')
                            
    1              0.000004   let eol = 0
    1              0.000012   if col('$') -  col('.') <= 1
                                let eol = 1
                              end
                            
                              " Ignore auto close if prev character is \
    1              0.000005   if prev_char == '\'
                                return a:key
                              end
                            
                              " The key is difference open-pair, then it means only for ) ] } by default
    1              0.000009   if !has_key(b:AutoPairs, a:key)
                                let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                                " Skip the character if current character is the same as input
                                if current_char == a:key
                                  return s:Right
                                end
                            
                                if !g:AutoPairsFlyMode
                                  " Skip the character if next character is space
                                  if current_char == ' ' && next_char == a:key
                                    return s:Right.s:Right
                                  end
                            
                                  " Skip the character if closed pair is next character
                                  if current_char == ''
                                    if g:AutoPairsMultilineClose
                                      let next_lineno = line('.')+1
                                      let next_line = getline(nextnonblank(next_lineno))
                                      let next_char = matchstr(next_line, '\s*\zs.')
                                    else
                                      let next_char = matchstr(line, '\s*\zs.')
                                    end
                                    if next_char == a:key
                                      return "\<ESC>e^a"
                                    endif
                                  endif
                                endif
                            
                                " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                                if g:AutoPairsFlyMode && has_key(b:AutoPairsClosedPairs, a:key)
                                  let n = stridx(after, a:key)
                                  if n != -1
                                    return repeat(s:Right, n+1)
                                  end
                                  if search(a:key, 'W')
                                    " force break the '.' when jump to different line
                                    return "\<Right>"
                                  endif
                                endif
                            
                                " Insert directly if the key is not an open key
                                return a:key
                              end
                            
    1              0.000004   let open = a:key
    1              0.000007   let close = b:AutoPairs[open]
                            
    1              0.000005   if current_char == close && open == close
                                return s:Right
                              end
                            
                              " Ignore auto close ' if follows a word
                              " MUST after closed check. 'hello|'
    1              0.000005   if a:key == "'" && prev_char =~ '\v\w'
                                return a:key
                              end
                            
                              " support for ''' ``` and """
    1              0.000004   if open == close
                                " The key must be ' " `
    1              0.000013     let pprev_char = line[col('.')-3]
    1              0.000010     if pprev_char == open && prev_char == open
                                  " Double pair found
                                  return repeat(a:key, 4) . repeat(s:Left, 3)
                                end
    1              0.000001   end
                            
    1              0.000004   let quotes_num = 0
                              " Ignore comment line for vim file
    1              0.000008   if &filetype == 'vim' && a:key == '"'
    1              0.000015     if before =~ '^\s*$'
    1              0.000005       return a:key
                                end
                                if before =~ '^\s*"'
                                  let quotes_num = -1
                                end
                              end
                            
                              " Keep quote number is odd.
                              " Because quotes should be matched in the same line in most of situation
                              if g:AutoPairsSmartQuotes && open == close
                                " Remove \\ \" \'
                                let cleaned_line = substitute(line, '\v(\\.)', '', 'g')
                                let n = quotes_num
                                let pos = 0
                                while 1
                                  let pos = stridx(cleaned_line, open, pos)
                                  if pos == -1
                                    break
                                  end
                                  let n = n + 1
                                  let pos = pos + 1
                                endwhile
                                if n % 2 == 1
                                  return a:key
                                endif
                              endif
                            
                              return open.close.s:Left

FUNCTION  airline#extensions#ctrlp#load_theme()
Called 9 times
Total time:   0.038975
 Self time:   0.001688

count  total (s)   self (s)
    9              0.000056   if exists('a:palette.ctrlp')
    2              0.000006     let theme = a:palette.ctrlp
    2              0.000002   else
    7              0.000063     let s:color_template = has_key(a:palette, s:color_template) ? s:color_template : 'insert'
    7   0.000419   0.000169     let theme = airline#extensions#ctrlp#generate_color_map( a:palette[s:color_template]['airline_c'], a:palette[s:color_template]['airline_b'], a:palette[s:color_template]['airline_a'])
    7              0.000013   endif
   69              0.000221   for key in keys(theme)
   60   0.037896   0.000859     call airline#highlighter#exec(key, theme[key])
   60              0.000103   endfor

FUNCTION  271()
Called 25 times
Total time:   0.005331
 Self time:   0.000613

count  total (s)   self (s)
   25   0.000821   0.000309     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
   25   0.004456   0.000250     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  272()
Called 25 times
Total time:   0.004206
 Self time:   0.002720

count  total (s)   self (s)
   25   0.000763   0.000285     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
   25   0.001035   0.000272     let auto_loc_list = syntastic#util#var('auto_loc_list')
   25   0.000369   0.000218     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
   25              0.000279         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
    3              0.000005             try
                                            " Vim 7.4.2200 or later
    3              0.000040                 let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
    3              0.000008             catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
    3              0.000018             if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
    3   0.000134   0.000040                 call SyntasticLoclistHide()
                            
    3              0.000005                 try
                                                " Vim 7.4.2200 or later
    3              0.000027                     call setloclist(0, [], 'r', { 'title': '' })
    3              0.000007                 catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
    3              0.000012                 let w:syntastic_loclist_set = []
    3              0.000004             endif
    3              0.000004         endif
   25              0.000036     endif

FUNCTION  274()
Called 25 times
Total time:   0.000338
 Self time:   0.000338

count  total (s)   self (s)
   25              0.000300     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  276()
Called 3 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    3              0.000018     let b:syntastic_private_balloons = {}
    3              0.000024     if has('balloon_eval')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    unlet! b:syntastic_private_balloons
                                    set noballooneval
                                endif

FUNCTION  277()
Called 2 times
Total time:   0.000328
 Self time:   0.000328

count  total (s)   self (s)
    2              0.000040     let newObj = copy(self)
                            
    2              0.000011     let newObj._filetype = a:args['filetype']
    2              0.000009     let newObj._name = a:args['name']
                            
    2              0.000004     if a:0
                                    " redirected checker
                                    let newObj._exec_default = get(a:args, 'exec', a:1['_exec_default'])
                            
                                    let filetype = a:1['_filetype']
                                    let name = a:1['_name']
                                    let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
                                    if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
                                else
    2              0.000016         let newObj._exec_default = get(a:args, 'exec', newObj._name)
    2              0.000007         if newObj._exec_default ==# ''
                                        let newObj._exec_default = '<dummy>'
                                    endif
    2              0.000017         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
    2              0.000009         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    endif
    2              0.000002     endif
                            
    2              0.000018     let newObj._locListFunc = function(prefix . 'GetLocList')
                            
    2              0.000015     if exists('*' . prefix . 'IsAvailable')
    1              0.000009         let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
    1              0.000002     else
    1              0.000009         let newObj._isAvailableFunc = function('s:_isAvailableDefault')
    1              0.000002     endif
                            
    2              0.000014     if exists('*' . prefix . 'GetHighlightRegex')
    1              0.000009         let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
    1              0.000001     endif
                            
    2              0.000004     return newObj

FUNCTION  278()
Called 5 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    5              0.000015     return self._filetype

FUNCTION  279()
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000005     return self._name

FUNCTION  <SNR>36_addtomrufs()
Called 48 times
Total time:   0.091955
 Self time:   0.081722

count  total (s)   self (s)
   48              0.037075 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
   48              0.000807 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
   48              0.012083 	let abs_fn = fnamemodify(fn,':p')
   48              0.028487 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
    1              0.000004 		retu
                            	en
   47              0.000733 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
   47              0.000109 	if idx
   22              0.000503 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
   22              0.000121 		cal insert(s:mrufs, fn)
   22              0.000130 		if {s:soup} && idx < 0
    1   0.010321   0.000088 			cal s:savetofile(s:mergelists())
    1              0.000001 		en
   22              0.000023 	en

FUNCTION  485()
Called 2 times
Total time:   0.000700
 Self time:   0.000400

count  total (s)   self (s)
    2              0.000049   let obj = copy(self)
    2              0.000019   let obj.position = copy(a:position)
    2              0.000009   let obj.visual = []
    2              0.000010   let obj.saved_visual = []
                              " Stores text that was yanked after any commands in Normal or Visual mode
    2              0.000020   let obj.paste_buffer_text = getreg('"')
    2              0.000017   let obj.paste_buffer_type = getregtype('"')
    2   0.000368   0.000068   let obj.cursor_hi_id = s:highlight_cursor(a:position)
    2              0.000011   let obj.visual_hi_id = 0
    2              0.000030   let obj.line_length = col([a:position[0], '$'])
    2              0.000017   if has('folding')
    2              0.000101     silent! execute a:position[0] . "foldopen!"
    2              0.000005   endif
    2              0.000006   return obj

FUNCTION  486()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007   return self.position[0]

FUNCTION  <SNR>278_glbpath()
Called 61 times
Total time:   0.026743
 Self time:   0.001193

count  total (s)   self (s)
   61   0.026661   0.001111 	retu call('ctrlp#utils#globpath', a:000)

FUNCTION  <SNR>252_prepareContent()
Called 1 time
Total time:   0.003222
 Self time:   0.003217

count  total (s)   self (s)
    1   0.000035   0.000030 	let sizes = ctrlspace#context#SymbolSizes()
                            
    1              0.000003 	if s:modes.File.Enabled
                            		let itemSpace = 5
                            	elseif s:modes.Bookmark.Enabled
                            		let itemSpace = 5 + sizes.IAV
                            	else
    1              0.000007 		let itemSpace = 5 + sizes.IAV + sizes.IM
    1              0.000001 	endif
                            
    1              0.000002 	let content  = ""
    1              0.000003 	let patterns = {}
    1              0.000002 	let indices  = []
                            
    4              0.000009 	for item in a:items
    3              0.000008 		let line = item.text
                            
    3              0.000022 		if strwidth(line) + itemSpace > &columns
                            			let line = s:config.Symbols.Dots . strpart(line, strwidth(line) - &columns + itemSpace + sizes.Dots)
                            		endif
                            
    3              0.000013 		if !empty(item.indicators)
    1              0.000006 			let line .= " " . item.indicators
    1              0.000001 		endif
                            
  290              0.001322 		while strwidth(line) < &columns
  287              0.000952 			let line .= " "
  287              0.000464 		endwhile
                            
    3              0.000018 		let content .= "  " . line . "\n"
                            
    3              0.000013 		if has_key(item, "pattern")
                            			let patterns[item.pattern] = 1
                            		endif
                            
    3              0.000014 		call add(indices, item.index)
    3              0.000005 	endfor
                            
    1              0.000009 	return [keys(patterns), indices, len(a:items), content]

FUNCTION  <SNR>200_on_exit_untracked()
Called 5 times
Total time:   0.000675
 Self time:   0.000393

count  total (s)   self (s)
    5   0.000552   0.000270     call s:untracked_output(self, self.buf)
    5              0.000041     if has_key(s:untracked_jobs, self.file)
    5              0.000042       call remove(s:untracked_jobs, self.file)
    5              0.000008     endif

FUNCTION  gitgutter#sign#update_signs()
Called 4 times
Total time:   0.002984
 Self time:   0.000522

count  total (s)   self (s)
    4   0.001234   0.000076   call s:find_current_signs(a:bufnr)
                            
    4              0.000042   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    4   0.000443   0.000109   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    4              0.000030   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    4              0.000010   if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
    4   0.000514   0.000074   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    4   0.000606   0.000076   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    4              0.000010   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif

FUNCTION  <SNR>77_ClearCache()
Called 3 times
Total time:   0.002305
 Self time:   0.000109

count  total (s)   self (s)
    3   0.000302   0.000037     let loclist = g:SyntasticLoclist.current(a:buf)
    3   0.001609   0.000034     call s:notifiers.reset(loclist)
    3   0.000387   0.000031     call loclist.destroy()

FUNCTION  ctrlspace#window#MaxHeight()
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000005 	let maxFromConfig = s:config.MaxHeight
                            
    1              0.000002 	if maxFromConfig
                            		return maxFromConfig
                            	else
    1              0.000002 		return &lines / 3
                            	endif

FUNCTION  <SNR>65_sub()
Called 460 times
Total time:   0.018792
 Self time:   0.018792

count  total (s)   self (s)
  460              0.017889   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 52 times
Total time:   0.040629
 Self time:   0.003788

count  total (s)   self (s)
   52              0.000519   if getbufvar(a:bufnr, '&modified')
   25              0.000519     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   25              0.000041   else
   27              0.000568     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   27              0.000046   endif
                            
   52              0.000203   if !empty(colors)
   52   0.037878   0.001037     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   52              0.000069   endif

FUNCTION  <SNR>128_get_accented_line()
Called 527 times
Total time:   0.060054
 Self time:   0.060054

count  total (s)   self (s)
  527              0.001657   if a:self._context.active
  507              0.001700     let contents = []
  507              0.007492     let content_parts = split(a:contents, '__accent')
 1110              0.003342     for cpart in content_parts
  603              0.014120       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  603              0.003664       call add(contents, cpart)
  603              0.001288     endfor
  507              0.003832     let line = join(contents, a:group)
  507              0.007153     let line = substitute(line, '__restore__', a:group, 'g')
  507              0.000790   else
   20              0.000723     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   20              0.000303     let line = substitute(line, '%#__restore__#', '', 'g')
   20              0.000037   endif
  527              0.001119   return line

FUNCTION  syntastic#util#setWids()
Called 1 time
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
    2              0.000013     for tab in range(1, tabpagenr('$'))
    2              0.000010         for win in range(1, tabpagewinnr(tab, '$'))
    1              0.000007             if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
    1              0.000012                 call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
    1              0.000005                 let s:_wid_pool += 1
    1              0.000002             endif
    1              0.000001         endfor
    1              0.000001     endfor

FUNCTION  <SNR>257_NewBufferCatalogViewer()
Called 1 time
Total time:   0.002779
 Self time:   0.001008

count  total (s)   self (s)
                            
                                " initialize
    1   0.001829   0.000058     let catalog_viewer = s:NewCatalogViewer("[[buffergator-buffers]]", "buffergator")
    1              0.000011     let catalog_viewer["calling_bufnum"] = -1
    1              0.000010     let catalog_viewer["buffers_catalog"] = {}
    1              0.000010     let catalog_viewer["current_buffer_index"] = -1
                            
                                " Populates the buffer list
    1              0.000004     function! catalog_viewer.update_buffers_info() dict
                                    let self.buffers_catalog = self.list_buffers()
                                    return self.buffers_catalog
                                endfunction
                            
                                " Opens the buffer for viewing, creating it if needed.
                                " First argument, if given, should be false if the buffers info is *not*
                                " to be repopulated; defaults to 1
                                " Second argument, if given, should be number of calling window.
    1              0.000004     function! catalog_viewer.open(...) dict
                                    " populate data
                                    if (a:0 == 0 || a:1 > 0)
                                        call self.update_buffers_info()
                                    endif
                                    " store calling buffer
                                    if (a:0 >= 2 && a:2)
                                        let self.calling_bufnum = a:2
                                    else
                                        let self.calling_bufnum = bufnr("%")
                                    endif
                                    " get buffer number of the catalog view buffer, creating it if neccessary
                                    if self.bufnum < 0 || !bufexists(self.bufnum)
                                        " create and render a new buffer
                                        call self.create_buffer()
                                    else
                                        " buffer exists: activate a viewport on it according to the
                                        " spawning mode, re-rendering the buffer with the catalog if needed
                                        call self.activate_viewport()
                                        call self.render_buffer()
                                        " if (a:0 > 0 && a:1) || b:buffergator_catalog_viewer != self
                                        "     call self.render_buffer()
                                        " else
                                        "     " search for calling buffer number in jump map,
                                        "     " when found, go to that line
                                        " endif
                                    endif
                                endfunction
                            
                            
                                " Sets buffer syntax.
    1              0.000004     function! catalog_viewer.setup_buffer_syntax() dict
                                    if has("syntax") && (!exists('b:did_syntax') || !b:did_syntax)
                                        syntax clear
                                        syn region BuffergatorFileLine start='^' keepend oneline end='$'
                                        syn match BuffergatorBufferNr '^\[.\{3\}\]' containedin=BuffergatorFileLine
                                        let l:line_symbols = values(s:buffergator_buffer_line_symbols)
                                        execute "syn match BuffergatorSymbol '[" . join(l:line_symbols,"") . "]' containedin=BuffergatorFileLine"
                                        for l:buffer_status_index in range(0, len(s:buffergator_buffer_line_symbols_order) - 1)
                                          let l:name = s:buffergator_buffer_line_symbols_order[l:buffer_status_index]
                                          let l:line_symbol = s:buffergator_buffer_line_symbols[l:name]
                                          let l:pattern = repeat('.', l:buffer_status_index)
                                          let l:pattern .= l:line_symbol
                                          let l:pattern .= repeat('.', len(s:buffergator_buffer_line_symbols_order) - (l:buffer_status_index + 1))
                                          let l:pattern .= '\s.\{-}/'
                                          let l:pattern_name = "Buffergator" . toupper(l:name[0]) . tolower(l:name[1:]) . "Entry"
                                          let l:element = [ "syn match", l:pattern_name, "'" . l:pattern . "'me=e-1", "containedin=BuffergatorFileLine", "contains=BuffergatorSymbol" ]
                                          let l:syntax_cmd = join(l:element," ")
                                          execute l:syntax_cmd
                                        endfor
                                        highlight link BuffergatorSymbol Constant
                                        " highlight link BuffergatorAlternateEntry Function
                                        " highlight link BuffergatorModifiedEntry String
                                        " highlight link BuffergatorCurrentEntry Keyword
                                        highlight link BuffergatorBufferNr LineNr
                                        let b:did_syntax = 1
                                    endif
                                  endfunction
                            
                                " Sets buffer key maps.
    1              0.000004     function! catalog_viewer.setup_buffer_keymaps() dict
                            
                                    call self.disable_editing_keymaps()
                            
                                    if !exists("g:buffergator_use_new_keymap") || !g:buffergator_use_new_keymap
                            
                                        """" Catalog management
                                        noremap <buffer> <silent> cs          :call b:buffergator_catalog_viewer.cycle_sort_regime()<CR>
                                        noremap <buffer> <silent> cd          :call b:buffergator_catalog_viewer.cycle_display_regime()<CR>
                                        noremap <buffer> <silent> cp          :call b:buffergator_catalog_viewer.cycle_directory_path_display()<CR>
                                        noremap <buffer> <silent> cw          :call b:buffergator_catalog_viewer.cycle_viewport_modes()<CR>
                                        noremap <buffer> <silent> cq          :call b:buffergator_catalog_viewer.cycle_autodismiss_modes()<CR>
                                        noremap <buffer> <silent> cc          <NOP>
                                        noremap <buffer> <silent> r           :call b:buffergator_catalog_viewer.rebuild_catalog()<CR>
                                        noremap <buffer> <silent> q           :call b:buffergator_catalog_viewer.close(1)<CR>
                                        noremap <buffer> <silent> d           :<C-U>call b:buffergator_catalog_viewer.delete_target(0, 0)<CR>
                                        noremap <buffer> <silent> D           :<C-U>call b:buffergator_catalog_viewer.delete_target(0, 1)<CR>
                                        noremap <buffer> <silent> x           :<C-U>call b:buffergator_catalog_viewer.delete_target(1, 0)<CR>
                                        noremap <buffer> <silent> X           :<C-U>call b:buffergator_catalog_viewer.delete_target(1, 1)<CR>
                            
                                        """"" Selection: show target and switch focus
                                        noremap <buffer> <silent> <CR>        :<C-U>call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "")<CR>
                                        noremap <buffer> <silent> o           :<C-U>call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "")<CR>
                                        noremap <buffer> <silent> <LeftMouse> :<C-U>call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "")<CR>
                                        noremap <buffer> <silent> s           :<C-U>call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "vert sb")<CR>
                                        noremap <buffer> <silent> <C-v>       :<C-U>call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "vert sb")<CR>
                                        noremap <buffer> <silent> i           :<C-U>call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "sb")<CR>
                                        noremap <buffer> <silent> <C-s>       :<C-U>call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "sb")<CR>
                                        noremap <buffer> <silent> t           :<C-U>call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "tab sb")<CR>
                                        noremap <buffer> <silent> <C-t>       :<C-U>call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "tab sb")<CR>
                            
                                        """"" Selection: show target and switch focus, preserving the catalog regardless of the autodismiss setting
                                        noremap <buffer> <silent> po          :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 0, "")<CR>
                                        noremap <buffer> <silent> ps          :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 0, "vert sb")<CR>
                                        noremap <buffer> <silent> pi          :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 0, "sb")<CR>
                                        noremap <buffer> <silent> pt          :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 0, "tab sb")<CR>
                            
                                        """"" Preview: show target , keeping focus on catalog
                                        noremap <buffer> <silent> O           :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 1, "")<CR>
                                        noremap <buffer> <silent> go          :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 1, "")<CR>
                                        noremap <buffer> <silent> S           :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 1, "vert sb")<CR>
                                        noremap <buffer> <silent> gs          :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 1, "vert sb")<CR>
                                        noremap <buffer> <silent> I           :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 1, "sb")<CR>
                                        noremap <buffer> <silent> gi          :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 1, "sb")<CR>
                                        noremap <buffer> <silent> T           :<C-U>call b:buffergator_catalog_viewer.visit_target(1, 1, "tab sb")<CR>
                                        noremap <buffer> <silent> <SPACE>     :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("n", 1, 1)<CR>
                                        noremap <buffer> <silent> <C-SPACE>   :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("p", 1, 1)<CR>
                                        noremap <buffer> <silent> <C-@>       :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("p", 1, 1)<CR>
                                        noremap <buffer> <silent> <C-N>       :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("n", 1, 1)<CR>
                                        noremap <buffer> <silent> <C-P>       :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("p", 1, 1)<CR>
                            
                                        """"" Preview: go to existing window showing target
                                        noremap <buffer> <silent> E           :<C-U>call b:buffergator_catalog_viewer.visit_open_target(1, !g:buffergator_autodismiss_on_select, "")<CR>
                                        noremap <buffer> <silent> eo          :<C-U>call b:buffergator_catalog_viewer.visit_open_target(0, !g:buffergator_autodismiss_on_select, "")<CR>
                                        noremap <buffer> <silent> es          :<C-U>call b:buffergator_catalog_viewer.visit_open_target(0, !g:buffergator_autodismiss_on_select, "vert sb")<CR>
                                        noremap <buffer> <silent> ei          :<C-U>call b:buffergator_catalog_viewer.visit_open_target(0, !g:buffergator_autodismiss_on_select, "sb")<CR>
                                        noremap <buffer> <silent> et          :<C-U>call b:buffergator_catalog_viewer.visit_open_target(0, !g:buffergator_autodismiss_on_select, "tab sb")<CR>
                            
                                    else
                            
                                        """" Catalog management
                                        noremap <buffer> <silent> s           :call b:buffergator_catalog_viewer.cycle_sort_regime()<CR>
                                        noremap <buffer> <silent> i           :call b:buffergator_catalog_viewer.cycle_display_regime()<CR>
                                        noremap <buffer> <silent> u           :call b:buffergator_catalog_viewer.rebuild_catalog()<CR>
                                        noremap <buffer> <silent> q           :call b:buffergator_catalog_viewer.close(1)<CR>
                                        noremap <buffer> <silent> d           :call b:buffergator_catalog_viewer.delete_target(0, 0)<CR>
                                        noremap <buffer> <silent> D           :call b:buffergator_catalog_viewer.delete_target(0, 1)<CR>
                                        noremap <buffer> <silent> x           :call b:buffergator_catalog_viewer.delete_target(1, 0)<CR>
                                        noremap <buffer> <silent> X           :call b:buffergator_catalog_viewer.delete_target(1, 1)<CR>
                            
                                        " open target
                                        noremap <buffer> <silent> <CR>  :call b:buffergator_catalog_viewer.visit_target(!g:buffergator_autodismiss_on_select, 0, "")<CR>
                            
                                        " show target line in other window, keeping catalog open and in focus
                                        noremap <buffer> <silent> .           :call b:buffergator_catalog_viewer.visit_target(1, 1, "")<CR>
                                        noremap <buffer> <silent> po          :call b:buffergator_catalog_viewer.visit_target(1, 1, "")<CR>
                                        noremap <buffer> <silent> ps          :call b:buffergator_catalog_viewer.visit_target(1, 1, "sb")<CR>
                                        noremap <buffer> <silent> pv          :call b:buffergator_catalog_viewer.visit_target(1, 1, "vert sb")<CR>
                                        noremap <buffer> <silent> pt          :call b:buffergator_catalog_viewer.visit_target(1, 1, "tab sb")<CR>
                                        noremap <buffer> <silent> <SPACE>     :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("n", 1, 1)<CR>
                                        noremap <buffer> <silent> <C-SPACE>   :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("p", 1, 1)<CR>
                                        noremap <buffer> <silent> <C-@>       :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("p", 1, 1)<CR>
                                        noremap <buffer> <silent> <C-N>       :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("n", 1, 1)<CR>
                                        noremap <buffer> <silent> <C-P>       :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("p", 1, 1)<CR>
                            
                                        " go to target line in other window, keeping catalog open
                                        noremap <buffer> <silent> o           :call b:buffergator_catalog_viewer.visit_target(1, 0, "")<CR>
                                        noremap <buffer> <silent> ws          :call b:buffergator_catalog_viewer.visit_target(1, 0, "sb")<CR>
                                        noremap <buffer> <silent> wv          :call b:buffergator_catalog_viewer.visit_target(1, 0, "vert sb")<CR>
                                        noremap <buffer> <silent> t           :call b:buffergator_catalog_viewer.visit_target(1, 0, "tab sb")<CR>
                            
                                        " open target line in other window, closing catalog
                                        noremap <buffer> <silent> O           :call b:buffergator_catalog_viewer.visit_target(0, 0, "")<CR>
                                        noremap <buffer> <silent> wS          :call b:buffergator_catalog_viewer.visit_target(0, 0, "sb")<CR>
                                        noremap <buffer> <silent> wV          :call b:buffergator_catalog_viewer.visit_target(0, 0, "vert sb")<CR>
                                        noremap <buffer> <silent> T           :call b:buffergator_catalog_viewer.visit_target(0, 0, "tab sb")<CR>
                            
                                    endif
                            
                                    " other
                                    noremap <buffer> <silent> A           :call b:buffergator_catalog_viewer.toggle_zoom()<CR>
                            
                                    if g:buffergator_remap_arrow_keys
                                        noremap <buffer> <UP>     <UP>
                                        noremap <buffer> <DOWN>   <DOWN>
                                    endif
                            
                                endfunction
                            
                                " Populates the buffer with the catalog index.
    1              0.000003     function! catalog_viewer.render_buffer() dict
                                    setlocal modifiable
                                    call self.claim_buffer()
                                    call self.clear_buffer()
                                    call self.setup_buffer_syntax()
                                    let self.jump_map = {}
                                    let l:initial_line = 1
                                    for l:bufinfo in self.buffers_catalog
                                        if self.calling_bufnum == l:bufinfo.bufnum
                                            let l:initial_line = line("$")
                                        endif
                            
                                        if l:bufinfo.is_current
                                          let self.current_buffer_index = line("$")
                                        endif
                            
                                        let l:bufnum_str = s:_format_filled(l:bufinfo.bufnum, 3, 1, 0)
                                        let l:line = "[" . l:bufnum_str . "]"
                            
                                        let l:line .= s:_format_filled(self.line_symbols(l:bufinfo),4,-1,0)
                            
                                        if self.display_regime == "basename"
                                            let l:line .= s:_format_align_left(l:bufinfo.basename, self.max_buffer_basename_len, " ")
                                            let l:line .= "  "
                                            let l:line .= l:bufinfo.parentdir
                                        elseif self.display_regime == "parentdir"
                                            let l:line .= s:_format_align_left(l:bufinfo.basename, self.max_buffer_basename_len, " ")
                                            let l:line .= "  "
                                            let l:line .= fnamemodify(l:bufinfo.parentdir, ':p:h:t')
                                        elseif self.display_regime == "filepath"
                                            let l:line .= l:bufinfo.filepath
                                        elseif self.display_regime == "bufname"
                                            let l:line .= l:bufinfo.bufname
                                        else
                                            throw s:_buffergator_messenger.format_exception("Invalid display regime: '" . self.display_regime . "'")
                                        endif
                                        call self.append_line(l:line, l:bufinfo.bufnum)
                                    endfor
                                    let b:buffergator_last_render_time = localtime()
                                    try
                                        " remove extra last line
                                        execute('normal! GV"_X')
                                    catch //
                                    endtry
                                    setlocal nomodifiable
                                    call cursor(l:initial_line, 1)
                                    " call self.goto_index_entry("n", 0, 1)
                                endfunction
                            
                                " Visits the specified buffer in the previous window, if it is already
                                " visible there. If not, then it looks for the first window with the
                                " buffer showing and visits it there. If no windows are showing the
                                " buffer, ... ?
    1              0.000005     function! catalog_viewer.visit_buffer(bufnum, split_cmd) dict
                                    " acquire window
                                    let l:split_cmd = self.acquire_viewport(a:split_cmd)
                                    " switch to buffer in acquired window
                                    let l:old_switch_buf = &switchbuf
                                    if empty(l:split_cmd)
                                        " explicit split command not given: switch to buffer in current
                                        " window
                                        let &switchbuf="useopen"
                                        execute("silent buffer " . a:bufnum)
                                    else
                                        " explcit split command given: split current window
                                        let &switchbuf="split"
                                        execute("silent keepalt keepjumps " . l:split_cmd . " " . a:bufnum)
                                    endif
                                    let &switchbuf=l:old_switch_buf
                                endfunction
                            
    1              0.000005     function! catalog_viewer.get_target_bufnum(cmd_count) dict
                                    if a:cmd_count == 0
                                        let l:cur_line = line(".")
                                        if !has_key(l:self.jump_map, l:cur_line)
                                            call s:_buffergator_messenger.send_info("Not a valid navigation line")
                                            return -1
                                        endif
                                        let [l:jump_to_bufnum] = self.jump_map[l:cur_line].target
                                        return l:jump_to_bufnum
                                    else
                                        let l:jump_to_bufnum = a:cmd_count
                                        if bufnr(l:jump_to_bufnum) == -1
                                            call s:_buffergator_messenger.send_info("Not a valid buffer number: " . string(l:jump_to_bufnum) )
                                            return -1
                                        endif
                                        for lnum in range(1, line("$"))
                                            if self.jump_map[lnum].target[0] == l:jump_to_bufnum
                                                call cursor(lnum, 1)
                                                return l:jump_to_bufnum
                                            endif
                                        endfor
                                        call s:_buffergator_messenger.send_info("Not a listed buffer number: " . string(l:jump_to_bufnum) )
                                        return -1
                                    endif
                                endfunction
                            
                                " Go to the selected buffer.
    1              0.000005     function! catalog_viewer.visit_target(keep_catalog, refocus_catalog, split_cmd) dict range
                                    let l:jump_to_bufnum = self.get_target_bufnum(v:count)
                                    if l:jump_to_bufnum == -1
                                        return 0
                                    endif
                                    let l:cur_tab_num = tabpagenr()
                                    if (self.split_mode != "buffer" || !empty(a:split_cmd)) && !a:keep_catalog
                                        call self.close(0)
                                    endif
                                    call self.visit_buffer(l:jump_to_bufnum, a:split_cmd)
                                    if a:keep_catalog && a:refocus_catalog
                                        execute("tabnext " . l:cur_tab_num)
                                        execute(bufwinnr(self.bufnum) . "wincmd w")
                                    endif
                                    call s:_buffergator_messenger.send_info(expand(bufname(l:jump_to_bufnum)))
                                endfunction
                            
                                " Go to the selected buffer, preferentially using a window that already is
                                " showing it; if not, create a window using split_cmd
    1              0.000005     function! catalog_viewer.visit_open_target(unconditional, keep_catalog, split_cmd) dict range
                                    let l:jump_to_bufnum = self.get_target_bufnum(v:count)
                                    if l:jump_to_bufnum == -1
                                        return 0
                                    endif
                                    let wnr = bufwinnr(l:jump_to_bufnum)
                                    if wnr != -1
                                        execute(wnr . "wincmd w")
                                        if !a:keep_catalog
                                            call self.close(0)
                                        endif
                                        return
                                    endif
                                    let l:cur_tab_num = tabpagenr()
                                    for tabnum in range(1, tabpagenr('$'))
                                        execute("tabnext " . tabnum)
                                        let wnr = bufwinnr(l:jump_to_bufnum)
                                        if wnr != -1
                                            execute(wnr . "wincmd w")
                                            if !a:keep_catalog
                                                call self.close(0)
                                            endif
                                            return
                                        endif
                                    endfor
                                    execute("tabnext " . l:cur_tab_num)
                                    if !a:unconditional
                                        call self.visit_target(a:keep_catalog, 0, a:split_cmd)
                                    endif
                                endfunction
                            
    1              0.000004     function! catalog_viewer.delete_target(wipe, force) dict range
                                    let l:bufnum_to_delete = self.get_target_bufnum(v:count)
                                    if l:bufnum_to_delete == -1
                                        return 0
                                    endif
                                    if !bufexists(l:bufnum_to_delete)
                                        call s:_buffergator_messenger.send_info("Not a valid or existing buffer")
                                        return 0
                                    endif
                                    if a:wipe && a:force
                                        let l:operation_desc = "unconditionally wipe"
                                        let l:cmd = "bw!"
                                    elseif a:wipe && !a:force
                                        let l:operation_desc = "wipe"
                                        let l:cmd = "bw"
                                    elseif !a:wipe && a:force
                                        let l:operation_desc = "unconditionally delete"
                                        let l:cmd = "bd!"
                                    elseif !a:wipe && !a:force
                                        let l:operation_desc = "delete"
                                        let l:cmd = "bd"
                                    endif
                            
                                    " store current window number
                                    let l:cur_win_num = winnr()
                            
                                    " find alternate buffer to switch to
                                    " let l:alternate_buffer = -1
                                    " for abufnum in range(l:bufnum_to_delete, 1, -1)
                                    "     if bufexists(abufnum) && buflisted(abufnum) && abufnum != l:bufnum_to_delete
                                    "         let l:alternate_buffer = abufnum
                                    "         break
                                    "     endif
                                    " endfor
                                    " if l:alternate_buffer == -1 && bufnr("$") > l:bufnum_to_delete
                                    "     for abufnum in range(l:bufnum_to_delete+1, bufnr("$"))
                                    "         if bufexists(abufnum) && buflisted(abufnum) && abufnum != l:bufnum_to_delete
                                    "             let l:alternate_buffer = abufnum
                                    "             break
                                    "         endif
                                    "     endfor
                                    " endif
                                    " if l:alternate_buffer == -1
                                    "     call s:_buffergator_messenger.send_warning("Cowardly refusing to delete last listed buffer")
                                    "     return 0
                                    " endif
                            
                                    call self.update_buffers_info()
                                    if len(self.buffers_catalog) == 1
                                        if self.buffers_catalog[0].bufnum == l:bufnum_to_delete
                                            call s:_buffergator_messenger.send_warning("Cowardly refusing to delete last listed buffer")
                                            return 0
                                        else
                                            call s:_buffergator_messenger.send_warning("Buffer not found")
                                            return 0
                                        endif
                                    endif
                                    let l:alternate_buffer = -1
                                    for xbi in range(0, len(self.buffers_catalog)-1)
                                        let curbf = self.buffers_catalog[xbi].bufnum
                                        if curbf == l:bufnum_to_delete
                                            if xbi == len(self.buffers_catalog)-1
                                                if xbi > 0
                                                    let l:alternate_buffer = self.buffers_catalog[xbi-1].bufnum
                                                else
                                                    call s:_buffergator_messenger.send_warning("Cowardly refusing to delete last listed buffer")
                                                    return 0
                                                endif
                                            else
                                                if xbi+1 < len(self.buffers_catalog)
                                                    let l:alternate_buffer = self.buffers_catalog[xbi+1].bufnum
                                                else
                                                    call s:_buffergator_messenger.send_warning("Cowardly refusing to delete last listed buffer")
                                                    return 0
                                                endif
                                            endif
                                            break
                                        endif
                                    endfor
                            
                                    let l:changed_win_bufs = []
                                    for winnum in range(1, winnr('$'))
                                        let wbufnum = winbufnr(winnum)
                                        if wbufnum == l:bufnum_to_delete
                                            call add(l:changed_win_bufs, winnum)
                                            execute(winnum . "wincmd w")
                                            execute("silent keepalt keepjumps buffer " . l:alternate_buffer)
                                        endif
                                    endfor
                            
                                    let l:bufname = expand(bufname(l:bufnum_to_delete))
                                    try
                                        execute(l:cmd . string(l:bufnum_to_delete))
                                        call self.open(1, l:alternate_buffer)
                                        let l:message = l:bufname . " " . l:operation_desc . "d"
                                        call s:_buffergator_messenger.send_info(l:message)
                                    catch /E89/
                                        for winnum in l:changed_win_bufs
                                            execute(winnum . "wincmd w")
                                            execute("silent keepalt keepjumps buffer " . l:bufnum_to_delete)
                                        endfor
                                        execute(l:cur_win_num . "wincmd w")
                                        let l:message = 'Failed to ' . l:operation_desc . ' "' . l:bufname . '" because it is modified; use unconditional version of this command to force operation'
                                        call s:_buffergator_messenger.send_error(l:message)
                                    catch //
                                        for winnum in l:changed_win_bufs
                                            execute(winnum . "wincmd w")
                                            execute("silent keepalt keepjumps buffer " . l:bufnum_to_delete)
                                        endfor
                                        execute(l:cur_win_num . "wincmd w")
                                        let l:message = 'Failed to ' . l:operation_desc . ' "' . l:bufname . '"'
                                        call s:_buffergator_messenger.send_error(l:message)
                                    endtry
                            
                                endfunction
                            
                                " Finds next line with occurrence of a rendered index
    1              0.000005     function! catalog_viewer.goto_index_entry(direction, visit_target, refocus_catalog) dict range
                                    if v:count > 0
                                        let l:target_bufnum = v:count
                                        if bufnr(l:target_bufnum) == -1
                                            call s:_buffergator_messenger.send_info("Not a valid buffer number: " . string(l:target_bufnum) )
                                            return -1
                                        endif
                                        let l:ok = 0
                                        for lnum in range(1, line("$"))
                                            if self.jump_map[lnum].target[0] == l:target_bufnum
                                                call cursor(lnum, 1)
                                                let l:ok = 1
                                                break
                                            endif
                                        endfor
                                        if !l:ok
                                            call s:_buffergator_messenger.send_info("Not a listed buffer number: " . string(l:target_bufnum) )
                                            return -1
                                        endif
                                    else
                                        let l:ok = self.goto_pattern("^\[", a:direction)
                                        execute("normal! zz")
                                    endif
                                    if l:ok && a:visit_target
                                        call self.visit_target(1, a:refocus_catalog, "")
                                    endif
                                endfunction
                            
                                " Sets buffer status line.
    1              0.000004     function! catalog_viewer.setup_buffer_statusline() dict
                                    if g:buffergator_window_statusline
                                        setlocal statusline=%{BuffergatorBuffersStatusLine()}
                                    endif
                                endfunction
                            
                                " Appends a line to the buffer and registers it in the line log.
    1              0.000005     function! catalog_viewer.append_line(text, jump_to_bufnum) dict
                                    let l:line_map = { "target" : [a:jump_to_bufnum], }
                                    if a:0 > 0
                                        call extend(l:line_map, a:1)
                                    endif
                                    let self.jump_map[line("$")] = l:line_map
                                    call append(line("$")-1, a:text)
                                endfunction
                            
                                " return object
    1              0.000004     return catalog_viewer
                            
                            

FUNCTION  airline#init#gui_mode()
Called 2 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000033   return has('gui_running') || (has("termguicolors") && &termguicolors == 1) ?  'gui' : 'cterm'

FUNCTION  airline#extensions#branch#get_head()
Called 961 times
Total time:   2.235321
 Self time:   0.044263

count  total (s)   self (s)
  961   2.202176   0.011118   let head = airline#extensions#branch#head()
  961              0.008384   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
  961              0.008922   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  961              0.012735   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  fugitive#head()
Called 961 times
Total time:   0.568987
 Self time:   0.019657

count  total (s)   self (s)
  961              0.005582   if !exists('b:git_dir')
  513              0.000972     return ''
                              endif
                            
  448   0.558583   0.009253   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  280()
Called 4 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    4              0.000023     return self._filetype . '/' . self._name

FUNCTION  281()
Called 3 times
Total time:   0.000974
 Self time:   0.000789

count  total (s)   self (s)
    3              0.000007     if a:0
                                    let self._exec = a:1
                                else
    3              0.000012         let suffix = self._name . '_exec'
    3   0.000926   0.000741         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    3              0.000009     endif

FUNCTION  airline#extensions#tabline#tabs#invalidate()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000007   let s:current_bufnr = -1

FUNCTION  <SNR>137_handleSwitchbuf()
Called 2 times
Total time:   0.000085
 Self time:   0.000081

count  total (s)   self (s)
    2              0.000023 	if (a:switch == "start") && !empty(&swb)
                            		let s:swbSave = &swb
                            		set swb=
                            	elseif (a:switch == "stop") && exists("s:swbSave")
    1   0.000018   0.000014 		let &swb = s:swbSave
    1              0.000003 		unlet s:swbSave
    1              0.000002 	endif

FUNCTION  491()
Called 1 time
Total time:   0.000035
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000034   0.000026   let self.line_length = col([self.line(), '$'])

FUNCTION  492()
Called 3 times
Total time:   0.000954
 Self time:   0.000207

count  total (s)   self (s)
    3              0.000049   let self.visual = deepcopy(a:region)
    3   0.000104   0.000047   call s:cm.remove_highlight(self.visual_hi_id)
    3   0.000786   0.000096   let self.visual_hi_id = s:highlight_region(a:region)

FUNCTION  airline#extensions#ctrlp#apply()
Called 40 times
Total time:   0.000776
 Self time:   0.000776

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
   40              0.000675   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  airline#extensions#ctrlp#ctrlp_airline_status()
Called 7 times
Total time:   0.000173
 Self time:   0.000173

count  total (s)   self (s)
    7              0.000047   let len = '%#CtrlPdark# '.a:1
    7              0.000079   let dir = '%=%<%#CtrlParrow3#'.g:airline_right_sep.'%#CtrlPlight# '.getcwd().' %*'
    7              0.000027   return len.dir

FUNCTION  syntastic#util#rawVar()
Called 191 times
Total time:   0.002459
 Self time:   0.002459

count  total (s)   self (s)
  191              0.002199     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  497()
Called 4 times
Total time:   0.001928
 Self time:   0.001268

count  total (s)   self (s)
    4              0.000018   if a:restore_view
                                " Return the view back to the beginning
    2              0.000014     if !empty(self.saved_winview)
    2              0.000207       call winrestview(self.saved_winview)
    2              0.000004     endif
                            
                                " If the cursor moved, just restoring the view could get confusing, let's
                                " put the cursor at where the user left it. Only do this if we didn't start
                                " from find mode
    2   0.000077   0.000026     if !self.is_empty() && !self.start_from_find
    2   0.000064   0.000045       call cursor(self.get(0).position)
    2              0.000005     endif
    2              0.000003   endif
                            
                              " Delete all cursors and clear their highlights. Don't do clearmatches() as
                              " that will potentially interfere with other plugins
    4   0.000170   0.000077   if !self.is_empty()
    4   0.000055   0.000040     for i in range(self.size())
    2   0.000125   0.000052       call self.remove_highlight(self.get(i).cursor_hi_id)
    2   0.000112   0.000046       call self.remove_highlight(self.get(i).visual_hi_id)
    2              0.000005     endfor
    2              0.000002   endif
                            
    4              0.000067   let self.cursors = []
    4              0.000025   let self.current_index = -1
    4              0.000015   let self.starting_index = -1
    4              0.000020   let self.saved_winview = []
    4              0.000015   let self.start_from_find = 0
    4              0.000016   let s:char = ''
    4              0.000016   let s:saved_char = ''
    4              0.000014   if a:restore_setting
    2   0.000368   0.000041     call self.restore_user_settings()
    2              0.000004   endif
                              " Call after function if exists and only if action is canceled (<Esc>)
    4              0.000018   if a:0 && s:before_function_called
    2              0.000018     if exists('*Multiple_cursors_after')
                                  exe "call Multiple_cursors_after()"
                                endif
    2   0.000110   0.000094     silent doautocmd User MultipleCursorsPost
    2              0.000012     let s:before_function_called = 0
    2              0.000004   endif

FUNCTION  498()
Called 10 times
Total time:   0.000242
 Self time:   0.000156

count  total (s)   self (s)
   10   0.000230   0.000144   return self.size() == 0

FUNCTION  <SNR>63_dir()
Called 300 times
Total time:   0.385172
 Self time:   0.010585

count  total (s)   self (s)
  300   0.384676   0.010089   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  airline#themes#generate_color_map()
Called 44 times
Total time:   0.004423
 Self time:   0.004423

count  total (s)   self (s)
   44              0.001627   let palette = { 'airline_a': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , get(a:sect1 , 4 , '') ] , 'airline_b': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , get(a:sect2 , 4 , '') ] , 'airline_c': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , get(a:sect3 , 4 , '') ] , }
                            
   44              0.000111   if a:0 > 0
                                call extend(palette, { 'airline_x': [ a:1[0] , a:1[1] , a:1[2] , a:1[3] , get(a:1 , 4 , '' ) ] , 'airline_y': [ a:2[0] , a:2[1] , a:2[2] , a:2[3] , get(a:2 , 4 , '' ) ] , 'airline_z': [ a:3[0] , a:3[1] , a:3[2] , a:3[3] , get(a:3 , 4 , '' ) ] , })
                              else
   44              0.001339     call extend(palette, { 'airline_x': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , '' ] , 'airline_y': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , '' ] , 'airline_z': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , '' ] , })
   44              0.000071   endif
                            
   44              0.000088   return palette

FUNCTION  <SNR>278_Render()
Called 4 times
Total time:   0.168700
 Self time:   0.003670

count  total (s)   self (s)
    4   0.000190   0.000167 	let [&ma, lines, s:res_count] = [1, a:lines, len(a:lines)]
    4              0.000055 	let height = min([max([s:mw_min, s:res_count]), s:winmaxh])
    4   0.000392   0.000082 	let pat = s:byfname() ? split(a:pat, '^[^;]\+\\\@<!\zs;', 1)[0] : a:pat
    4              0.000037 	let cur_cmd = 'keepj norm! '.( s:mw_order == 'btt' ? 'G' : 'gg' ).'1|'
                            
                            	" Setup the match window
    4              0.000245 	sil! exe '%d _ | res' height
                            	" Print the new items
    4              0.000021 	if empty(lines)
                            		let [s:matched, s:lines] = [[], []]
                            		let lines = [' == NO ENTRIES ==']
                            		cal setline(1, s:offset(lines, height - 1))
                            		setl noma nocul
                            		exe cur_cmd
                            		cal s:unmarksigns()
                            		if s:dohighlight() | cal clearmatches() | en
                            		retu
                            	en
    4              0.000083 	let s:matched = copy(lines)
                            	" Sorting
    4   0.000474   0.000067 	if !s:nosort()
    4              0.000025 		let s:compat = s:martcs.pat
    4   0.157391   0.001294 		cal sort(lines, 's:mixedsort')
    4              0.000015 		unl s:compat
    4              0.000005 	en
    4              0.000044 	if s:mw_order == 'btt' | cal reverse(lines) | en
    4              0.000063 	let s:lines = copy(lines)
    4   0.006881   0.000442 	cal map(lines, s:flfunc)
    4   0.000226   0.000159 	cal setline(1, s:offset(lines, height))
    4   0.000212   0.000118 	cal s:unmarksigns()
    4   0.000119   0.000049 	cal s:remarksigns()
                            	" Highlighting
    4   0.000158   0.000044 	if s:dohighlight()
    4   0.001470   0.000095 		cal s:highlight(pat, s:mathi[1])
    4              0.000005 	en
    4   0.000187   0.000153 	setl noma cul
    4              0.000171 	exe cur_cmd

FUNCTION  airline#extensions#ctrlp#generate_color_map()
Called 9 times
Total time:   0.000318
 Self time:   0.000318

count  total (s)   self (s)
    9              0.000304   return { 'CtrlPdark'   : a:dark, 'CtrlPlight'  : a:light, 'CtrlPwhite'  : a:white, 'CtrlParrow1' : [ a:light[1] , a:white[1] , a:light[3] , a:white[3] , ''     ] , 'CtrlParrow2' : [ a:white[1] , a:light[1] , a:white[3] , a:light[3] , ''     ] , 'CtrlParrow3' : [ a:light[1] , a:dark[1]  , a:light[3] , a:dark[3]  , ''     ] , }

FUNCTION  <SNR>278_ispathitem()
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000022 	retu s:itemtype < len(s:coretypes) || s:getextvar('type') == 'path'

FUNCTION  <SNR>77_BufWritePostHook()
Called 2 times
Total time:   0.014179
 Self time:   0.000113

count  total (s)   self (s)
    2   0.000297   0.000028     let buf = syntastic#util#fname2buf(a:fname)
    2   0.000097   0.000054     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . buf . ' = ' . string(a:fname))
    2   0.013778   0.000024     call s:UpdateErrors(buf, 1, [])

FUNCTION  290()
Called 3 times
Total time:   0.020736
 Self time:   0.000159

count  total (s)   self (s)
    3   0.001008   0.000034     call self.syncExec()
                            
    3              0.000018     if !has_key(self, '_available')
    1              0.000004         let self._available = {}
    1              0.000002     endif
    3              0.000015     if !has_key(self._available, self._exec)
    1   0.019643   0.000040         let self._available[self._exec] = self._isAvailableFunc()
    1              0.000001     endif
                            
    3              0.000009     return self._available[self._exec]

FUNCTION  298()
Called 50 times
Total time:   0.002065
 Self time:   0.000550

count  total (s)   self (s)
   50   0.001990   0.000475     return syntastic#util#var('echo_current_error')

FUNCTION  299()
Called 25 times
Total time:   0.002273
 Self time:   0.001123

count  total (s)   self (s)
   25   0.001595   0.000445     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  gitgutter#utility#getbufvar()
Called 941 times
Total time:   0.027473
 Self time:   0.027473

count  total (s)   self (s)
  941              0.014184   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  941              0.006251   if has_key(dict, a:varname)
  939              0.003968     return dict[a:varname]
                              else
    2              0.000003     if a:0
                                  return a:1
                                endif
    2              0.000002   endif

FUNCTION  AutoPairsTryInit()
Called 23 times
Total time:   0.002017
 Self time:   0.000503

count  total (s)   self (s)
   23              0.000189   if exists('b:autopairs_loaded')
   22              0.000045     return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    1              0.000002   if g:AutoPairsMapCR
    1              0.000005     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    1              0.000038       let info = maparg('<CR>', 'i', 0, 1)
    1              0.000004       if empty(info)
    1              0.000003         let old_cr = '<CR>'
    1              0.000002         let is_expr = 0
    1              0.000001       else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
    1              0.000002     else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
    1              0.000009     if old_cr !~ 'AutoPairsReturn'
    1              0.000002       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
    1              0.000033       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    1              0.000002     end
    1              0.000001   endif
    1   0.001537   0.000023   call AutoPairsInit()

FUNCTION  ctrlspace#workspaces#ActiveWorkspace()
Called 1 time
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000012 	let aw = s:modes.Workspace.Data.Active
    1              0.000006 	let aw.Status = 0
                            
    1              0.000013 	if !empty(aw.Name) && aw.Root ==# ctrlspace#roots#CurrentProjectRoot()
                            		let aw.Status = 1
                            
                            		if aw.Digest !=# ctrlspace#workspaces#CreateDigest()
                            			let aw.Status = 2
                            		endif
                            	endif
                            
    1              0.000004 	return aw

FUNCTION  <SNR>63_windows()
Called 72 times
Total time:   0.002047
 Self time:   0.002047

count  total (s)   self (s)
   72              0.001902   return has('win64') || has('win32') || has('win16')

FUNCTION  <SNR>257_NewTabCatalogViewer()
Called 1 time
Total time:   0.002087
 Self time:   0.000407

count  total (s)   self (s)
                            
                                " initialize
    1   0.001701   0.000021     let catalog_viewer = s:NewCatalogViewer("[[buffergator-tabs]]", "buffergator")
    1              0.000010     let catalog_viewer["tab_catalog"] = []
                            
                                " Opens the buffer for viewing, creating it if needed.
                                " First argument, if given, should be false if the buffers info is *not*
                                " to be repopulated; defaults to 1
    1              0.000004     function! catalog_viewer.open(...) dict
                                    " populate data
                                    if (a:0 == 0 || a:1 > 0)
                                        call self.update_buffers_info()
                                    endif
                                    " get buffer number of the catalog view buffer, creating it if neccessary
                                    if self.bufnum < 0 || !bufexists(self.bufnum)
                                        " create and render a new buffer
                                        call self.create_buffer()
                                    else
                                        " buffer exists: activate a viewport on it according to the
                                        " spawning mode, re-rendering the buffer with the catalog if needed
                                        call self.activate_viewport()
                                        call self.render_buffer()
                                    endif
                                endfunction
                            
                                " Populates the buffer list
    1              0.000004     function! catalog_viewer.update_buffers_info() dict
                                    let self.tab_catalog = []
                                    for tabnum in range(1, tabpagenr('$'))
                                        call add(self.tab_catalog, tabpagebuflist(tabnum))
                                    endfor
                                    return self.tab_catalog
                                endfunction
                            
                                " Populates the buffer with the catalog index.
    1              0.000003     function! catalog_viewer.render_buffer() dict
                                    setlocal modifiable
                                    let l:cur_tab_num = tabpagenr()
                                    call self.claim_buffer()
                                    call self.clear_buffer()
                                    call self.setup_buffer_syntax()
                                    let self.jump_map = {}
                                    let l:initial_line = 1
                                    for l:tidx in range(len(self.tab_catalog))
                                        let l:tabinfo = self.tab_catalog[tidx]
                                        if l:cur_tab_num - 1 == l:tidx
                                            let l:initial_line = line("$")
                                        endif
                                        " let l:tabfield = "==== Tab Page [" . string(l:tidx+1) . "] ===="
                                        let l:tabfield = "TAB PAGE " . string(l:tidx+1) . ":"
                                        call self.append_line(l:tabfield, l:tidx+1, 1)
                                        for widx in range(len(l:tabinfo))
                                            let l:tabbufnum = l:tabinfo[widx]
                                            let l:tabbufname = bufname(l:tabbufnum)
                                            let subline = "[" . s:_format_filled(l:tabbufnum, 3, 1, 0) . "] "
                                            if getbufvar(l:tabbufnum, "&mod") == 1
                                                let subline .= "+ "
                                            else
                                                let subline .= "  "
                                            endif
                                            if self.display_regime == "basename"
                                                let l:subline .= s:_format_align_left(fnamemodify(l:tabbufname, ":t"), 30, " ")
                                                let l:subline .= fnamemodify(l:tabbufname, ":p:h")
                                            elseif self.display_regime == "parentdir"
                                                let l:subline .= s:_format_align_left(fnamemodify(l:tabbufname, ":t"), 30, " ")
                                                let l:subline .= fnamemodify(l:tabbufname, ":p:h:t")
                                            elseif self.display_regime == "filepath"
                                                let l:subline .= fnamemodify(l:tabbufname, ":p")
                                            elseif self.display_regime == "bufname"
                                                let l:subline .= l:tabbufname
                                            else
                                                throw s:_buffergator_messenger.format_exception("Invalid display regime: '" . self.display_regime . "'")
                                            endif
                                            call self.append_line(l:subline, l:tidx+1, l:widx+1)
                                        endfor
                                    endfor
                                    let b:buffergator_last_render_time = localtime()
                                    try
                                        " remove extra last line
                                        execute('normal! GV"_X')
                                    catch //
                                    endtry
                                    setlocal nomodifiable
                                    call cursor(l:initial_line, 1)
                                    " call self.goto_index_entry("n", 0, 1)
                                endfunction
                            
    1              0.000005     function! catalog_viewer.setup_buffer_syntax() dict
                                    if has("syntax") && !(exists('b:did_syntax'))
                                        syn match BuffergatorTabPageLine '^TAB PAGE \d\+\:$'
                                        " syn match BuffergatorTabPageLineStart '^==== Tab Page \[' nextgroup=BuffergatorTabPageNumber
                                        " syn match BuffergatorTabPageNumber '\d\+' nextgroup=BuffergatorTabPageLineEnd
                                        " syn match BuffergatorTabPageLineEnd '\] ====$'
                                        syn region BuffergatorModifiedFileLine start='^\[\s\{-}.\{-1,}\s\{-}\] + ' keepend oneline end='$'
                                        syn region BuffergatorUnmodifiedFileLine start='^\[\s\{-}.\{-1,}\s\{-}\]   ' keepend oneline end='$'
                                        syn match BuffergatorModifiedFileSyntaxKey '^\zs\[\s\{-}.\{-1,}\s\{-}\]\ze' containedin=BuffergatorModifiedFileLine nextgroup=BuffergatorModifiedFilename
                                        syn match BuffergatorUnmodifiedFileSyntaxKey '^\zs\[\s\{-}.\{-1,}\s\{-}\]\ze' containedin=BuffergatorUnmodifiedFileLine nextgroup=BuffergatorUnmodifiedFilename
                                        syn match BuffergatorModifiedFilename ' + .\+$' containedin=BuffergatorModifiedFilenameEntry
                                        syn match BuffergatorUnmodifiedFilename '   .\+$' containedin=BuffergatorUnmodifiedFileLine
                                        highlight! link BuffergatorModifiedFileSyntaxKey   LineNr
                                        highlight! link BuffergatorUnmodifiedFileSyntaxKey   LineNr
                                        highlight! link BuffergatorModifiedFileFlag   WarningMsg
                                        highlight! link BuffergatorModifiedFilename   WarningMsg
                                        highlight! link BuffergatorTabPageLine Title
                                        " highlight! link BufergatorModifiedFilename NonText
                                        " highlight! link BufergatorUnmodifiedFilename NonText
                                        " highlight! link BuffergatorTabPageLineStart Title
                                        " highlight! link BuffergatorTabPageNumber Special
                                        " highlight! link BuffergatorTabPageLineEnd Title
                                        highlight! link BuffergatorCurrentEntry CursorLine
                                        let b:did_syntax = 1
                                    endif
                                endfunction
                            
    1              0.000004     function! catalog_viewer.setup_buffer_keymaps() dict
                            
                                    call self.disable_editing_keymaps()
                            
                                    noremap <buffer> <silent> cd          :call b:buffergator_catalog_viewer.cycle_display_regime()<CR>
                                    noremap <buffer> <silent> r           :call b:buffergator_catalog_viewer.rebuild_catalog()<CR>
                                    noremap <buffer> <silent> q           :call b:buffergator_catalog_viewer.close(1)<CR>
                            
                                    noremap <buffer> <silent> <CR>        :call b:buffergator_catalog_viewer.visit_target()<CR>
                                    noremap <buffer> <silent> o           :call b:buffergator_catalog_viewer.visit_target()<CR>
                            
                                    noremap <buffer> <silent> <SPACE>     :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("n")<CR>
                                    noremap <buffer> <silent> <C-SPACE>   :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("p")<CR>
                                    noremap <buffer> <silent> <C-@>       :<C-U>call b:buffergator_catalog_viewer.goto_index_entry("p")<CR>
                                    noremap <buffer> <silent> <C-N>       :<C-U>call b:buffergator_catalog_viewer.goto_win_entry("n")<CR>
                                    noremap <buffer> <silent> <C-P>       :<C-U>call b:buffergator_catalog_viewer.goto_win_entry("p")<CR>
                                    noremap <buffer> <silent> A           :call b:buffergator_catalog_viewer.toggle_zoom()<CR>
                            
                                endfunction
                            
                                " Appends a line to the buffer and registers it in the line log.
    1              0.000005     function! catalog_viewer.append_line(text, jump_to_tabnum, jump_to_winnum) dict
                                    let l:line_map = { "target" : [a:jump_to_tabnum, a:jump_to_winnum], }
                                    if a:0 > 0
                                        call extend(l:line_map, a:1)
                                    endif
                                    let self.jump_map[line("$")] = l:line_map
                                    call append(line("$")-1, a:text)
                                endfunction
                            
    1              0.000004     function! catalog_viewer.goto_index_entry(direction) dict
                                    let l:ok = self.goto_pattern("^T", a:direction)
                                    execute("normal! zz")
                                    " if l:ok && a:visit_target
                                    "     call self.visit_target(1, a:refocus_catalog, "")
                                    " endif
                                endfunction
                            
    1              0.000004     function! catalog_viewer.goto_win_entry(direction) dict
                                    let l:ok = self.goto_pattern('^\[', a:direction)
                                    execute("normal! zz")
                                endfunction
                            
                                " Go to the selected buffer.
    1              0.000003     function! catalog_viewer.visit_target() dict
                                    let l:cur_line = line(".")
                                    if !has_key(l:self.jump_map, l:cur_line)
                                        call s:_buffergator_messenger.send_info("Not a valid navigation line")
                                        return 0
                                    endif
                                    let [l:jump_to_tabnum, l:jump_to_winnum] = self.jump_map[l:cur_line].target
                                    call self.close(0)
                                    execute("tabnext " . l:jump_to_tabnum)
                                    execute(l:jump_to_winnum . "wincmd w")
                                    " call s:_buffergator_messenger.send_info(expand(bufname(l:jump_to_bufnum)))
                                endfunction
                            
    1              0.000004     function! catalog_viewer.setup_buffer_statusline() dict
                                    if g:buffergator_tab_statusline
                                        setlocal statusline=%{BuffergatorTabsStatusLine()}
                                    endif
                                endfunction
                            
                                " return object
    1              0.000004     return catalog_viewer
                            

FUNCTION  <SNR>277_end_latency_measure()
Called 4 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
    4              0.000025   if g:multi_cursor_debug_latency && !empty(s:char)
                                if empty(s:latency_debug_file)
                                  let s:latency_debug_file = tempname()
                                  exec 'redir >> '.s:latency_debug_file
                                    silent! echom "Starting latency debug at ".reltimestr(reltime())
                                  redir END
                                endif
                            
                                if !s:skip_latency_measure
                                  exec 'redir >> '.s:latency_debug_file
                                    silent! echom "Processing '".s:char."' took ".string(str2float(reltimestr(reltime(s:start_time)))*1000).' ms in '.s:cm.size().' cursors. mode = '.s:from_mode
                                  redir END
                                endif
                              endif
    4              0.000015   let s:skip_latency_measure = 0

FUNCTION  509()
Called 2 times
Total time:   0.000376
 Self time:   0.000331

count  total (s)   self (s)
    2              0.000021   let self.saved_settings['virtualedit'] = &virtualedit
    2              0.000015   let self.saved_settings['cursorline'] = &cursorline
    2              0.000013   let self.saved_settings['lazyredraw'] = &lazyredraw
    2              0.000010   let self.saved_settings['paste'] = &paste
    2              0.000012   let self.saved_settings['clipboard'] = &clipboard
    2   0.000046   0.000034   let &virtualedit = "onemore"
    2   0.000032   0.000027   let &cursorline = 0
    2   0.000025   0.000022   let &lazyredraw = 1
    2   0.000028   0.000021   let &paste = 0
    2   0.000060   0.000042   set clipboard-=unnamed clipboard-=unnamedplus
                              " We could have already saved the view from multiple_cursors#find
    2              0.000009   if !self.start_from_find
    2              0.000025     let self.saved_winview = winsaveview()
    2              0.000004   endif
                            
                              " Save contents and type of unnamed register upon entering multicursor mode
                              " to restore it later when leaving mode
    2              0.000021   let s:paste_buffer_temporary_text = getreg('"')
    2              0.000019   let s:paste_buffer_temporary_type = getregtype('"')

FUNCTION  ctrlspace#util#WorkspaceFile()
Called 1 time
Total time:   0.000282
 Self time:   0.000051

count  total (s)   self (s)
    1   0.000281   0.000050 	return s:internalFilePath("cs_workspaces")

FUNCTION  <SNR>277_select_in_visual_mode()
Called 2 times
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
    2              0.000019   if a:region[0] == a:region[1]
                                normal! v
                              else
    2              0.000018     call cursor(a:region[1])
    2              0.000043     normal! m`
    2              0.000020     call cursor(a:region[0])
    2              0.000030     normal! v``
    2              0.000006   endif
                            
                              " Unselect and reselect it again to properly set the '< and '> markers
    2              0.000044   exec "normal! \<Esc>gv"

FUNCTION  <SNR>278_multipliers()
Called 108 times
Total time:   0.002855
 Self time:   0.002855

count  total (s)   self (s)
  108              0.000502 	let mp0 = !a:1 ? 0 : 2
  108              0.000596 	let mp1 = !a:2 ? 0 : 1 + ( !mp0 ? 1 : mp0 )
  108              0.000506 	let mp2 = !a:3 ? 0 : 1 + ( !( mp0 + mp1 ) ? 1 : ( mp0 + mp1 ) )
  108              0.000474 	let mp3 = !a:4 ? 0 : 1 + ( !( mp0 + mp1 + mp2 ) ? 1 : ( mp0 + mp1 + mp2 ) )
  108              0.000425 	retu [mp0, mp1, mp2, mp3]

FUNCTION  buffergator#UpdateBuffergator()
Called 26 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
   26              0.000112     if !(g:buffergator_autoupdate)
   26              0.000048         return
                                endif
                                let l:calling = bufnr("%")
                                let l:self_call = 0
                                let l:curr_winnr = winnr()
                                let l:prev_winnr = winnr("#")
                                let l:buffergators = s:_find_buffers_with_var("is_buffergator_buffer",1)
                                call s:_catalog_viewer.update_buffers_info()
                            
                                " BufDelete is the last Autocommand executed, but it's done BEFORE the
                                " buffer is actually deleted. - preemptively remove the buffer from
                                " the list if this is a delete event
                                if a:event == "delete"
                                    call filter(s:_catalog_viewer.buffers_catalog,'v:val["bufnum"] != ' . a:affected)
                                endif
                            
                                for l:gator in l:buffergators
                                    if bufwinnr(l:gator) > 0
                                        if l:calling != l:gator
                                            execute bufwinnr(l:gator) . "wincmd w"
                                        else
                                            let l:self_call = 1
                                        endif
                            
                                        " do not execute for tab view catalogs
                                        if has_key(b:buffergator_catalog_viewer, "tab_catalog")
                                            continue
                                        endif
                            
                                        call s:_catalog_viewer.render_buffer()
                            
                                        if !l:self_call
                                            call s:_catalog_viewer.highlight_current_line()
                                        endif
                                    endif
                                endfor
                                if exists("b:is_buffergator_buffer") && !l:self_call
                                    try
                                        execute l:prev_winnr . "wincmd w"
                                        execute l:curr_winnr . "wincmd w"
                                    catch //
                                    endtry
                                elseif a:event == 'delete' && !l:self_call
                                    try
                                        execute l:prev_winnr . "wincmd w"
                                        execute l:curr_winnr . "wincmd w"
                                    catch //
                                    endtry
                                endif

FUNCTION  airline#extensions#syntastic#get_warning()
Called 961 times
Total time:   0.288490
 Self time:   0.012266

count  total (s)   self (s)
  961   0.287258   0.011034   return airline#extensions#syntastic#get('warning')

FUNCTION  airline#highlighter#reset_hlcache()
Called 2 times
Total time:   0.000790
 Self time:   0.000790

count  total (s)   self (s)
    2              0.000788   let s:hl_groups = {}

FUNCTION  <SNR>77_BufWinEnterHook()
Called 22 times
Total time:   0.023748
 Self time:   0.001787

count  total (s)   self (s)
   22   0.021813   0.000319     let buf = syntastic#util#fname2buf(a:fname)
   22   0.001059   0.000592     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
   22              0.000164     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
   22              0.000238         let idx = index(reverse(copy(s:_check_stack)), buf)
   22              0.000082         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
                                    endif
   22              0.000023     endif

FUNCTION  airline#util#prepend()
Called 965 times
Total time:   0.016799
 Self time:   0.016799

count  total (s)   self (s)
  965              0.005123   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  965              0.006464   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>113_ws_refresh()
Called 180 times
Total time:   0.003569
 Self time:   0.003569

count  total (s)   self (s)
  180              0.002062   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
  154              0.000334     return
                              endif
   26              0.000113   unlet! b:airline_whitespace_check
   26              0.000156   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
   26              0.000129   let b:airline_ws_changedtick = b:changedtick

FUNCTION  css_color#reinit()
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000022 	call filter( keys( b:css_color_hi ), 's:create_highlight( v:val, s:color_bright[v:val] )' )

FUNCTION  <SNR>129_add_section()
Called 311 times
Total time:   0.054625
 Self time:   0.019932

count  total (s)   self (s)
  311              0.002983     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  311   0.009734   0.003646     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
  311              0.000583     if condition
                                  call a:builder.add_raw('%(')
                                endif
  311   0.035162   0.006557     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  311              0.000658     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  ctrlspace#roots#CurrentProjectRoot()
Called 5 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    5              0.000023 	return s:currentProjectRoot

FUNCTION  ctrlp#files()
Called 3 times
Total time: 162.317630
 Self time:   0.003216

count  total (s)   self (s)
    3   0.000374   0.000053 	let cafile = ctrlp#utils#cachefile()
    3   0.001762   0.001685 	if g:ctrlp_newcache || !filereadable(cafile) || s:nocache(cafile)
    1   0.000047   0.000032 		let [lscmd, s:initcwd, g:ctrlp_allfiles] = [s:lsCmd(), s:dyncwd, []]
                            		" Get the list of files
    1              0.000004 		if empty(lscmd)
    1   0.000598   0.000019 			if !ctrlp#igncwd(s:dyncwd)
    1   0.000041   0.000027 				cal s:InitCustomFuncs()
    1 161.974318   0.000064 				cal s:GlobPath(s:fnesc(s:dyncwd, 'g', ','), 0)
    1   0.000096   0.000069 				cal s:CloseCustomFuncs()
    1              0.000001 			en
    1              0.000001 		el
                            			sil! cal ctrlp#progress('Indexing...')
                            			try | cal s:UserCmd(lscmd)
                            			cat | retu [] | endt
                            		en
                            		" Remove base directory
    1   0.055296   0.000030 		cal ctrlp#rmbasedir(g:ctrlp_allfiles)
    1              0.000014 		if len(g:ctrlp_allfiles) <= s:compare_lim
                            			cal sort(g:ctrlp_allfiles, 'ctrlp#complen')
                            		en
    1   0.283913   0.000052 		cal s:writecache(cafile)
    1              0.000373 		let catime = getftime(cafile)
    1              0.000003 	el
    2              0.000468 		let catime = getftime(cafile)
    2              0.000039 		if !( exists('s:initcwd') && s:initcwd == s:dyncwd ) || get(s:ficounts, s:dyncwd, [0, catime])[1] != catime
                            			let s:initcwd = s:dyncwd
                            			let g:ctrlp_allfiles = ctrlp#utils#readfile(cafile)
                            		en
    2              0.000002 	en
    3              0.000049 	cal extend(s:ficounts, { s:dyncwd : [len(g:ctrlp_allfiles), catime] })
    3              0.000008 	retu g:ctrlp_allfiles

FUNCTION  <SNR>278_shortest()
Called 216 times
Total time:   0.002567
 Self time:   0.002567

count  total (s)   self (s)
  216              0.002327 	retu min(map(values(a:lens), 'v:val[0]'))

FUNCTION  <SNR>55_init()
Called 27 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
   27              0.000089   if s:airline_initialized
   27              0.000050     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  ctrlspace#window#Kill()
Called 2 times
Total time:   0.213580
 Self time:   0.001315

count  total (s)   self (s)
                            	" added workaround for strange Vim behavior when, when kill starts with some delay
                            	" (in a wrong buffer). This happens in some Nop modes (in a File List view).
    2              0.000040 	if (exists("s:killingNow") && s:killingNow) || (!a:pluginBuffer && &ft != "ctrlspace")
    1              0.000003 		return
                            	endif
                            
    1              0.000005 	let s:killingNow = 1
                            
    1              0.000015 	if exists("b:updatetimeSave")
    1   0.000040   0.000032 		silent! exe "set updatetime=" . b:updatetimeSave
    1              0.000003 	endif
                            
    1              0.000008 	if exists("b:timeoutlenSave")
    1   0.000046   0.000029 		silent! exe "set timeoutlen=" . b:timeoutlenSave
    1              0.000002 	endif
                            
    1              0.000008 	if exists("b:mouseSave")
    1   0.000032   0.000030 		silent! exe "set mouse=" . b:mouseSave
    1              0.000003 	endif
                            
                            	" shellslash support for win32
    1              0.000008 	if exists("b:nosslSave") && b:nosslSave
                            		set nossl
                            	endif
                            
    1              0.000003 	if a:pluginBuffer
                            		silent! exe ':' . a:pluginBuffer . 'bwipeout'
                            	else
    1              0.000118 		bwipeout
    1              0.000002 	endif
                            
    1              0.000002 	if a:final
    1   0.000094   0.000009 		call ctrlspace#util#HandleVimSettings("stop")
                            
    1              0.000003 		if s:modes.Search.Data.Restored
                            			call ctrlspace#search#AppendToSearchHistory()
                            		endif
                            
    1   0.000070   0.000033 		call ctrlspace#window#GoToStartWindow()
                            
    1              0.000003 		if s:modes.Zoom.Enabled
                            			exec ":b " . s:modes.Zoom.Data.Buffer
                            			call s:modes.Zoom.SetData("Buffer", 0)
                            			call s:modes.Zoom.Disable()
                            			call ctrlspace#buffers#DeleteForeignBuffers(1)
                            			call ctrlspace#buffers#DeleteHiddenNonameBuffers(1)
                            		endif
                            
    1   0.000023   0.000021 		set guicursor-=n:block-CtrlSpaceSelected-blinkon0
    1              0.000002 	endif
                            
    1              0.000003 	unlet s:killingNow

FUNCTION  <SNR>274_filler()
Called 1 time
Total time:   0.001248
 Self time:   0.001248

count  total (s)   self (s)
                            	" generate a variable to fill the buffer afterwards
                            	" (we need this for "full window" color :)
    1              0.000010 	if !exists("s:filler['" . &columns . "']")
    1              0.000003 		let fill = "\n"
    1              0.000003 		let i    = 0
                            
  121              0.000238 		while i < &columns
  120              0.000241 			let i += 1
  120              0.000413 			let fill = ' ' . fill
  120              0.000191 		endwhile
                            
    1              0.000010 		if !exists("s:filler")
    1              0.000004 			let s:filler = {}
    1              0.000001 		endif
                            
    1              0.000009 		let s:filler[string(&columns)] = fill
    1              0.000001 	endif
                            
    1              0.000006 	return s:filler[string(&columns)]

FUNCTION  gitgutter#diff#process_hunks()
Called 4 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    4              0.000017   let modified_lines = []
    4              0.000016   for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
                              endfor
    4              0.000010   return modified_lines

FUNCTION  <SNR>278_maxf()
Called 8 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    8              0.000046 	retu s:maxfiles && a:len > s:maxfiles

FUNCTION  ctrlspace#engine#Content()
Called 1 time
Total time:   0.005222
 Self time:   0.000159

count  total (s)   self (s)
    1              0.000007 	if !empty(s:config.FileEngine) && s:modes.File.Enabled
                            		return s:contentFromFileEngine()
                            	endif
                            
    1   0.001827   0.000025 	let items = s:contentSource()
                            
    1              0.000005 	if !empty(s:modes.Search.Data.Letters)
                            		let items = s:computeLowestNoises(items)
                            		call sort(items, function("ctrlspace#engine#CompareByNoiseAndText"))
                            	else
    1              0.000003 		if len(items) > 500
                            			let items = items[0:499]
                            		endif
                            
    1              0.000002 		if s:modes.Tab.Enabled
                            			call sort(items, function("ctrlspace#engine#CompareByIndex"))
                            		else
    1   0.000066   0.000027 			call sort(items, function("ctrlspace#engine#CompareByText"))
    1              0.000001 		endif
    1              0.000001 	endif
                            
                            	" trim the list in search mode
    1              0.000002 	if s:modes.Search.Enabled
                            		let maxHeight = ctrlspace#window#MaxHeight()
                            
                            		if len(items) > maxHeight
                            			let items = items[-maxHeight : -1]
                            		endif
                            	endif
                            
    1   0.003253   0.000031 	return s:prepareContent(items)

FUNCTION  ctrlspace#roots#SetCurrentProjectRoot()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000008 	let s:currentProjectRoot = a:value
    1              0.000004 	return s:currentProjectRoot

FUNCTION  ctrlspace#buffers#Buffers()
Called 144 times
Total time:   0.009482
 Self time:   0.009482

count  total (s)   self (s)
  144              0.000373 	if a:tabnr
  144              0.001014 		let buffers = gettabvar(a:tabnr, "CtrlSpaceList")
                            
                            		" Workaround for a Vim bug after :only and e.g. help window:
                            		" for the first time after :only gettabvar cannot properly ready any tab variable
                            		" More info: https://github.com/vim/vim/issues/394
                            		" TODO Remove when decided to drop support for Vim 7.3
  144              0.000609 		if type(buffers) == 1
                            			unlet buffers
                            			let buffers = gettabvar(a:tabnr, "CtrlSpaceList")
                            		endif
                            
  144              0.000508 		if type(buffers) != 4
                            			return {}
                            		endif
  144              0.000171 	else
                            		let buffers = s:allBuffers
                            	endif
                            
  144              0.003317 	return filter(buffers, "buflisted(str2nr(v:key))") " modify proper dictionary and return it

FUNCTION  <SNR>128_get_transitioned_seperator()
Called 408 times
Total time:   1.075207
 Self time:   0.031854

count  total (s)   self (s)
  408              0.001291   let line = ''
  408   0.528996   0.004854   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  408              0.003860   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
  408   0.523853   0.004642     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  408              0.003741     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  408              0.002758     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  408              0.002282     let line .= '%#'.a:group.'#'
  408              0.000526   endif
  408              0.000844   return line

FUNCTION  <SNR>277_start_latency_measure()
Called 4 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    4              0.000023   if g:multi_cursor_debug_latency
                                let s:start_time = reltime()
                              endif

FUNCTION  gitgutter#hunk#set_hunks()
Called 4 times
Total time:   0.000479
 Self time:   0.000132

count  total (s)   self (s)
    4   0.000202   0.000056   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    4   0.000265   0.000064   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>278_log()
Called 6 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
    6              0.000065 	if exists('g:ctrlp_log') && g:ctrlp_log | if a:m
                            		let cadir = ctrlp#utils#cachedir()
                            		let apd = g:ctrlp_log > 1 ? '>' : ''
                            		sil! exe 'redi! >'.apd cadir.s:lash(cadir).'ctrlp.log'
                            	el
                            		sil! redi END
                            	en | en

FUNCTION  airline#builder#new()
Called 82 times
Total time:   0.004196
 Self time:   0.004196

count  total (s)   self (s)
   82              0.001228   let builder = copy(s:prototype)
   82              0.000405   let builder._context = a:context
   82              0.000280   let builder._sections = []
                            
   82              0.001721   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   82              0.000179   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    8 1055.836252  88.879932  <SNR>278_GlobPath()
    3 162.741323   0.001102  ctrlp#init()
    3 162.318810   0.000245  ctrlp#setlines()
    3 162.317630   0.003216  ctrlp#files()
    8  15.455356   8.438285  ctrlp#dirnfile()
 1172  13.969506  12.585697  <SNR>149_parse_screen()
27903   7.016750             <SNR>278_usrign()
   70   6.320992   0.601845  airline#highlighter#highlight()
  972   6.120189   0.180941  airline#check_mode()
  208   5.359644   0.023420  gitgutter#process_buffer()
 8974   4.954012   1.332464  airline#highlighter#exec()
   68   4.577833   0.202115  gitgutter#diff#run_diff()
15133   4.573364   1.875299  airline#highlighter#get_highlight()
   72   3.647598   3.639252  gitgutter#async#execute()
 2658   3.312897   0.210606  <SNR>124_exec_separator()
30266   2.412186             <SNR>124_get_syn()
  961   2.235321   0.044263  airline#extensions#branch#get_head()
  961   2.191058   0.158760  airline#extensions#branch#head()
 5316   1.722402   0.086310  airline#themes#get_highlight()
   69   1.542226   0.108284  380()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    8 1055.836252  88.879932  <SNR>278_GlobPath()
 1172  13.969506  12.585697  <SNR>149_parse_screen()
    8  15.455356   8.438285  ctrlp#dirnfile()
27903              7.016750  <SNR>278_usrign()
   72   3.647598   3.639252  gitgutter#async#execute()
30266              2.412186  <SNR>124_get_syn()
15133   4.573364   1.875299  airline#highlighter#get_highlight()
 1194   1.518255   1.496803  <SNR>149_create_matches()
 8974   4.954012   1.332464  airline#highlighter#exec()
  961   1.202486   0.965613  <SNR>110_update_untracked()
  376              0.919471  <SNR>228_SearchForMatchingTag()
   64              0.846871  <SNR>159_write_buffer()
  676   0.825197   0.825012  <SNR>63_abs_path()
 7671              0.717185  ctrlp#utils#fnesc()
 1198              0.672314  <SNR>93_Highlight_Matching_Pair()
   70   6.320992   0.601845  airline#highlighter#highlight()
    7              0.519036  <SNR>55_get_airline_themes()
    4   0.460663   0.459014  ctrlp#utils#writecache()
 8974              0.441019  <SNR>124_CheckDefined()
  448   0.444700   0.428820  <SNR>65_repo_head_ref()

